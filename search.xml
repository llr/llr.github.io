<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shell不处理颜色转义码问题</title>
      <link href="post/9362.html"/>
      <url>post/9362.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><ul><li><p>在嵌入式linux系统中执行<code>systemctl</code>命令，颜色码无法转义，如下图：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl list-dependencies systemd-networkd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/9362/image-20210613203127072.png" alt="image-20210613203127072"></p></li></ul><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><ol><li><p>安装<code>less</code></p></li><li><p>或者在命令最后添加<code>--no-pager</code></p><pre class="line-numbers language-code" data-language="code"><code class="language-code">systemctl list-dependencies systemd-networkd --no-pager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/9362/image-20210613203508667.png" alt="image-20210613203508667"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemd基础</title>
      <link href="post/f81b.html"/>
      <url>post/f81b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-systemd功能"><a href="#1-systemd功能" class="headerlink" title="1. systemd功能"></a>1. systemd功能</h2><ul><li>查看systemd官网：<a href="https://www.freedesktop.org/wiki/Software/systemd/">https://www.freedesktop.org/wiki/Software/systemd/</a></li></ul><h2 id="2-分析booting过程"><a href="#2-分析booting过程" class="headerlink" title="2. 分析booting过程"></a>2. 分析booting过程</h2><ul><li><p>详情查看以下链接：</p><p><a href="https://en.wikipedia.org/wiki/Init">https://en.wikipedia.org/wiki/Init</a></p><p><a href="https://wiki.ubuntu.com/Booting">https://wiki.ubuntu.com/Booting</a></p></li><li><p>系统启动的第一个进程<code>pid</code>为1</p><p>执行<code>top</code>命令，然后按<code>Shift + v</code>以树形查看进程，如下图</p><p><img src="/post/f81b/image-20210613161303053.png" alt="image-20210613161303053"></p></li></ul><h2 id="3-使用systemctl工具"><a href="#3-使用systemctl工具" class="headerlink" title="3. 使用systemctl工具"></a>3. 使用systemctl工具</h2><blockquote><p><code>systemctl</code>工具用于和<code>systemd</code>守护进程进行交互</p></blockquote><p>参考：<a href="https://wiki.archlinux.org/title/Systemd">https://wiki.archlinux.org/title/Systemd</a></p><p><img src="/post/f81b/image-20210613162549047.png" alt="image-20210613162549047"></p><h3 id="3-1-查看systemd版本"><a href="#3-1-查看systemd版本" class="headerlink" title="3.1 查看systemd版本"></a>3.1 查看systemd版本</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/f81b/image-20210613161700647.png" alt="image-20210613161700647"></p><blockquote><p>-PAM -AUDIT -SELINUX -IMA -APPARMOR -SMACK +SYSVINIT -UTMP -LIBCRYPTSETUP -GCRYPT -GNUTLS -ACL -XZ -LZ4 -SECCOMP +BLKID -ELFUTILS -KMOD -IDN2 -IDN -PCRE2 default-hierarchy=hybrid</p><p>这是systemd支持的组件。  <code>+</code>：说明systemd开启了组件， <code>-</code>：说明systemd没有开启组件</p><p>可以在编译systemd的时候指定组件的<code>开启</code>或者<code>关闭</code></p></blockquote><h3 id="3-2-命令"><a href="#3-2-命令" class="headerlink" title="3.2 命令"></a>3.2 命令</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl以上命令没有加任何参数，相当于：systemctl list-unitssystemctl --state&#x3D;failed #查看状态为failed的unitsystemctl --state&#x3D;active#查看状态为active的unitsystemctl --state&#x3D;inactive#查看状态为inactive的unitsystemctl list-unit-files#列出所有的unit文件systemctl is-enabled systemd-networkd.service#查看服务是否自启动systemctl is-active systemd-networkd.service#查看服务是否处于活动状态systemctl cat systemd-networkd#查看unit文件内容systemctl list-dependencies systemd-networkd#查看服务所依赖的服务systemctl get-default#获取系统默认的targetsystemctl set-default multi-user.target#设置系统默认的targetsystemctl daemon-reload#重载所有修改过的配置文件systemctl list-timers --all#查看所有已启动的计时器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/post/f81b/image-20210613211702333.png" alt="image-20210613211702333"></p><p>以树形的结构显示systemd unit</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/f81b/image-20210613211724088.png" alt="image-20210613211724088"></p><h3 id="3-3-系统启动分析"><a href="#3-3-系统启动分析" class="headerlink" title="3.3 系统启动分析"></a>3.3 系统启动分析</h3><ul><li><p>使用以下命令可查看系统启动每个服务花费的时间</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemd-analyze blame<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/f81b/image-20210614232953906.png" alt="image-20210614232953906"></p><p>以下命令将生成已启动的系统服务的图形化（svg格式）详细信息，如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemd-analyze plot &gt; boot_analysis.svg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/f81b/image-20210614233125284.png" alt="image-20210614233125284"></p></li></ul><h2 id="4-挂载文件系统-mount"><a href="#4-挂载文件系统-mount" class="headerlink" title="4. 挂载文件系统(mount)"></a>4. 挂载文件系统(mount)</h2><h3 id="4-1-查看systemd-mount用法"><a href="#4-1-查看systemd-mount用法" class="headerlink" title="4.1 查看systemd.mount用法"></a>4.1 查看systemd.mount用法</h3><ul><li>man systemd.mount</li></ul><h3 id="4-2-挂载usb分区"><a href="#4-2-挂载usb分区" class="headerlink" title="4.2 挂载usb分区"></a>4.2 挂载usb分区</h3><ol><li><p>在/etc/systemd/system目录下创建<code>mnt-usb.mount</code></p><blockquote><p>注意：.mount文件命名规范为<code>挂载点的路径</code>，例如：将u盘挂载到<code>/mnt/usb</code>目录下，则<code>.mount</code>的文件命令应该为：<code>mnt-usb.mount</code></p></blockquote></li><li><p><code>mnt-usb.mount</code>文件内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Mount USB Device[Mount]What&#x3D;&#x2F;dev&#x2F;sda1Where&#x3D;&#x2F;mnt&#x2F;usbType&#x3D;vfat[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令进行<code>挂载</code>、<code>卸载</code>、<code>自启动</code>、<code>禁止自启动</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start mnt-usb.mountsystemctl stop mnt-usb.mountsystemctl enable mnt-usb.mountsystemctl disable mnt-usb.mount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="5-自动挂载文件系统-automount"><a href="#5-自动挂载文件系统-automount" class="headerlink" title="5. 自动挂载文件系统(automount)"></a>5. 自动挂载文件系统(automount)</h2><blockquote><p>当程序或者用户访问特定的路径的时候，就会触发与之关联的<code>.mount</code>，然后挂载文件系统</p></blockquote><h3 id="5-1-查看systemd-mount用法"><a href="#5-1-查看systemd-mount用法" class="headerlink" title="5.1 查看systemd.mount用法"></a>5.1 查看systemd.mount用法</h3><ul><li>man systemd.automount</li></ul><h3 id="5-2-自动挂载usb分区"><a href="#5-2-自动挂载usb分区" class="headerlink" title="5.2 自动挂载usb分区"></a>5.2 自动挂载usb分区</h3><ol><li><p>在/etc/systemd/system目录下创建<code>mnt-usb.automount</code></p></li><li><p><code>mnt-usb.automount</code>文件内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Auto Mount USB Device[Automount]Where&#x3D;&#x2F;mnt&#x2F;usb[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start mnt-usb.automountsystemctl status mnt-usb.automount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/post/f81b/image-20210613215116123.png" alt="image-20210613215116123"></p></li><li><p>当访问了<code>/mnt/usb</code>目录，就会自动挂载</p><p><img src="/post/f81b/image-20210613215429360.png" alt="image-20210613215429360"></p></li></ol><h2 id="6-timer类型unit"><a href="#6-timer类型unit" class="headerlink" title="6. timer类型unit"></a>6. timer类型unit</h2><blockquote><p>timer类型的unit用于定时触发服务</p><p>参考：<a href="https://wiki.archlinux.org/title/Systemd/Timers">https://wiki.archlinux.org/title/Systemd/Timers</a></p></blockquote><h3 id="6-1-定时任务-绝对时间"><a href="#6-1-定时任务-绝对时间" class="headerlink" title="6.1 定时任务(绝对时间)"></a>6.1 定时任务(绝对时间)</h3><ul><li><p>在<code>/etc/systemd/system</code>下新建<code>job.service</code>，内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Simple Job[Service]Type&#x3D;oneshotExecStart&#x3D;&#x2F;bin&#x2F;bash -c &quot;date &gt;&gt; &#x2F;tmp&#x2F;job.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>systemctl start job.service</code>测试服务是否正常运行，正常运行的话，将会在<code>/tmp</code>目录下创建<code>job.log</code>文件，如下</p><p><img src="/post/f81b/image-20210614120204636.png" alt="image-20210614120204636"></p></li><li><p>在<code>/etc/systemd/system</code>下新建<code>job.timer</code>，内容如下</p><blockquote><p>.timer文件名称需要和.service文件名称一致，如果.timer文件名称不一致，则需要在.timer文件中在<code>[Timer]</code>段中使用<code>Unit</code>来指定.service文件</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Simple Timer[Timer]#Unit&#x3D;job.serviceOnCalendar&#x3D;*:*:00[Install]WantedBy&#x3D;timers.target# *:*:00  定时器在每小时每分钟的0秒触发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/post/f81b/image-20210614121416882.png" alt="image-20210614121416882"></p></li></ul><h3 id="6-2-定时任务-相对时间"><a href="#6-2-定时任务-相对时间" class="headerlink" title="6.2 定时任务(相对时间)"></a>6.2 定时任务(相对时间)</h3><ul><li><p>在<code>/etc/systemd/system</code>下新建<code>job.service</code>，内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Simple Job[Service]Type&#x3D;oneshotExecStart&#x3D;&#x2F;bin&#x2F;bash -c &quot;date &gt;&gt; &#x2F;tmp&#x2F;job.log&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>systemctl start job.service</code>测试服务是否正常运行，正常运行的话，将会在<code>/tmp</code>目录下创建<code>job.log</code>文件，如下</p><p><img src="/post/f81b/image-20210614120204636.png" alt="image-20210614120204636"></p><p>在<code>/etc/systemd/system</code>下新建<code>job.timer</code>，内容如下</p><blockquote><p>.timer文件名称需要和.service文件名称一致，如果.timer文件名称不一致，则需要在.timer文件中在<code>[Timer]</code>段中使用<code>Unit</code>来指定.service文件</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Simple Timer[Timer]#Unit&#x3D;job.serviceOnBootSec&#x3D;1minOnUnitActiveSec&#x3D;10s[Install]WantedBy&#x3D;timers.target# OnBootSec&#x3D;1min   系统在启动1分钟后，触发该定时器（只会触发一次）# OnUnitActiveSec&#x3D;10s每10秒触发一次定时器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>systemctl start job.timer</code>启动定时器</p></li></ul><h2 id="7-preset用法"><a href="#7-preset用法" class="headerlink" title="7. preset用法"></a>7. preset用法</h2><blockquote><p>预设文件(<code>*.preset</code>)可用于设置哪些单元应该 默认启用/停用。</p></blockquote><ul><li><p>执行以下命令查看服务状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl status systemd-networkd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/f81b/image-20210614184619493.png" alt="image-20210614184619493"></p></li><li><p>查看<code>.preset</code>文件</p><p><img src="/post/f81b/image-20210614184911106.png" alt="image-20210614184911106"></p><p><img src="/post/f81b/image-20210614185009529.png" alt="image-20210614185009529"></p></li><li><p>使用以下命令可以使服务恢复到preset状态</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl preset systemd-networkd.service  #将systemd-networkd.service恢复到preset状态systemctl preset-all#将所有服务恢复到preset状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="8-socket类型unit"><a href="#8-socket类型unit" class="headerlink" title="8. socket类型unit"></a>8. socket类型unit</h2><blockquote><p>通过socket类型的unit激活对应的服务，可减少系统启动时间</p></blockquote><p>如下图为<code>sshd.socket</code>监听<code>22</code>端口，当客户端通过<code>ssh</code>远程连接时，会启动sshd.service服务</p><p><img src="/post/f81b/image-20210614225626227.png" alt="image-20210614225626227"></p>]]></content>
      
      
      <categories>
          
          <category> systemd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> systemd基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yocto-修改说明</title>
      <link href="post/2795.html"/>
      <url>post/2795.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量说明"><a href="#1-变量说明" class="headerlink" title="1. 变量说明"></a>1. 变量说明</h2><h3 id="1-1-指定生成文件系统镜像类型"><a href="#1-1-指定生成文件系统镜像类型" class="headerlink" title="1.1 指定生成文件系统镜像类型"></a>1.1 指定生成文件系统镜像类型</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">IMAGE_FSTYPES +&#x3D; &quot;tar.gz tar.bz2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-指定镜像文件的基本名称"><a href="#1-2-指定镜像文件的基本名称" class="headerlink" title="1.2 指定镜像文件的基本名称"></a>1.2 指定镜像文件的基本名称</h3><blockquote><p>该变量默认为菜谱名称 ${PN}</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export IMAGE_BASENAME &#x3D; &quot;arago-base-tisdk-image&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-指定需要安装哪些包到镜像中"><a href="#1-3-指定需要安装哪些包到镜像中" class="headerlink" title="1.3 指定需要安装哪些包到镜像中"></a>1.3 指定需要安装哪些包到镜像中</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">IMAGE_INSTALL +&#x3D; &quot;\    packagegroup-arago-base \    php \    iperf \    &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-指定配方的许可证"><a href="#1-4-指定配方的许可证" class="headerlink" title="1.4 指定配方的许可证"></a>1.4 指定配方的许可证</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LICENSE &#x3D; &quot;MIT&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-设置目标镜像的特性"><a href="#1-5-设置目标镜像的特性" class="headerlink" title="1.5 设置目标镜像的特性"></a>1.5 设置目标镜像的特性</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">IMAGE_FEATURES +&#x3D; &quot;package-management splash&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不止是包和包组，这些特性来自于 IMAGE_FEATURES 的定义，假设 :</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FEATURE_PACKAGES_widget &#x3D; &quot;package1 package2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，如果 <code>IMAGE_FEATURES</code> 中包含了 <code>widget</code> ，就包含了 <code>package1</code> 和 <code>package2</code> 。例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">MACHINE&#x3D;zc706-zynq7 bitbake -e petalinux-image | grep ^FEATURE_PACKAGESFEATURE_PACKAGES_ssh-server-dropbear&#x3D;&quot;packagegroup-core-ssh-dropbear&quot;FEATURE_PACKAGES_petalinux-benchmarks&#x3D;&quot;packagegroup-petalinux-benchmarks&quot;FEATURE_PACKAGES_petalinux-base&#x3D;&quot;packagegroup-petalinux&quot;FEATURE_PACKAGES_x11&#x3D;&quot;packagegroup-core-x11&quot;FEATURE_PACKAGES_nfs-server&#x3D;&quot;packagegroup-core-nfs-server&quot;FEATURE_PACKAGES_eclipse-debug&#x3D;&quot;packagegroup-core-eclipse-debug&quot;FEATURE_PACKAGES_petalinux-qt&#x3D;&quot;packagegroup-petalinux-qt&quot;FEATURE_PACKAGES_x11-base&#x3D;&quot;packagegroup-core-x11-base&quot;FEATURE_PACKAGES_petalinux-audio&#x3D;&quot;packagegroup-petalinux-audio&quot;FEATURE_PACKAGES_petalinux-gstreamer&#x3D;&quot;packagegroup-petalinux-gstreamer&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>IMAGE_FEATURES</code> 中定义的<code>petalinux-qt</code> 就表示 <code>packagegroup-petalinux-qt</code> ，可以在<code>sources</code>目录中直接搜索这个包组的 .bb 文件</p><h3 id="1-6-定位配方文件"><a href="#1-6-定位配方文件" class="headerlink" title="1.6 定位配方文件"></a>1.6 定位配方文件</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BBPATH .&#x3D; &quot;:$&#123;LAYERDIR&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用来定位<code>.bb</code>、<code>.bbclass</code>和<code>配置文件</code>等</p><h3 id="1-7-层路径变量-LAYERDIR"><a href="#1-7-层路径变量-LAYERDIR" class="headerlink" title="1.7 层路径变量(LAYERDIR)"></a>1.7 层路径变量(LAYERDIR)</h3><pre class="line-numbers language-none"><code class="language-none">BBPATH .&#x3D; &quot;:$&#123;LAYERDIR&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当在layer.conf配置文件中使用时，该变量提供当前层的路径</p><h3 id="1-8-指定新建的layer和openembedded-core版本兼容"><a href="#1-8-指定新建的layer和openembedded-core版本兼容" class="headerlink" title="1.8 指定新建的layer和openembedded-core版本兼容"></a>1.8 指定新建的layer和openembedded-core版本兼容</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LAYERSERIES_COMPAT_layer_root_name &#x3D; &quot;dunfell zeus&quot;LAYERSERIES_COMPAT_meta-zholpw01-4376 &#x3D; &quot;thud&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指定新创建的层和<code>openbedded - core</code>层哪个版本是兼容的，如果没有设置该变量，OpenEmbedded 构建系统就会生成一个警告，如下图</p><p><img src="/post/2795/image-20210611151008565.png" alt="image-20210611151008565"></p><h3 id="1-9-列出已配置层的名称，用于查找其他BBFILE-变量"><a href="#1-9-列出已配置层的名称，用于查找其他BBFILE-变量" class="headerlink" title="1.9 列出已配置层的名称，用于查找其他BBFILE_*变量"></a>1.9 列出已配置层的名称，用于查找其他BBFILE_*变量</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BBFILE_COLLECTIONS +&#x3D; &quot;meta-ti&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>BBFILE_COLLECTIONS</code>是层名字列表</p><h3 id="1-10-匹配特定层的BBFILES变量"><a href="#1-10-匹配特定层的BBFILES变量" class="headerlink" title="1.10 匹配特定层的BBFILES变量"></a>1.10 匹配特定层的BBFILES变量</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BBFILE_PATTERN_meta-ti :&#x3D; &quot;^$&#123;LAYERDIR&#125;&#x2F;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-11-指定层优先级"><a href="#1-11-指定层优先级" class="headerlink" title="1.11 指定层优先级"></a>1.11 指定层优先级</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BBFILE_PRIORITY_meta-ti &#x3D; &quot;6&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过设置这个变量，您可以将一个层与包含相同配方的其他层区分优先级，从而有效地控制多个层的优先级。通过这个变量建立的优先级与菜谱的版本无关(PV变量)。例如，如果一层的配方具有较高的PV值，但其<code>BBFILE_PRIORITY</code>被设置为具有较低的优先级，那么该层仍然具有较低的优先级。</li><li><code>BBFILE_PRIORITY</code>变量的值越大，优先级越高。例如，6的优先级高于5。</li><li>可以使用<code>bitbake-layers show-layers</code>命令可以列出所有已配置的层及其优先级。</li></ul><h3 id="1-12-指定许可证路径"><a href="#1-12-指定许可证路径" class="headerlink" title="1.12 指定许可证路径"></a>1.12 指定许可证路径</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LICENSE_PATH +&#x3D; &quot;$&#123;LAYERDIR&#125;&#x2F;licenses&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构建期间使用的附加许可的路径。默认情况下，OpenEmbedded构建系统使用COMMON_LICENSE_DIR来定义包含构建过程中使用的公共许可文本的目录。LICENSE_PATH变量允许您将该位置扩展到其他具有附加许可的区域</p><h3 id="1-13-指定需要依赖的层"><a href="#1-13-指定需要依赖的层" class="headerlink" title="1.13 指定需要依赖的层"></a>1.13 指定需要依赖的层</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LAYERDEPENDS_meta-arago-distro &#x3D; &quot; \    core \    meta-ti \    openembedded-layer \    networking-layer \    meta-python \    linaro-toolchain \    meta-optee \    qt5-layer \    browser-layer \    meta-arago-extras \&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-14-指定层的版本号"><a href="#1-14-指定层的版本号" class="headerlink" title="1.14 指定层的版本号"></a>1.14 指定层的版本号</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LAYERVERSION_meta-ti &#x3D; &quot;1&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-15-BB-DANGLINGAPPENDS-WARNONLY"><a href="#1-15-BB-DANGLINGAPPENDS-WARNONLY" class="headerlink" title="1.15 BB_DANGLINGAPPENDS_WARNONLY"></a>1.15 BB_DANGLINGAPPENDS_WARNONLY</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BB_DANGLINGAPPENDS_WARNONLY &#x3D; &quot;1&quot;   #出现警告，不退出BB_DANGLINGAPPENDS_WARNONLY &#x3D; &quot;0&quot;   #出现错误，退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义BitBake如何处理附加文件(<code>.bbappend</code>)没有对应的配方文件(<code>.bb</code>)的情况。</p><h3 id="1-16-RRECOMMENDS"><a href="#1-16-RRECOMMENDS" class="headerlink" title="1.16 RRECOMMENDS"></a>1.16 RRECOMMENDS</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">RRECOMMENDS_$&#123;PN&#125; &#x3D; &quot;depth-image-proc image-proc nodelet tf&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>扩展正在构建的包的可用性的包列表。正在构建的包并不依赖于这个包列表来成功构建，而是使用它们来扩展可用性。</p><h3 id="1-17-BAD-RECOMMENDATIONS"><a href="#1-17-BAD-RECOMMENDATIONS" class="headerlink" title="1.17 BAD_RECOMMENDATIONS"></a>1.17 BAD_RECOMMENDATIONS</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">BAD_RECOMMENDATIONS +&#x3D; &quot; \    ti-llvm3.6-dev \    opencl-monitor-dev \    libulm-dev \    gdbserver-c6x-dev \    coreutils \    coreutils-dev \&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过在<code>BAD_RECOMMENDATIONS</code>变量中列出<code>RRECOMMENDS指定的包</code>来防止它们被安装</p><h3 id="1-18-ROOTFS-POSTPROCESS-COMMAND"><a href="#1-18-ROOTFS-POSTPROCESS-COMMAND" class="headerlink" title="1.18 ROOTFS_POSTPROCESS_COMMAND"></a>1.18 ROOTFS_POSTPROCESS_COMMAND</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">create_modules_dir() &#123;    if [ ! -d $&#123;IMAGE_ROOTFS&#125;$&#123;base_libdir&#125;&#x2F;modules ]; then        mkdir $&#123;IMAGE_ROOTFS&#125;$&#123;base_libdir&#125;&#x2F;modules    fi&#125;ROOTFS_POSTPROCESS_COMMAND +&#x3D; &quot;create_modules_dir;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定OpenEmbedded构建系统创建根文件系统后要调用的函数列表。可以指定用分号分隔函数</p><p>参考：</p><p><a href="https://shaocheng.li/posts/2020/12/12/">https://shaocheng.li/posts/2020/12/12/</a></p>]]></content>
      
      
      <categories>
          
          <category> yocto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 修改说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv案例无法运行问题</title>
      <link href="post/3e8.html"/>
      <url>post/3e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><ul><li><p>运行系统自带的opencv demo，出现以下问题</p><p><img src="/post/3e8/image-20210609232729814.png" alt="image-20210609232729814"></p></li></ul><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h2><ul><li><p>OpenCV需要依赖于<code>GUI库</code>来绘制窗口，出现以上问题是因为在编译opencv没有指定<code>GUI库</code>导致的。</p><p><img src="/post/3e8/image-20210610002116242.png" alt="image-20210610002116242"></p><p>文档说明链接：<a href="https://docs.opencv.org/4.5.0/db/d05/tutorial_config_reference.html">https://docs.opencv.org/4.5.0/db/d05/tutorial_config_reference.html</a></p></li></ul><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><h3 id="3-1-基于yocto编译opencv-imx8"><a href="#3-1-基于yocto编译opencv-imx8" class="headerlink" title="3.1 基于yocto编译opencv(imx8)"></a>3.1 基于yocto编译opencv(imx8)</h3><ul><li><p>通过设置<code>PACKAGECONFIG</code>，使opencv使用<code>qt</code>作用GUI库</p><p><img src="/post/3e8/image-20210610002455109.png" alt="image-20210610002455109"></p><p>通过以下命令查看是否配置成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bitbake -e opencv | grep ^PACKAGECONFIG<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/3e8/image-20210610003847690.png" alt="image-20210610003847690"></p></li></ul><h3 id="3-2-基于源码编译opencv"><a href="#3-2-基于源码编译opencv" class="headerlink" title="3.2 基于源码编译opencv"></a>3.2 基于源码编译opencv</h3><ul><li>在使用cmake配置时，指定<code>-DWITH_QT=ON</code>即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gstreamer命令</title>
      <link href="post/5979.html"/>
      <url>post/5979.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h3 id="1-1-播放视频测试数据"><a href="#1-1-播放视频测试数据" class="headerlink" title="1.1 播放视频测试数据"></a>1.1 播放视频测试数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 videotestsrc ! &quot;video&#x2F;x-raw,width&#x3D;1280,height&#x3D;720&quot; ! autovideosinkgst-launch-1.0 videotestsrc ! &quot;video&#x2F;x-raw,width&#x3D;1280,height&#x3D;720&quot; ! timeoverlay ! autovideosink gst-launch-1.0 -v videotestsrc ! vertigotv ! videoconvert ! autovideosink<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>videotestsrc是一个source element，用于产生视频数据，通常用于调试。</li><li>timeoverlay是一个filter-like element，可以在视频数据中叠加一个时间字符串。</li><li>autovideosink用于自动选择视频输出设备，创建视频显示窗口，并显示其收到的数据。</li></ul><h3 id="1-2-播放本地视频文件"><a href="#1-2-播放本地视频文件" class="headerlink" title="1.2 播放本地视频文件"></a>1.2 播放本地视频文件</h3><p>测试文件<a href="http://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.ogv"> sintel_trailer-480p.ogv</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 filesrc location&#x3D;sintel_trailer-480p.ogv ! oggdemux name&#x3D;demux ! queue ! vorbisdec ! autoaudiosink demux. ! queue ! theoradec ! videoconvert ! autovideosink<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上面的命令播放文件时，会创建如下pipeline：</p><p><img src="/post/5979/image-20210604235706460.png" alt="image-20210604235706460"></p><p>可以看到这个pipeline由8个element构成，每个element都实现各自的功能：</p><ul><li>filesrc读取文件</li><li>oggdemux解析文件，分别提取audio,video数据</li><li>queue缓存数据</li><li>vorbisdec解码audio</li><li>autoaudiosink自动选择音频设备并输出</li><li>theoradec解码video</li><li>videoconvert转换video数据格式</li><li>autovideosink自动选择显示设备并输出</li></ul><blockquote><p>不同的element拥有不同数量及类型的pad，只有src pad的element被称为source element，只有sink pad的被称为sink element。</p><p>element可以同时拥有多个相同的pad，例如oggdemux在解析文件后，会将audio，video通过不同的pad输出。</p></blockquote><h3 id="1-3-ogv转码为mp4"><a href="#1-3-ogv转码为mp4" class="headerlink" title="1.3 ogv转码为mp4"></a>1.3 ogv转码为mp4</h3><p>测试视频：<a href="http://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.ogv"> sintel_trailer-480p.ogv</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 filesrc location&#x3D;sintel_trailer-480p.ogv ! decodebin name&#x3D;decode ! videoscale ! &quot;video&#x2F;x-raw,width&#x3D;640,height&#x3D;480&quot; ! x264enc ! queue !  mp4mux name&#x3D;mux ! filesink location&#x3D;test-480p.mp4 decode. ! audioconvert ! avenc_aac compliance&#x3D;experimental ! queue ! mux.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-播放mp4"><a href="#1-4-播放mp4" class="headerlink" title="1.4 播放mp4"></a>1.4 播放mp4</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 playbin uri&#x3D;file:&#x2F;&#x2F;&#x2F;home&#x2F;llr&#x2F;work&#x2F;demo&#x2F;gst-demo&#x2F;test-480p.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-udp-Streaming"><a href="#1-5-udp-Streaming" class="headerlink" title="1.5 udp Streaming"></a>1.5 udp Streaming</h3><p>server：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 -v videotestsrc ! &quot;video&#x2F;x-raw,framerate&#x3D;30&#x2F;1&quot; ! x264enc key-int-max&#x3D;30 ! rtph264pay ! udpsink host&#x3D;127.0.0.1 port&#x3D;1234<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>client：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 udpsrc port&#x3D;1234 ! &quot;application&#x2F;x-rtp, payload&#x3D;96&quot; ! rtph264depay ! decodebin ! autovideosink sync&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-6-播放音频测试数据"><a href="#1-6-播放音频测试数据" class="headerlink" title="1.6 播放音频测试数据"></a>1.6 播放音频测试数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 audiotestsrc ! audioconvert ! autoaudiosink<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>uridecodebin会中内部实例化所需的Elements（source，demuxer，decoder）将URI所指向的媒体文件中的各种媒体数据分别提取出来。因为其包含了demuxer，所以Source Pad在初始化阶段无法访问，只有在收到相应事件后去动态连接Pad。</li><li>audioconvert用于在不同的音频数据格式之间进行转换。由于不同的声卡支持的数据类型不尽相同，所以在某些平台需要对音频数据类型进行转换。</li><li>autoaudiosink会自动查找声卡设备，并将音频数据传输到声卡上进行输出。</li></ul><h3 id="1-7-仅播放视频中的音频"><a href="#1-7-仅播放视频中的音频" class="headerlink" title="1.7 仅播放视频中的音频"></a>1.7 仅播放视频中的音频</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 uridecodebin uri&#x3D;https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;gstreamer-sdk&#x2F;data&#x2F;media&#x2F;sintel_trailer-480p.webm ! audioconvert ! autoaudiosink<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-8-使用多线程将一路媒体数据分为两路数据输出"><a href="#1-8-使用多线程将一路媒体数据分为两路数据输出" class="headerlink" title="1.8 使用多线程将一路媒体数据分为两路数据输出"></a>1.8 使用多线程将一路媒体数据分为两路数据输出</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 audiotestsrc freq&#x3D;215.0 ! tee name&#x3D;t ! queue ! audioconvert ! audioresample ! autoaudiosink t. ! queue ! wavescope shader&#x3D;0 style&#x3D;1 ! videoconvert ! autovideosink sync&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/5979/image-20210605175326882.png" alt="image-20210605175326882"></p><blockquote><p>在上面的示例Pipeline中，souce是audiotestsrc，会产生一个相应的audio信号，然后使用tee Element将数据分为两路，一路被用于播放，通过声卡输出，另一路被用于转换为视频波形，用于输出到屏幕。<br>示例图中的红色阴影部分表示位于同一个线程中，queue会创建单独的线程，所以上面的Pipeline使用了3个线程完成相应的功能。拥有多个sink的Pipeline通常需要多个线程，因为在多个sync间进行同步的时候，sink会阻塞当前所在线程直到所等待的事件发生。</p></blockquote><h3 id="1-9-多分支管道"><a href="#1-9-多分支管道" class="headerlink" title="1.9 多分支管道"></a>1.9 多分支管道</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gst-launch-1.0 videotestsrc ! videoconvert ! tee name&#x3D;t ! queue ! autovideosink t. ! queue ! autovideosink<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-常用插件"><a href="#2-常用插件" class="headerlink" title="2. 常用插件"></a>2. 常用插件</h2><table><thead><tr><th align="center">videotestsrc</th><th>用于生成各种格式的测试视频数据</th></tr></thead><tbody><tr><td align="center">videoconvert</td><td>用于多种视频格式之间转换</td></tr><tr><td align="center">autovideosink</td><td>视频接收器，可以自动检测要使用的适当视频接收器</td></tr><tr><td align="center">videoscale</td><td>用于调整视频分辨率的大小</td></tr><tr><td align="center">audiotestsrc</td><td>用于生成各种格式的测试音频数据</td></tr><tr><td align="center">audioconvert</td><td>用于多种音频格式之间转换</td></tr><tr><td align="center">audioresample</td><td>对音频数据重新采样</td></tr><tr><td align="center">autoaudiosink</td><td>音频接收器，可以自动检测要使用的适当的音频接收器。</td></tr><tr><td align="center">tee</td><td>用于将一路数据拆分为多路输出</td></tr><tr><td align="center">queue</td><td>队列，会在source pad创建新的线程</td></tr><tr><td align="center">souphttpsrc</td><td>从一个 URI 指定的远程位置读取数据，支持的协议是 http，https。</td></tr><tr><td align="center">matroskademux</td><td>将一个Matroska 文件分解成不同的流（分别为：音频流和数据流）</td></tr><tr><td align="center">matroskamux</td><td>将不同的输入流(<code>视频流和音频流</code>)转换成 Matroska 文件</td></tr><tr><td align="center">filesrc</td><td>从本地文件读取数据</td></tr><tr><td align="center">filesink</td><td>将传入的数据写入本地文件</td></tr><tr><td align="center">playbin</td><td>用于播放媒体文件</td></tr><tr><td align="center">decodebin</td><td>自动选择可用的解码器进行解码</td></tr><tr><td align="center">uridecodebin</td><td>将 URI 中的数据解码为原始媒体</td></tr><tr><td align="center">fakesrc</td><td>用于生成空的缓冲区</td></tr><tr><td align="center">fakesink</td><td>用于丢弃不需要的数据，类似于Linux的/dev/null</td></tr><tr><td align="center">fpsdisplaysink</td><td>显示当前和平均帧率</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> gstreamer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gstreamer命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pkg-config命令</title>
      <link href="post/4583.html"/>
      <url>post/4583.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-pkg-config命令的作用"><a href="#1-pkg-config命令的作用" class="headerlink" title="1. pkg-config命令的作用"></a>1. pkg-config命令的作用</h2><ul><li>用于返回已安装的库的元信息，能够列出系统已经安装的库的相关信息。如 <code>库的路径</code> 和 <code>头文件路径</code>。特别是在预处理和编译的时候，能够告诉 gcc 等编译器，程序依赖的库和头文件的位置。</li></ul><h2 id="2-pkg-config命令原理"><a href="#2-pkg-config命令原理" class="headerlink" title="2. pkg-config命令原理"></a>2. pkg-config命令原理</h2><ul><li><p>pkg-config命令是通过查询<code>.pc</code>后缀的文件来检索包的信息，在大多数系统中，会在以下位置查找<code>.pc</code>文件</p><ul><li>/usr/lib/pkgconfig</li><li>/usr/share/pkgconfig</li><li>/usr/local/lib/pkgconfig</li><li>/usr/local/share/pkgconfig</li></ul></li><li><p>可以通过设置<code>PKG_CONFIG_PATH</code>环境变量，<code>pkg-config</code>命令会读取这个环境变量从而在指定的位置下查找<code>.pc</code>文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PKG_CONFIG_PATH&#x3D;&#x2F;home&#x2F;llr&#x2F;work&#x2F;demo&#x2F;gst-demo:$PKG_CONFIG_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>ubuntu16.04安装包后，<code>.pc</code>文件在/usr/lib/x86_64-linux-gnu/pkgconfig目录下</p></blockquote></li></ul><h2 id="3-pkg-config命令使用"><a href="#3-pkg-config命令使用" class="headerlink" title="3. pkg-config命令使用"></a>3. pkg-config命令使用</h2><h3 id="3-1-列出所有已经安装的库"><a href="#3-1-列出所有已经安装的库" class="headerlink" title="3.1 列出所有已经安装的库"></a>3.1 列出所有已经安装的库</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pkg-config --list-all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4583/image-20210603233210963.png" alt="image-20210603233210963"></p><h3 id="3-2-列出指定库的预处理和编译flag"><a href="#3-2-列出指定库的预处理和编译flag" class="headerlink" title="3.2 列出指定库的预处理和编译flag"></a>3.2 列出指定库的预处理和编译flag</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pkg-config --cflags gstreamer-1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4583/image-20210603233743611.png" alt="image-20210603233743611"></p><h3 id="3-3-列出指定库的链接flag"><a href="#3-3-列出指定库的链接flag" class="headerlink" title="3.3 列出指定库的链接flag"></a>3.3 列出指定库的链接flag</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pkg-config --libs gstreamer-1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4583/image-20210603233921087.png" alt="image-20210603233921087"></p><h3 id="3-4-输出包的版本"><a href="#3-4-输出包的版本" class="headerlink" title="3.4 输出包的版本"></a>3.4 输出包的版本</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pkg-config --modversion gstreamer-base-1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4583/image-20210603235709585.png" alt="image-20210603235709585"></p><h3 id="3-5-输出需要依赖的软件包"><a href="#3-5-输出需要依赖的软件包" class="headerlink" title="3.5 输出需要依赖的软件包"></a>3.5 输出需要依赖的软件包</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pkg-config --print-requires gstreamer-1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4583/image-20210604005904417.png" alt="image-20210604005904417"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++提高编程</title>
      <link href="post/366d.html"/>
      <url>post/366d.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul><li><p>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</p><p>内容来源于黑马程序员</p></li></ul><h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><p>一寸照片模板：</p><p><img src="/post/366d/1547105026929.png" alt="1547105026929"></p><p>PPT模板：</p><p><img src="/post/366d/1547103297864.png" alt="1547103297864"></p><p><img src="/post/366d/1547103359158.png" alt="1547103359158"></p><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul><li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li></ul><ul><li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li></ul><h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong> </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;函数声明或定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;交换整型函数void swapInt(int&amp; a, int&amp; b) &#123;int temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;&#x2F;&#x2F;交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123;double temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;&#x2F;&#x2F;利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123;T temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;void test01()&#123;int a &#x3D; 10;int b &#x3D; 20;&#x2F;&#x2F;swapInt(a, b);&#x2F;&#x2F;利用模板实现交换&#x2F;&#x2F;1、自动类型推导mySwap(a, b);&#x2F;&#x2F;2、显示指定类型mySwap&lt;int&gt;(a, b);cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li></ul><ul><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123;T temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;&#x2F;&#x2F; 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123;int a &#x3D; 10;int b &#x3D; 20;char c &#x3D; &#39;c&#39;;mySwap(a, b); &#x2F;&#x2F; 正确，可以推导出一致的T&#x2F;&#x2F;mySwap(a, c); &#x2F;&#x2F; 错误，推导不出一致的T类型&#125;&#x2F;&#x2F; 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123;cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123;&#x2F;&#x2F;func(); &#x2F;&#x2F;错误，模板不能独立使用，必须确定出T的类型func&lt;int&gt;(); &#x2F;&#x2F;利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123;T temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;template&lt;class T&gt; &#x2F;&#x2F; 也可以替换成typename&#x2F;&#x2F;利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123;for (int i &#x3D; 0; i &lt; len; i++)&#123;int max &#x3D; i; &#x2F;&#x2F;最大数的下标for (int j &#x3D; i + 1; j &lt; len; j++)&#123;if (arr[max] &lt; arr[j])&#123;max &#x3D; j;&#125;&#125;if (max !&#x3D; i) &#x2F;&#x2F;如果最大数的下标不是i，交换两者&#123;mySwap(arr[max], arr[i]);&#125;&#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123;for (int i &#x3D; 0; i &lt; len; i++) &#123;cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;&#x2F;&#x2F;测试char数组char charArr[] &#x3D; &quot;bdcfeagh&quot;;int num &#x3D; sizeof(charArr) &#x2F; sizeof(char);mySort(charArr, num);printArray(charArr, num);&#125;void test02()&#123;&#x2F;&#x2F;测试int数组int intArr[] &#x3D; &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;int num &#x3D; sizeof(intArr) &#x2F; sizeof(int);mySort(intArr, num);printArray(intArr, num);&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;普通函数int myAdd01(int a, int b)&#123;return a + b;&#125;&#x2F;&#x2F;函数模板template&lt;class T&gt;T myAdd02(T a, T b)  &#123;return a + b;&#125;&#x2F;&#x2F;使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123;int a &#x3D; 10;int b &#x3D; 20;char c &#x3D; &#39;c&#39;;cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; &#x2F;&#x2F;正确，将char类型的&#39;c&#39;隐式转换为int类型  &#39;c&#39; 对应 ASCII码 99&#x2F;&#x2F;myAdd02(a, c); &#x2F;&#x2F; 报错，使用自动类型推导时，不会发生隐式类型转换myAdd02&lt;int&gt;(a, c); &#x2F;&#x2F;正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;普通函数与函数模板调用规则void myPrint(int a, int b)&#123;cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123;&#x2F;&#x2F;1、如果函数模板和普通函数都可以实现，优先调用普通函数&#x2F;&#x2F; 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到int a &#x3D; 10;int b &#x3D; 20;myPrint(a, b); &#x2F;&#x2F;调用普通函数&#x2F;&#x2F;2、可以通过空模板参数列表来强制调用函数模板myPrint&lt;&gt;(a, b); &#x2F;&#x2F;调用函数模板&#x2F;&#x2F;3、函数模板也可以发生重载int c &#x3D; 30;myPrint(a, b, c); &#x2F;&#x2F;调用重载的函数模板&#x2F;&#x2F;4、 如果函数模板可以产生更好的匹配,优先调用函数模板char c1 &#x3D; &#39;a&#39;;char c2 &#x3D; &#39;b&#39;;myPrint(c1, c2); &#x2F;&#x2F;调用函数模板&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;void f(T a, T b)&#123;    a &#x3D; b;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;void f(T a, T b)&#123;    if(a &gt; b) &#123; ... &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;string m_Name;int m_Age;&#125;;&#x2F;&#x2F;普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123;if (a &#x3D;&#x3D; b)&#123;return true;&#125;else&#123;return false;&#125;&#125;&#x2F;&#x2F;具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型&#x2F;&#x2F;具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;if ( p1.m_Name  &#x3D;&#x3D; p2.m_Name &amp;&amp; p1.m_Age &#x3D;&#x3D; p2.m_Age)&#123;return true;&#125;else&#123;return false;&#125;&#125;void test01()&#123;int a &#x3D; 10;int b &#x3D; 20;&#x2F;&#x2F;内置数据类型可以直接使用通用的函数模板bool ret &#x3D; myCompare(a, b);if (ret)&#123;cout &lt;&lt; &quot;a &#x3D;&#x3D; b &quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;a !&#x3D; b &quot; &lt;&lt; endl;&#125;&#125;void test02()&#123;Person p1(&quot;Tom&quot;, 10);Person p2(&quot;Tom&quot;, 10);&#x2F;&#x2F;自定义数据类型，不会调用普通的函数模板&#x2F;&#x2F;可以创建具体化的Person数据类型的模板，用于特殊处理这个类型bool ret &#x3D; myCompare(p1, p2);if (ret)&#123;cout &lt;&lt; &quot;p1 &#x3D;&#x3D; p2 &quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;p1 !&#x3D; p2 &quot; &lt;&lt; endl;&#125;&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong> </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public:Person(NameType name, AgeType age)&#123;this-&gt;mName &#x3D; name;this-&gt;mAge &#x3D; age;&#125;void showPerson()&#123;cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;&#125;public:NameType mName;AgeType mAge;&#125;;void test01()&#123;&#x2F;&#x2F; 指定NameType 为string类型，AgeType 为 int类型Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);P1.showPerson();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;类模板template&lt;class NameType, class AgeType &#x3D; int&gt; class Person&#123;public:Person(NameType name, AgeType age)&#123;this-&gt;mName &#x3D; name;this-&gt;mAge &#x3D; age;&#125;void showPerson()&#123;cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;&#125;public:NameType mName;AgeType mAge;&#125;;&#x2F;&#x2F;1、类模板没有自动类型推导的使用方式void test01()&#123;&#x2F;&#x2F; Person p(&quot;孙悟空&quot;, 1000); &#x2F;&#x2F; 错误 类模板使用时候，不可以用自动类型推导Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); &#x2F;&#x2F;必须使用显示指定类型的方式，使用类模板p.showPerson();&#125;&#x2F;&#x2F;2、类模板在模板参数列表中可以有默认参数void test02()&#123;Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); &#x2F;&#x2F;类模板中的模板参数列表 可以指定默认参数p.showPerson();&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person1&#123;public:void showPerson1()&#123;cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;&#125;&#125;;class Person2&#123;public:void showPerson2()&#123;cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;&#125;&#125;;template&lt;class T&gt;class MyClass&#123;public:T obj;&#x2F;&#x2F;类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成void fun1() &#123; obj.showPerson1(); &#125;void fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123;MyClass&lt;Person1&gt; m;m.fun1();&#x2F;&#x2F;m.fun2();&#x2F;&#x2F;编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;类模板template&lt;class NameType, class AgeType &#x3D; int&gt; class Person&#123;public:Person(NameType name, AgeType age)&#123;this-&gt;mName &#x3D; name;this-&gt;mAge &#x3D; age;&#125;void showPerson()&#123;cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;&#125;public:NameType mName;AgeType mAge;&#125;;&#x2F;&#x2F;1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123;p.showPerson();&#125;void test01()&#123;Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);printPerson1(p);&#125;&#x2F;&#x2F;2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123;p.showPerson();cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123;Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);printPerson2(p);&#125;&#x2F;&#x2F;3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123;cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;p.showPerson();&#125;void test03()&#123;Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);printPerson3(p);&#125;int main() &#123;test01();test02();test03();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class Base&#123;T m;&#125;;&#x2F;&#x2F;class Son:public Base  &#x2F;&#x2F;错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; &#x2F;&#x2F;必须指定一个类型&#123;&#125;;void test01()&#123;Son c;&#125;&#x2F;&#x2F;类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public:Son2()&#123;cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;&#125;;void test02()&#123;Son2&lt;int, char&gt; child1;&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public:&#x2F;&#x2F;成员函数类内声明Person(T1 name, T2 age);void showPerson();public:T1 m_Name;T2 m_Age;&#125;;&#x2F;&#x2F;构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;&#x2F;&#x2F;成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123;Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);p.showPerson();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public:Person(T1 name, T2 age);void showPerson();public:T1 m_Name;T2 m_Age;&#125;;&#x2F;&#x2F;构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;&#x2F;&#x2F;成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类模板分文件编写.cpp中代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F;#include &quot;person.h&quot;#include &quot;person.cpp&quot; &#x2F;&#x2F;解决方式1，包含cpp源文件&#x2F;&#x2F;解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123;Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);p.showPerson();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;&#x2F;&#x2F;如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到&#x2F;&#x2F;template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123;cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123;&#x2F;&#x2F;1、全局函数配合友元   类内实现friend void printPerson(Person&lt;T1, T2&gt; &amp; p)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;&#x2F;&#x2F;全局函数配合友元  类外实现friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public:Person(T1 name, T2 age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;private:T1 m_Name;T2 m_Age;&#125;;&#x2F;&#x2F;1、全局函数在类内实现void test01()&#123;Person &lt;string, int &gt;p(&quot;Tom&quot;, 20);printPerson(p);&#125;&#x2F;&#x2F;2、全局函数在类外实现void test02()&#123;Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30);printPerson2(p);&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public:    &#x2F;&#x2F;构造函数MyArray(int capacity)&#123;this-&gt;m_Capacity &#x3D; capacity;this-&gt;m_Size &#x3D; 0;pAddress &#x3D; new T[this-&gt;m_Capacity];&#125;&#x2F;&#x2F;拷贝构造MyArray(const MyArray &amp; arr)&#123;this-&gt;m_Capacity &#x3D; arr.m_Capacity;this-&gt;m_Size &#x3D; arr.m_Size;this-&gt;pAddress &#x3D; new T[this-&gt;m_Capacity];for (int i &#x3D; 0; i &lt; this-&gt;m_Size; i++)&#123;&#x2F;&#x2F;如果T为对象，而且还包含指针，必须需要重载 &#x3D; 操作符，因为这个等号不是 构造 而是赋值，&#x2F;&#x2F; 普通类型可以直接&#x3D; 但是指针类型需要深拷贝this-&gt;pAddress[i] &#x3D; arr.pAddress[i];&#125;&#125;&#x2F;&#x2F;重载&#x3D; 操作符  防止浅拷贝问题MyArray&amp; operator&#x3D;(const MyArray&amp; myarray) &#123;if (this-&gt;pAddress !&#x3D; NULL) &#123;delete[] this-&gt;pAddress;this-&gt;m_Capacity &#x3D; 0;this-&gt;m_Size &#x3D; 0;&#125;this-&gt;m_Capacity &#x3D; myarray.m_Capacity;this-&gt;m_Size &#x3D; myarray.m_Size;this-&gt;pAddress &#x3D; new T[this-&gt;m_Capacity];for (int i &#x3D; 0; i &lt; this-&gt;m_Size; i++) &#123;this-&gt;pAddress[i] &#x3D; myarray[i];&#125;return *this;&#125;&#x2F;&#x2F;重载[] 操作符  arr[0]T&amp; operator [](int index)&#123;return this-&gt;pAddress[index]; &#x2F;&#x2F;不考虑越界，用户自己去处理&#125;&#x2F;&#x2F;尾插法void Push_back(const T &amp; val)&#123;if (this-&gt;m_Capacity &#x3D;&#x3D; this-&gt;m_Size)&#123;return;&#125;this-&gt;pAddress[this-&gt;m_Size] &#x3D; val;this-&gt;m_Size++;&#125;&#x2F;&#x2F;尾删法void Pop_back()&#123;if (this-&gt;m_Size &#x3D;&#x3D; 0)&#123;return;&#125;this-&gt;m_Size--;&#125;&#x2F;&#x2F;获取数组容量int getCapacity()&#123;return this-&gt;m_Capacity;&#125;&#x2F;&#x2F;获取数组大小intgetSize()&#123;return this-&gt;m_Size;&#125;&#x2F;&#x2F;析构~MyArray()&#123;if (this-&gt;pAddress !&#x3D; NULL)&#123;delete[] this-&gt;pAddress;this-&gt;pAddress &#x3D; NULL;this-&gt;m_Capacity &#x3D; 0;this-&gt;m_Size &#x3D; 0;&#125;&#125;private:T * pAddress;  &#x2F;&#x2F;指向一个堆空间，这个空间存储真正的数据int m_Capacity; &#x2F;&#x2F;容量int m_Size;   &#x2F;&#x2F; 大小&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类模板案例—数组类封装.cpp中</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;for (int i &#x3D; 0; i &lt; arr.getSize(); i++) &#123;cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;测试内置数据类型void test01()&#123;MyArray&lt;int&gt; array1(10);for (int i &#x3D; 0; i &lt; 10; i++)&#123;array1.Push_back(i);&#125;cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;printIntArray(array1);cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;MyArray&lt;int&gt; array2(array1);array2.Pop_back();cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;printIntArray(array2);cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;&#x2F;&#x2F;测试自定义数据类型class Person &#123;public:Person() &#123;&#125; Person(string name, int age) &#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;public:string m_Name;int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123;for (int i &#x3D; 0; i &lt; personArr.getSize(); i++) &#123;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;&#125;&#125;void test02()&#123;&#x2F;&#x2F;创建数组MyArray&lt;Person&gt; pArray(10);Person p1(&quot;孙悟空&quot;, 30);Person p2(&quot;韩信&quot;, 20);Person p3(&quot;妲己&quot;, 18);Person p4(&quot;王昭君&quot;, 15);Person p5(&quot;赵云&quot;, 24);&#x2F;&#x2F;插入数据pArray.Push_back(p1);pArray.Push_back(p2);pArray.Push_back(p3);pArray.Push_back(p4);pArray.Push_back(p5);printPersonArray(pArray);cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;void MyPrint(int val)&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123;&#x2F;&#x2F;创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型vector&lt;int&gt; v;&#x2F;&#x2F;向容器中放数据v.push_back(10);v.push_back(20);v.push_back(30);v.push_back(40);&#x2F;&#x2F;每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素&#x2F;&#x2F;v.begin()返回迭代器，这个迭代器指向容器中第一个数据&#x2F;&#x2F;v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置&#x2F;&#x2F;vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型vector&lt;int&gt;::iterator pBegin &#x3D; v.begin();vector&lt;int&gt;::iterator pEnd &#x3D; v.end();&#x2F;&#x2F;第一种遍历方式：while (pBegin !&#x3D; pEnd) &#123;cout &lt;&lt; *pBegin &lt;&lt; endl;pBegin++;&#125;&#x2F;&#x2F;第二种遍历方式：for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#x2F;&#x2F;第三种遍历方式：&#x2F;&#x2F;使用STL提供标准遍历算法  头文件 algorithmfor_each(v.begin(), v.end(), MyPrint);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;string&gt;&#x2F;&#x2F;自定义数据类型class Person &#123;public:Person(string name, int age) &#123;mName &#x3D; name;mAge &#x3D; age;&#125;public:string mName;int mAge;&#125;;&#x2F;&#x2F;存放对象void test01() &#123;vector&lt;Person&gt; v;&#x2F;&#x2F;创建数据Person p1(&quot;aaa&quot;, 10);Person p2(&quot;bbb&quot;, 20);Person p3(&quot;ccc&quot;, 30);Person p4(&quot;ddd&quot;, 40);Person p5(&quot;eee&quot;, 50);v.push_back(p1);v.push_back(p2);v.push_back(p3);v.push_back(p4);v.push_back(p5);for (vector&lt;Person&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;&#125;&#125;&#x2F;&#x2F;放对象指针void test02() &#123;vector&lt;Person*&gt; v;&#x2F;&#x2F;创建数据Person p1(&quot;aaa&quot;, 10);Person p2(&quot;bbb&quot;, 20);Person p3(&quot;ccc&quot;, 30);Person p4(&quot;ddd&quot;, 40);Person p5(&quot;eee&quot;, 50);v.push_back(&amp;p1);v.push_back(&amp;p2);v.push_back(&amp;p3);v.push_back(&amp;p4);v.push_back(&amp;p5);for (vector&lt;Person*&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;Person * p &#x3D; (*it);cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;&#125;&#125;int main() &#123;test01();    test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;&#x2F;&#x2F;容器嵌套容器void test01() &#123;vector&lt; vector&lt;int&gt; &gt;  v;vector&lt;int&gt; v1;vector&lt;int&gt; v2;vector&lt;int&gt; v3;vector&lt;int&gt; v4;for (int i &#x3D; 0; i &lt; 4; i++) &#123;v1.push_back(i + 1);v2.push_back(i + 2);v3.push_back(i + 3);v4.push_back(i + 4);&#125;&#x2F;&#x2F;将容器元素插入到vector v中v.push_back(v1);v.push_back(v2);v.push_back(v3);v.push_back(v4);for (vector&lt;vector&lt;int&gt;&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;for (vector&lt;int&gt;::iterator vit &#x3D; (*it).begin(); vit !&#x3D; (*it).end(); vit++) &#123;cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;string构造void test01()&#123;string s1; &#x2F;&#x2F;创建空字符串，调用无参构造函数cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; s1 &lt;&lt; endl;const char* str &#x3D; &quot;hello world&quot;;string s2(str); &#x2F;&#x2F;把c_string转换成了stringcout &lt;&lt; &quot;str2 &#x3D; &quot; &lt;&lt; s2 &lt;&lt; endl;string s3(s2); &#x2F;&#x2F;调用拷贝构造函数cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; s3 &lt;&lt; endl;string s4(10, &#39;a&#39;);cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; s3 &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;赋值void test01()&#123;string str1;str1 &#x3D; &quot;hello world&quot;;cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;string str2;str2 &#x3D; str1;cout &lt;&lt; &quot;str2 &#x3D; &quot; &lt;&lt; str2 &lt;&lt; endl;string str3;str3 &#x3D; &#39;a&#39;;cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;string str4;str4.assign(&quot;hello c++&quot;);cout &lt;&lt; &quot;str4 &#x3D; &quot; &lt;&lt; str4 &lt;&lt; endl;string str5;str5.assign(&quot;hello c++&quot;,5);cout &lt;&lt; &quot;str5 &#x3D; &quot; &lt;&lt; str5 &lt;&lt; endl;string str6;str6.assign(str5);cout &lt;&lt; &quot;str6 &#x3D; &quot; &lt;&lt; str6 &lt;&lt; endl;string str7;str7.assign(5, &#39;x&#39;);cout &lt;&lt; &quot;str7 &#x3D; &quot; &lt;&lt; str7 &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;字符串拼接void test01()&#123;string str1 &#x3D; &quot;我&quot;;str1 +&#x3D; &quot;爱玩游戏&quot;;cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;str1 +&#x3D; &#39;:&#39;;cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;string str2 &#x3D; &quot;LOL DNF&quot;;str1 +&#x3D; str2;cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;string str3 &#x3D; &quot;I&quot;;str3.append(&quot; love &quot;);str3.append(&quot;game abcde&quot;, 4);&#x2F;&#x2F;str3.append(str2);str3.append(str2, 4, 3); &#x2F;&#x2F; 从下标4位置开始 ，截取3个字符，拼接到字符串末尾cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;查找和替换void test01()&#123;&#x2F;&#x2F;查找string str1 &#x3D; &quot;abcdefgde&quot;;int pos &#x3D; str1.find(&quot;de&quot;);if (pos &#x3D;&#x3D; -1)&#123;cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;pos &#x3D; &quot; &lt;&lt; pos &lt;&lt; endl;&#125;pos &#x3D; str1.rfind(&quot;de&quot;);cout &lt;&lt; &quot;pos &#x3D; &quot; &lt;&lt; pos &lt;&lt; endl;&#125;void test02()&#123;&#x2F;&#x2F;替换string str1 &#x3D; &quot;abcdefgde&quot;;str1.replace(1, 3, &quot;1111&quot;);cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;test01();&#x2F;&#x2F;test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;字符串比较void test01()&#123;string s1 &#x3D; &quot;hello&quot;;string s2 &#x3D; &quot;aello&quot;;int ret &#x3D; s1.compare(s2);if (ret &#x3D;&#x3D; 0) &#123;cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;&#125;else if (ret &gt; 0)&#123;cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void test01()&#123;string str &#x3D; &quot;hello world&quot;;for (int i &#x3D; 0; i &lt; str.size(); i++)&#123;cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for (int i &#x3D; 0; i &lt; str.size(); i++)&#123;cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#x2F;&#x2F;字符修改str[0] &#x3D; &#39;x&#39;;str.at(1) &#x3D; &#39;x&#39;;cout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;字符串插入和删除void test01()&#123;string str &#x3D; &quot;hello&quot;;str.insert(1, &quot;111&quot;);cout &lt;&lt; str &lt;&lt; endl;str.erase(1, 3);  &#x2F;&#x2F;从1号位置开始3个字符cout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;子串void test01()&#123;string str &#x3D; &quot;abcdefg&quot;;string subStr &#x3D; str.substr(1, 3);cout &lt;&lt; &quot;subStr &#x3D; &quot; &lt;&lt; subStr &lt;&lt; endl;string email &#x3D; &quot;hello@sina.com&quot;;int pos &#x3D; email.find(&quot;@&quot;);string username &#x3D; email.substr(0, pos);cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><p><img src="/post/366d/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;vector&lt;int&gt; v1; &#x2F;&#x2F;无参构造for (int i &#x3D; 0; i &lt; 10; i++)&#123;v1.push_back(i);&#125;printVector(v1);vector&lt;int&gt; v2(v1.begin(), v1.end());printVector(v2);vector&lt;int&gt; v3(10, 100);printVector(v3);vector&lt;int&gt; v4(v3);printVector(v4);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;赋值操作void test01()&#123;vector&lt;int&gt; v1; &#x2F;&#x2F;无参构造for (int i &#x3D; 0; i &lt; 10; i++)&#123;v1.push_back(i);&#125;printVector(v1);vector&lt;int&gt;v2;v2 &#x3D; v1;printVector(v2);vector&lt;int&gt;v3;v3.assign(v1.begin(), v1.end());printVector(v3);vector&lt;int&gt;v4;v4.assign(10, 100);printVector(v4);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;vector&lt;int&gt; v1;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v1.push_back(i);&#125;printVector(v1);if (v1.empty())&#123;cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;cout &lt;&lt; &quot;v1的容量 &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;cout &lt;&lt; &quot;v1的大小 &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl;&#125;&#x2F;&#x2F;resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充v1.resize(15,10);printVector(v1);&#x2F;&#x2F;resize 重新指定大小 ，若指定的更小，超出部分元素被删除v1.resize(5);printVector(v1);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;插入和删除void test01()&#123;vector&lt;int&gt; v1;&#x2F;&#x2F;尾插v1.push_back(10);v1.push_back(20);v1.push_back(30);v1.push_back(40);v1.push_back(50);printVector(v1);&#x2F;&#x2F;尾删v1.pop_back();printVector(v1);&#x2F;&#x2F;插入v1.insert(v1.begin(), 100);printVector(v1);v1.insert(v1.begin(), 2, 1000);printVector(v1);&#x2F;&#x2F;删除v1.erase(v1.begin());printVector(v1);&#x2F;&#x2F;清空v1.erase(v1.begin(), v1.end());v1.clear();printVector(v1);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void test01()&#123;vector&lt;int&gt;v1;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v1.push_back(i);&#125;for (int i &#x3D; 0; i &lt; v1.size(); i++)&#123;cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for (int i &#x3D; 0; i &lt; v1.size(); i++)&#123;cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;vector&lt;int&gt;v1;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v1.push_back(i);&#125;printVector(v1);vector&lt;int&gt;v2;for (int i &#x3D; 10; i &gt; 0; i--)&#123;v2.push_back(i);&#125;printVector(v2);&#x2F;&#x2F;互换容器cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;v1.swap(v2);printVector(v1);printVector(v2);&#125;void test02()&#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt; 100000; i++) &#123;v.push_back(i);&#125;cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;v.resize(3);cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#x2F;&#x2F;收缩内存vector&lt;int&gt;(v).swap(v); &#x2F;&#x2F;匿名对象cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;void test01()&#123;vector&lt;int&gt; v;&#x2F;&#x2F;预留空间v.reserve(100000);int num &#x3D; 0;int* p &#x3D; NULL;for (int i &#x3D; 0; i &lt; 100000; i++) &#123;v.push_back(i);if (p !&#x3D; &amp;v[0]) &#123;p &#x3D; &amp;v[0];num++;&#125;&#125;cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;test01();    system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="/post/366d/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="/post/366d/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;deque构造void test01() &#123;deque&lt;int&gt; d1; &#x2F;&#x2F;无参构造函数for (int i &#x3D; 0; i &lt; 10; i++)&#123;d1.push_back(i);&#125;printDeque(d1);deque&lt;int&gt; d2(d1.begin(),d1.end());printDeque(d2);deque&lt;int&gt;d3(10,100);printDeque(d3);deque&lt;int&gt;d4 &#x3D; d3;printDeque(d4);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;赋值操作void test01()&#123;deque&lt;int&gt; d1;for (int i &#x3D; 0; i &lt; 10; i++)&#123;d1.push_back(i);&#125;printDeque(d1);deque&lt;int&gt;d2;d2 &#x3D; d1;printDeque(d2);deque&lt;int&gt;d3;d3.assign(d1.begin(), d1.end());printDeque(d3);deque&lt;int&gt;d4;d4.assign(10, 100);printDeque(d4);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;大小操作void test01()&#123;deque&lt;int&gt; d1;for (int i &#x3D; 0; i &lt; 10; i++)&#123;d1.push_back(i);&#125;printDeque(d1);&#x2F;&#x2F;判断容器是否为空if (d1.empty()) &#123;cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;&#x2F;&#x2F;统计大小cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;&#125;&#x2F;&#x2F;重新指定大小d1.resize(15, 1);printDeque(d1);d1.resize(5);printDeque(d1);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;两端操作void test01()&#123;deque&lt;int&gt; d;&#x2F;&#x2F;尾插d.push_back(10);d.push_back(20);&#x2F;&#x2F;头插d.push_front(100);d.push_front(200);printDeque(d);&#x2F;&#x2F;尾删d.pop_back();&#x2F;&#x2F;头删d.pop_front();printDeque(d);&#125;&#x2F;&#x2F;插入void test02()&#123;deque&lt;int&gt; d;d.push_back(10);d.push_back(20);d.push_front(100);d.push_front(200);printDeque(d);d.insert(d.begin(), 1000);printDeque(d);d.insert(d.begin(), 2,10000);printDeque(d);deque&lt;int&gt;d2;d2.push_back(1);d2.push_back(2);d2.push_back(3);d.insert(d.begin(), d2.begin(), d2.end());printDeque(d);&#125;&#x2F;&#x2F;删除void test03()&#123;deque&lt;int&gt; d;d.push_back(10);d.push_back(20);d.push_front(100);d.push_front(200);printDeque(d);d.erase(d.begin());printDeque(d);d.erase(d.begin(), d.end());d.clear();printDeque(d);&#125;int main() &#123;&#x2F;&#x2F;test01();&#x2F;&#x2F;test02();    test03();    system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;数据存取void test01()&#123;deque&lt;int&gt; d;d.push_back(10);d.push_back(20);d.push_front(100);d.push_front(200);for (int i &#x3D; 0; i &lt; d.size(); i++) &#123;cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;for (int i &#x3D; 0; i &lt; d.size(); i++) &#123;cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;for (deque&lt;int&gt;::const_iterator it &#x3D; d.begin(); it !&#x3D; d.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;deque&lt;int&gt; d;d.push_back(10);d.push_back(20);d.push_front(100);d.push_front(200);printDeque(d);sort(d.begin(), d.end());printDeque(d);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;选手类class Person&#123;public:Person(string name, int score)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Score &#x3D; score;&#125;string m_Name; &#x2F;&#x2F;姓名int m_Score;  &#x2F;&#x2F;平均分&#125;;void createPerson(vector&lt;Person&gt;&amp;v)&#123;string nameSeed &#x3D; &quot;ABCDE&quot;;for (int i &#x3D; 0; i &lt; 5; i++)&#123;string name &#x3D; &quot;选手&quot;;name +&#x3D; nameSeed[i];int score &#x3D; 0;Person p(name, score);&#x2F;&#x2F;将创建的person对象 放入到容器中v.push_back(p);&#125;&#125;&#x2F;&#x2F;打分void setScore(vector&lt;Person&gt;&amp;v)&#123;for (vector&lt;Person&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#123;&#x2F;&#x2F;将评委的分数 放入到deque容器中deque&lt;int&gt;d;for (int i &#x3D; 0; i &lt; 10; i++)&#123;int score &#x3D; rand() % 41 + 60;  &#x2F;&#x2F; 60 ~ 100d.push_back(score);&#125;&#x2F;&#x2F;cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;&#x2F;&#x2F;for (deque&lt;int&gt;::iterator dit &#x3D; d.begin(); dit !&#x3D; d.end(); dit++)&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;&#x2F;&#x2F;&#125;&#x2F;&#x2F;cout &lt;&lt; endl;&#x2F;&#x2F;排序sort(d.begin(), d.end());&#x2F;&#x2F;去除最高和最低分d.pop_back();d.pop_front();&#x2F;&#x2F;取平均分int sum &#x3D; 0;for (deque&lt;int&gt;::iterator dit &#x3D; d.begin(); dit !&#x3D; d.end(); dit++)&#123;sum +&#x3D; *dit; &#x2F;&#x2F;累加每个评委的分数&#125;int avg &#x3D; sum &#x2F; d.size();&#x2F;&#x2F;将平均分 赋值给选手身上it-&gt;m_Score &#x3D; avg;&#125;&#125;void showScore(vector&lt;Person&gt;&amp;v)&#123;for (vector&lt;Person&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;&#125;&#125;int main() &#123;&#x2F;&#x2F;随机数种子srand((unsigned int)time(NULL));&#x2F;&#x2F;1、创建5名选手vector&lt;Person&gt;v;  &#x2F;&#x2F;存放选手容器createPerson(v);&#x2F;&#x2F;测试&#x2F;&#x2F;for (vector&lt;Person&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;&#x2F;&#x2F;&#125;&#x2F;&#x2F;2、给5名选手打分setScore(v);&#x2F;&#x2F;3、显示最后得分showScore(v);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="/post/366d/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><p>生活中的栈：</p><p><img src="/post/366d/clip_image002.png" alt="img"></p><p><img src="/post/366d/clip_image002-1547605111510.jpg" alt="img"></p><h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stack&gt;&#x2F;&#x2F;栈容器常用接口void test01()&#123;&#x2F;&#x2F;创建栈容器 栈容器必须符合先进后出stack&lt;int&gt; s;&#x2F;&#x2F;向栈中添加元素，叫做 压栈 入栈s.push(10);s.push(20);s.push(30);while (!s.empty()) &#123;&#x2F;&#x2F;输出栈顶元素cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;&#x2F;&#x2F;弹出栈顶元素s.pop();&#125;cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="/post/366d/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><p>生活中的队列：</p><p><img src="/post/366d/1547606785041.png" alt="1547606785041"></p><h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;string m_Name;int m_Age;&#125;;void test01() &#123;&#x2F;&#x2F;创建队列queue&lt;Person&gt; q;&#x2F;&#x2F;准备数据Person p1(&quot;唐僧&quot;, 30);Person p2(&quot;孙悟空&quot;, 1000);Person p3(&quot;猪八戒&quot;, 900);Person p4(&quot;沙僧&quot;, 800);&#x2F;&#x2F;向队列中添加元素  入队操作q.push(p1);q.push(p2);q.push(p3);q.push(p4);&#x2F;&#x2F;队列不提供迭代器，更不支持随机访问while (!q.empty()) &#123;&#x2F;&#x2F;输出队头元素cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name               &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name                &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        cout &lt;&lt; endl;&#x2F;&#x2F;弹出队头元素q.pop();&#125;cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul><h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="/post/366d/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;for (list&lt;int&gt;::const_iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);printList(L1);list&lt;int&gt;L2(L1.begin(),L1.end());printList(L2);list&lt;int&gt;L3(L2);printList(L3);list&lt;int&gt;L4(10, 1000);printList(L4);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;for (list&lt;int&gt;::const_iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;赋值和交换void test01()&#123;list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);printList(L1);&#x2F;&#x2F;赋值list&lt;int&gt;L2;L2 &#x3D; L1;printList(L2);list&lt;int&gt;L3;L3.assign(L2.begin(), L2.end());printList(L3);list&lt;int&gt;L4;L4.assign(10, 100);printList(L4);&#125;&#x2F;&#x2F;交换void test02()&#123;list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);list&lt;int&gt;L2;L2.assign(10, 100);cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;printList(L1);printList(L2);cout &lt;&lt; endl;L1.swap(L2);cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;printList(L1);printList(L2);&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;for (list&lt;int&gt;::const_iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;大小操作void test01()&#123;list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);if (L1.empty())&#123;cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;&#125;&#x2F;&#x2F;重新指定大小L1.resize(10);printList(L1);L1.resize(2);printList(L1);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;for (list&lt;int&gt;::const_iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;插入和删除void test01()&#123;list&lt;int&gt; L;&#x2F;&#x2F;尾插L.push_back(10);L.push_back(20);L.push_back(30);&#x2F;&#x2F;头插L.push_front(100);L.push_front(200);L.push_front(300);printList(L);&#x2F;&#x2F;尾删L.pop_back();printList(L);&#x2F;&#x2F;头删L.pop_front();printList(L);&#x2F;&#x2F;插入list&lt;int&gt;::iterator it &#x3D; L.begin();L.insert(++it, 1000);printList(L);&#x2F;&#x2F;删除it &#x3D; L.begin();L.erase(++it);printList(L);&#x2F;&#x2F;移除L.push_back(10000);L.push_back(10000);L.push_back(10000);printList(L);L.remove(10000);printList(L);        &#x2F;&#x2F;清空L.clear();printList(L);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;&#x2F;&#x2F;数据存取void test01()&#123;list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);&#x2F;&#x2F;cout &lt;&lt; L1.at(0) &lt;&lt; endl;&#x2F;&#x2F;错误 不支持at访问数据&#x2F;&#x2F;cout &lt;&lt; L1[0] &lt;&lt; endl; &#x2F;&#x2F;错误  不支持[]方式访问数据cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;&#x2F;&#x2F;list容器的迭代器是双向迭代器，不支持随机访问list&lt;int&gt;::iterator it &#x3D; L1.begin();&#x2F;&#x2F;it &#x3D; it + 1;&#x2F;&#x2F;错误，不可以跳跃访问，即使是+1&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void printList(const list&lt;int&gt;&amp; L) &#123;for (list&lt;int&gt;::const_iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;return val1 &gt; val2;&#125;&#x2F;&#x2F;反转和排序void test01()&#123;list&lt;int&gt; L;L.push_back(90);L.push_back(30);L.push_back(20);L.push_back(70);printList(L);&#x2F;&#x2F;反转容器的元素L.reverse();printList(L);&#x2F;&#x2F;排序L.sort(); &#x2F;&#x2F;默认的排序规则 从小到大printList(L);L.sort(myCompare); &#x2F;&#x2F;指定规则，从大到小printList(L);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:Person(string name, int age , int height) &#123;m_Name &#x3D; name;m_Age &#x3D; age;m_Height &#x3D; height;&#125;public:string m_Name;  &#x2F;&#x2F;姓名int m_Age;      &#x2F;&#x2F;年龄int m_Height;   &#x2F;&#x2F;身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;if (p1.m_Age &#x3D;&#x3D; p2.m_Age) &#123;return p1.m_Height  &gt; p2.m_Height;&#125;else&#123;return  p1.m_Age &lt; p2.m_Age;&#125;&#125;void test01() &#123;list&lt;Person&gt; L;Person p1(&quot;刘备&quot;, 35 , 175);Person p2(&quot;曹操&quot;, 45 , 180);Person p3(&quot;孙权&quot;, 40 , 170);Person p4(&quot;赵云&quot;, 25 , 190);Person p5(&quot;张飞&quot;, 35 , 160);Person p6(&quot;关羽&quot;, 35 , 200);L.push_back(p1);L.push_back(p2);L.push_back(p3);L.push_back(p4);L.push_back(p5);L.push_back(p6);for (list&lt;Person&gt;::iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;&#125;cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;L.sort(ComparePerson); &#x2F;&#x2F;排序for (list&lt;Person&gt;::iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) &#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li></ul><ul><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;for (set&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;构造和赋值void test01()&#123;set&lt;int&gt; s1;s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);printSet(s1);&#x2F;&#x2F;拷贝构造set&lt;int&gt;s2(s1);printSet(s2);&#x2F;&#x2F;赋值set&lt;int&gt;s3;s3 &#x3D; s2;printSet(s3);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;for (set&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;大小void test01()&#123;set&lt;int&gt; s1;s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);if (s1.empty())&#123;cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;&#125;&#125;&#x2F;&#x2F;交换void test02()&#123;set&lt;int&gt; s1;s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);set&lt;int&gt; s2;s2.insert(100);s2.insert(300);s2.insert(200);s2.insert(400);cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;printSet(s1);printSet(s2);cout &lt;&lt; endl;cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;s1.swap(s2);printSet(s1);printSet(s2);&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;for (set&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;插入和删除void test01()&#123;set&lt;int&gt; s1;&#x2F;&#x2F;插入s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);printSet(s1);&#x2F;&#x2F;删除s1.erase(s1.begin());printSet(s1);s1.erase(30);printSet(s1);&#x2F;&#x2F;清空&#x2F;&#x2F;s1.erase(s1.begin(), s1.end());s1.clear();printSet(s1);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;&#x2F;&#x2F;查找和统计void test01()&#123;set&lt;int&gt; s1;&#x2F;&#x2F;插入s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);&#x2F;&#x2F;查找set&lt;int&gt;::iterator pos &#x3D; s1.find(30);if (pos !&#x3D; s1.end())&#123;cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;统计int num &#x3D; s1.count(30);cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;&#x2F;&#x2F;set和multiset区别void test01()&#123;set&lt;int&gt; s;pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret &#x3D; s.insert(10);if (ret.second) &#123;cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;&#125;ret &#x3D; s.insert(10);if (ret.second) &#123;cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;&#125;    &#x2F;&#x2F;multisetmultiset&lt;int&gt; ms;ms.insert(10);ms.insert(10);for (multiset&lt;int&gt;::iterator it &#x3D; ms.begin(); it !&#x3D; ms.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;对组创建void test01()&#123;pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;pair&lt;string, int&gt; p2 &#x3D; make_pair(&quot;Jerry&quot;, 10);cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;class MyCompare &#123;public:bool operator()(int v1, int v2) &#123;return v1 &gt; v2;&#125;&#125;;void test01() &#123;    set&lt;int&gt; s1;s1.insert(10);s1.insert(40);s1.insert(20);s1.insert(30);s1.insert(50);&#x2F;&#x2F;默认从小到大for (set&lt;int&gt;::iterator it &#x3D; s1.begin(); it !&#x3D; s1.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#x2F;&#x2F;指定排序规则set&lt;int,MyCompare&gt; s2;s2.insert(10);s2.insert(40);s2.insert(20);s2.insert(30);s2.insert(50);for (set&lt;int, MyCompare&gt;::iterator it &#x3D; s2.begin(); it !&#x3D; s2.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;string m_Name;int m_Age;&#125;;class comparePerson&#123;public:bool operator()(const Person&amp; p1, const Person &amp;p2)&#123;&#x2F;&#x2F;按照年龄进行排序  降序return p1.m_Age &gt; p2.m_Age;&#125;&#125;;void test01()&#123;set&lt;Person, comparePerson&gt; s;Person p1(&quot;刘备&quot;, 23);Person p2(&quot;关羽&quot;, 27);Person p3(&quot;张飞&quot;, 25);Person p4(&quot;赵云&quot;, 21);s.insert(p1);s.insert(p2);s.insert(p3);s.insert(p4);for (set&lt;Person, comparePerson&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;for (map&lt;int, int&gt;::iterator it &#x3D; m.begin(); it !&#x3D; m.end(); it++)&#123;cout &lt;&lt; &quot;key &#x3D; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value &#x3D; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;map&lt;int,int&gt;m; &#x2F;&#x2F;默认构造m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 20));m.insert(pair&lt;int, int&gt;(3, 30));printMap(m);map&lt;int, int&gt;m2(m); &#x2F;&#x2F;拷贝构造printMap(m2);map&lt;int, int&gt;m3;m3 &#x3D; m2; &#x2F;&#x2F;赋值printMap(m3);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;for (map&lt;int, int&gt;::iterator it &#x3D; m.begin(); it !&#x3D; m.end(); it++)&#123;cout &lt;&lt; &quot;key &#x3D; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value &#x3D; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 20));m.insert(pair&lt;int, int&gt;(3, 30));if (m.empty())&#123;cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;&#125;&#125;&#x2F;&#x2F;交换void test02()&#123;map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 20));m.insert(pair&lt;int, int&gt;(3, 30));map&lt;int, int&gt;m2;m2.insert(pair&lt;int, int&gt;(4, 100));m2.insert(pair&lt;int, int&gt;(5, 200));m2.insert(pair&lt;int, int&gt;(6, 300));cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;printMap(m);printMap(m2);cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;m.swap(m2);printMap(m);printMap(m2);&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;for (map&lt;int, int&gt;::iterator it &#x3D; m.begin(); it !&#x3D; m.end(); it++)&#123;cout &lt;&lt; &quot;key &#x3D; &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value &#x3D; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#125;void test01()&#123;&#x2F;&#x2F;插入map&lt;int, int&gt; m;&#x2F;&#x2F;第一种插入方式m.insert(pair&lt;int, int&gt;(1, 10));&#x2F;&#x2F;第二种插入方式m.insert(make_pair(2, 20));&#x2F;&#x2F;第三种插入方式m.insert(map&lt;int, int&gt;::value_type(3, 30));&#x2F;&#x2F;第四种插入方式m[4] &#x3D; 40; printMap(m);&#x2F;&#x2F;删除m.erase(m.begin());printMap(m);m.erase(3);printMap(m);&#x2F;&#x2F;清空m.erase(m.begin(),m.end());m.clear();printMap(m);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert </li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;map&gt;&#x2F;&#x2F;查找和统计void test01()&#123;map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 20));m.insert(pair&lt;int, int&gt;(3, 30));&#x2F;&#x2F;查找map&lt;int, int&gt;::iterator pos &#x3D; m.find(3);if (pos !&#x3D; m.end())&#123;cout &lt;&lt; &quot;找到了元素 key &#x3D; &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value &#x3D; &quot; &lt;&lt; (*pos).second &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;统计int num &#x3D; m.count(3);cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;map&gt;class MyCompare &#123;public:bool operator()(int v1, int v2) &#123;return v1 &gt; v2;&#125;&#125;;void test01() &#123;&#x2F;&#x2F;默认从小到大排序&#x2F;&#x2F;利用仿函数实现从大到小排序map&lt;int, int, MyCompare&gt; m;m.insert(make_pair(1, 10));m.insert(make_pair(2, 20));m.insert(make_pair(3, 30));m.insert(make_pair(4, 40));m.insert(make_pair(5, 50));for (map&lt;int, int, MyCompare&gt;::iterator it &#x3D; m.begin(); it !&#x3D; m.end(); it++) &#123;cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;&#x2F;*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入  key(部门编号) value(员工)- 分部门显示员工信息*&#x2F;#define CEHUA  0#define MEISHU 1#define YANFA  2class Worker&#123;public:string m_Name;int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;string nameSeed &#x3D; &quot;ABCDEFGHIJ&quot;;for (int i &#x3D; 0; i &lt; 10; i++)&#123;Worker worker;worker.m_Name &#x3D; &quot;员工&quot;;worker.m_Name +&#x3D; nameSeed[i];worker.m_Salary &#x3D; rand() % 10000 + 10000; &#x2F;&#x2F; 10000 ~ 19999&#x2F;&#x2F;将员工放入到容器中v.push_back(worker);&#125;&#125;&#x2F;&#x2F;员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;for (vector&lt;Worker&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#123;&#x2F;&#x2F;产生随机部门编号int deptId &#x3D; rand() % 3; &#x2F;&#x2F; 0 1 2 &#x2F;&#x2F;将员工插入到分组中&#x2F;&#x2F;key部门编号，value具体员工m.insert(make_pair(deptId, *it));&#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;&#x2F;&#x2F; 0  A  B  C   1  D  E   2  F G ...cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;multimap&lt;int,Worker&gt;::iterator pos &#x3D; m.find(CEHUA);int count &#x3D; m.count(CEHUA); &#x2F;&#x2F; 统计具体人数int index &#x3D; 0;for (; pos !&#x3D; m.end() &amp;&amp; index &lt; count; pos++ , index++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;&#125;cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;pos &#x3D; m.find(MEISHU);count &#x3D; m.count(MEISHU); &#x2F;&#x2F; 统计具体人数index &#x3D; 0;for (; pos !&#x3D; m.end() &amp;&amp; index &lt; count; pos++, index++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;&#125;cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;pos &#x3D; m.find(YANFA);count &#x3D; m.count(YANFA); &#x2F;&#x2F; 统计具体人数index &#x3D; 0;for (; pos !&#x3D; m.end() &amp;&amp; index &lt; count; pos++, index++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;&#125;&#125;int main() &#123;srand((unsigned int)time(NULL));&#x2F;&#x2F;1、创建员工vector&lt;Worker&gt;vWorker;createWorker(vWorker);&#x2F;&#x2F;2、员工分组multimap&lt;int, Worker&gt;mWorker;setGroup(vWorker, mWorker);&#x2F;&#x2F;3、分组显示员工showWorkerByGourp(mWorker);&#x2F;&#x2F;&#x2F;&#x2F;测试&#x2F;&#x2F;for (vector&lt;Worker&gt;::iterator it &#x3D; vWorker.begin(); it !&#x3D; vWorker.end(); it++)&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;&#x2F;&#x2F;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;string&gt;&#x2F;&#x2F;1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public :int operator()(int v1,int v2)&#123;return v1 + v2;&#125;&#125;;void test01()&#123;MyAdd myAdd;cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;&#x2F;&#x2F;2、函数对象可以有自己的状态class MyPrint&#123;public:MyPrint()&#123;count &#x3D; 0;&#125;void operator()(string test)&#123;cout &lt;&lt; test &lt;&lt; endl;count++; &#x2F;&#x2F;统计使用次数&#125;int count; &#x2F;&#x2F;内部自己的状态&#125;;void test02()&#123;MyPrint myPrint;myPrint(&quot;hello world&quot;);myPrint(&quot;hello world&quot;);myPrint(&quot;hello world&quot;);cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;&#125;&#x2F;&#x2F;3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123;mp(test);&#125;void test03()&#123;MyPrint myPrint;doPrint(myPrint, &quot;Hello C++&quot;);&#125;int main() &#123;&#x2F;&#x2F;test01();&#x2F;&#x2F;test02();test03();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;&#x2F;&#x2F;1.一元谓词struct GreaterFive&#123;bool operator()(int val) &#123;return val &gt; 5;&#125;&#125;;void test01() &#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v.push_back(i);&#125;vector&lt;int&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), GreaterFive());if (it &#x3D;&#x3D; v.end()) &#123;cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;&#x2F;&#x2F;二元谓词class MyCompare&#123;public:bool operator()(int num1, int num2)&#123;return num1 &gt; num2;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.push_back(10);v.push_back(40);v.push_back(20);v.push_back(30);v.push_back(50);&#x2F;&#x2F;默认从小到大sort(v.begin(), v.end());for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;&#x2F;&#x2F;使用函数对象改变算法策略，排序从大到小sort(v.begin(), v.end(), MyCompare());for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;functional&gt;&#x2F;&#x2F;negatevoid test01()&#123;negate&lt;int&gt; n;cout &lt;&lt; n(50) &lt;&lt; endl;&#125;&#x2F;&#x2F;plusvoid test02()&#123;plus&lt;int&gt; p;cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:bool operator()(int v1,int v2)&#123;return v1 &gt; v2;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.push_back(10);v.push_back(30);v.push_back(50);v.push_back(40);v.push_back(20);for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#x2F;&#x2F;自己实现仿函数&#x2F;&#x2F;sort(v.begin(), v.end(), MyCompare());&#x2F;&#x2F;STL内建仿函数  大于仿函数sort(v.begin(), v.end(), greater&lt;int&gt;());for (vector&lt;int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;vector&lt;bool&gt; v;v.push_back(true);v.push_back(false);v.push_back(true);v.push_back(false);for (vector&lt;bool&gt;::iterator it &#x3D; v.begin();it!&#x3D; v.end();it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#x2F;&#x2F;逻辑非  将v容器搬运到v2中，并执行逻辑非运算vector&lt;bool&gt; v2;v2.resize(v.size());transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());for (vector&lt;bool&gt;::iterator it &#x3D; v2.begin(); it !&#x3D; v2.end(); it++)&#123;cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul><ul><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;&#x2F;&#x2F;普通函数void print01(int val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#x2F;&#x2F;函数对象class print02 &#123; public:void operator()(int val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;&#x2F;&#x2F;for_each算法基本用法void test01() &#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v.push_back(i);&#125;&#x2F;&#x2F;遍历算法for_each(v.begin(), v.end(), print01);cout &lt;&lt; endl;for_each(v.begin(), v.end(), print02());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;vector&gt;#include&lt;algorithm&gt;&#x2F;&#x2F;常用遍历算法  搬运 transformclass TransForm&#123;public:int operator()(int val)&#123;return val;&#125;&#125;;class MyPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt;v;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v.push_back(i);&#125;vector&lt;int&gt;vTarget; &#x2F;&#x2F;目标容器vTarget.resize(v.size()); &#x2F;&#x2F; 目标容器需要提前开辟空间transform(v.begin(), v.end(), vTarget.begin(), TransForm());for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬</p><h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v.push_back(i + 1);&#125;&#x2F;&#x2F;查找容器中是否有 5 这个元素vector&lt;int&gt;::iterator it &#x3D; find(v.begin(), v.end(), 5);if (it &#x3D;&#x3D; v.end()) &#123;cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;&#125;&#125;class Person &#123;public:Person(string name, int age) &#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;&#x2F;&#x2F;重载&#x3D;&#x3D;bool operator&#x3D;&#x3D;(const Person&amp; p) &#123;if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age) &#123;return true;&#125;return false;&#125;public:string m_Name;int m_Age;&#125;;void test02() &#123;vector&lt;Person&gt; v;&#x2F;&#x2F;创建数据Person p1(&quot;aaa&quot;, 10);Person p2(&quot;bbb&quot;, 20);Person p3(&quot;ccc&quot;, 30);Person p4(&quot;ddd&quot;, 40);v.push_back(p1);v.push_back(p2);v.push_back(p3);v.push_back(p4);vector&lt;Person&gt;::iterator it &#x3D; find(v.begin(), v.end(), p2);if (it &#x3D;&#x3D; v.end()) &#123;cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;&#x2F;&#x2F;内置数据类型class GreaterFive&#123;public:bool operator()(int val)&#123;return val &gt; 5;&#125;&#125;;void test01() &#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v.push_back(i + 1);&#125;vector&lt;int&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), GreaterFive());if (it &#x3D;&#x3D; v.end()) &#123;cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;&#125;&#125;&#x2F;&#x2F;自定义数据类型class Person &#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;public:string m_Name;int m_Age;&#125;;class Greater20&#123;public:bool operator()(Person &amp;p)&#123;return p.m_Age &gt; 20;&#125;&#125;;void test02() &#123;vector&lt;Person&gt; v;&#x2F;&#x2F;创建数据Person p1(&quot;aaa&quot;, 10);Person p2(&quot;bbb&quot;, 20);Person p3(&quot;ccc&quot;, 30);Person p4(&quot;ddd&quot;, 40);v.push_back(p1);v.push_back(p2);v.push_back(p3);v.push_back(p4);vector&lt;Person&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), Greater20());if (it &#x3D;&#x3D; v.end())&#123;cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;&#125;&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(5);v.push_back(2);v.push_back(4);v.push_back(4);v.push_back(3);&#x2F;&#x2F;查找相邻重复元素vector&lt;int&gt;::iterator it &#x3D; adjacent_find(v.begin(), v.end());if (it &#x3D;&#x3D; v.end()) &#123;cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;&#125;else &#123;cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;vector&lt;int&gt;v;for (int i &#x3D; 0; i &lt; 10; i++)&#123;v.push_back(i);&#125;&#x2F;&#x2F;二分查找bool ret &#x3D; binary_search(v.begin(), v.end(),2);if (ret)&#123;cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;&#x2F;&#x2F;内置数据类型void test01()&#123;vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(4);v.push_back(5);v.push_back(3);v.push_back(4);v.push_back(4);int num &#x3D; count(v.begin(), v.end(), 4);cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;&#x2F;&#x2F;自定义数据类型class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;bool operator&#x3D;&#x3D;(const Person &amp; p)&#123;if (this-&gt;m_Age &#x3D;&#x3D; p.m_Age)&#123;return true;&#125;else&#123;return false;&#125;&#125;string m_Name;int m_Age;&#125;;void test02()&#123;vector&lt;Person&gt; v;Person p1(&quot;刘备&quot;, 35);Person p2(&quot;关羽&quot;, 35);Person p3(&quot;张飞&quot;, 35);Person p4(&quot;赵云&quot;, 30);Person p5(&quot;曹操&quot;, 25);v.push_back(p1);v.push_back(p2);v.push_back(p3);v.push_back(p4);v.push_back(p5);        Person p(&quot;诸葛亮&quot;,35);int num &#x3D; count(v.begin(), v.end(), p);cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:bool operator()(int val)&#123;return val &gt;&#x3D; 4;&#125;&#125;;&#x2F;&#x2F;内置数据类型void test01()&#123;vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(4);v.push_back(5);v.push_back(3);v.push_back(4);v.push_back(4);int num &#x3D; count_if(v.begin(), v.end(), Greater4());cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;&#x2F;&#x2F;自定义数据类型class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;string m_Name;int m_Age;&#125;;class AgeLess35&#123;public:bool operator()(const Person &amp;p)&#123;return p.m_Age &lt; 35;&#125;&#125;;void test02()&#123;vector&lt;Person&gt; v;Person p1(&quot;刘备&quot;, 35);Person p2(&quot;关羽&quot;, 35);Person p3(&quot;张飞&quot;, 35);Person p4(&quot;赵云&quot;, 30);Person p5(&quot;曹操&quot;, 25);v.push_back(p1);v.push_back(p2);v.push_back(p3);v.push_back(p4);v.push_back(p5);int num &#x3D; count_if(v.begin(), v.end(), AgeLess35());cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;vector&lt;int&gt; v;v.push_back(10);v.push_back(30);v.push_back(50);v.push_back(20);v.push_back(40);&#x2F;&#x2F;sort默认从小到大排序sort(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint);cout &lt;&lt; endl;&#x2F;&#x2F;从大到小排序sort(v.begin(), v.end(), greater&lt;int&gt;());for_each(v.begin(), v.end(), myPrint);cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;srand((unsigned int)time(NULL));vector&lt;int&gt; v;for(int i &#x3D; 0 ; i &lt; 10;i++)&#123;v.push_back(i);&#125;for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#x2F;&#x2F;打乱顺序random_shuffle(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;vector&lt;int&gt; v2;for (int i &#x3D; 0; i &lt; 10 ; i++)     &#123;v1.push_back(i);v2.push_back(i + 1);&#125;vector&lt;int&gt; vtarget;&#x2F;&#x2F;目标容器需要提前开辟空间vtarget.resize(v1.size() + v2.size());&#x2F;&#x2F;合并  需要两个有序序列merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());for_each(vtarget.begin(), vtarget.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.push_back(10);v.push_back(30);v.push_back(50);v.push_back(20);v.push_back(40);cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;reverse(v.begin(), v.end());for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v1.push_back(i + 1);&#125;vector&lt;int&gt; v2;v2.resize(v1.size());copy(v1.begin(), v1.end(), v2.begin());for_each(v2.begin(), v2.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.push_back(20);v.push_back(30);v.push_back(20);v.push_back(40);v.push_back(50);v.push_back(10);v.push_back(20);cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#x2F;&#x2F;将容器中的20 替换成 2000cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;replace(v.begin(), v.end(), 20,2000);for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;class ReplaceGreater30&#123;public:bool operator()(int val)&#123;return val &gt;&#x3D; 30;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.push_back(20);v.push_back(30);v.push_back(20);v.push_back(40);v.push_back(50);v.push_back(10);v.push_back(20);cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#x2F;&#x2F;将容器中大于等于的30 替换成 3000cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;vector&lt;int&gt; v2;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v1.push_back(i);v2.push_back(i+100);&#125;cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;for_each(v1.begin(), v1.end(), myPrint());cout &lt;&lt; endl;for_each(v2.begin(), v2.end(), myPrint());cout &lt;&lt; endl;cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;swap(v1, v2);for_each(v1.begin(), v1.end(), myPrint());cout &lt;&lt; endl;for_each(v2.begin(), v2.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li> 计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;vector&lt;int&gt; v;for (int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#123;v.push_back(i);&#125;int total &#x3D; accumulate(v.begin(), v.end(), 0);cout &lt;&lt; &quot;total &#x3D; &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v;v.resize(10);&#x2F;&#x2F;填充fill(v.begin(), v.end(), 100);for_each(v.begin(), v.end(), myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;vector&lt;int&gt; v2;for (int i &#x3D; 0; i &lt; 10; i++)    &#123;v1.push_back(i);v2.push_back(i+5);&#125;vector&lt;int&gt; vTarget;&#x2F;&#x2F;取两个里面较小的值给目标容器开辟空间vTarget.resize(min(v1.size(), v2.size()));&#x2F;&#x2F;返回目标容器的最后一个元素的迭代器地址vector&lt;int&gt;::iterator itEnd &#x3D;         set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());for_each(vTarget.begin(), itEnd, myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;vector&lt;int&gt; v2;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v1.push_back(i);v2.push_back(i+5);&#125;vector&lt;int&gt; vTarget;&#x2F;&#x2F;取两个容器的和给目标容器开辟空间vTarget.resize(v1.size() + v2.size());&#x2F;&#x2F;返回目标容器的最后一个元素的迭代器地址vector&lt;int&gt;::iterator itEnd &#x3D;         set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());for_each(vTarget.begin(), itEnd, myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:void operator()(int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;void test01()&#123;vector&lt;int&gt; v1;vector&lt;int&gt; v2;for (int i &#x3D; 0; i &lt; 10; i++) &#123;v1.push_back(i);v2.push_back(i+5);&#125;vector&lt;int&gt; vTarget;&#x2F;&#x2F;取两个里面较大的值给目标容器开辟空间vTarget.resize( max(v1.size() , v2.size()));&#x2F;&#x2F;返回目标容器的最后一个元素的迭代器地址cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;vector&lt;int&gt;::iterator itEnd &#x3D;         set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());for_each(vTarget.begin(), itEnd, myPrint());cout &lt;&lt; endl;cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;itEnd &#x3D; set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());for_each(vTarget.begin(), itEnd, myPrint());cout &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++核心编程</title>
      <link href="post/9c88.html"/>
      <url>post/9c88.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><p>内容来源于黑马程序员</p><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;全局变量int g_a &#x3D; 10;int g_b &#x3D; 10;&#x2F;&#x2F;全局常量const int c_g_a &#x3D; 10;const int c_g_b &#x3D; 10;int main() &#123;&#x2F;&#x2F;局部变量int a &#x3D; 10;int b &#x3D; 10;&#x2F;&#x2F;打印地址cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;&#x2F;&#x2F;静态变量static int s_a &#x3D; 10;static int s_b &#x3D; 10;cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;const int c_l_a &#x3D; 10;const int c_l_b &#x3D; 10;cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><p><img src="/post/9c88/1545017602518.png" alt="1545017602518"></p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p><p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * func()&#123;int a &#x3D; 10;return &amp;a;&#125;int main() &#123;int *p &#x3D; func();cout &lt;&lt; *p &lt;&lt; endl;cout &lt;&lt; *p &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>堆区：</strong></p><p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​        在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* func()&#123;int* a &#x3D; new int(10);return a;&#125;int main() &#123;int *p &#x3D; func();cout &lt;&lt; *p &lt;&lt; endl;cout &lt;&lt; *p &lt;&lt; endl;    system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p><p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​    语法：<code> new 数据类型</code></p><p>​    利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* func()&#123;int* a &#x3D; new int(10);return a;&#125;int main() &#123;int *p &#x3D; func();cout &lt;&lt; *p &lt;&lt; endl;cout &lt;&lt; *p &lt;&lt; endl;&#x2F;&#x2F;利用delete释放堆区数据delete p;&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;报错，释放的空间不可访问system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：开辟数组</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;堆区开辟数组int main() &#123;int* arr &#x3D; new int[10];for (int i &#x3D; 0; i &lt; 10; i++)&#123;arr[i] &#x3D; i + 100;&#125;for (int i &#x3D; 0; i &lt; 10; i++)&#123;cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;&#x2F;&#x2F;释放数组 delete 后加 []delete[] arr;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int a &#x3D; 10;int &amp;b &#x3D; a;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;b &#x3D; 100;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int a &#x3D; 10;int b &#x3D; 20;&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化int &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改c &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;1. 值传递void mySwap01(int a, int b) &#123;int temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;&#x2F;&#x2F;2. 地址传递void mySwap02(int* a, int* b) &#123;int temp &#x3D; *a;*a &#x3D; *b;*b &#x3D; temp;&#125;&#x2F;&#x2F;3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123;int temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;int main() &#123;int a &#x3D; 10;int b &#x3D; 20;mySwap01(a, b);cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;mySwap02(&amp;a, &amp;b);cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;mySwap03(a, b);cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;返回局部变量引用int&amp; test01() &#123;int a &#x3D; 10; &#x2F;&#x2F;局部变量return a;&#125;&#x2F;&#x2F;返回静态变量引用int&amp; test02() &#123;static int a &#x3D; 20;return a;&#125;int main() &#123;&#x2F;&#x2F;不能返回局部变量的引用int&amp; ref &#x3D; test01();cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;&#x2F;&#x2F;如果函数做左值，那么必须返回引用int&amp; ref2 &#x3D; test02();cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;test02() &#x3D; 1000;cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;void func(int&amp; ref)&#123;ref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100&#125;int main()&#123;int a &#x3D; 10;        &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改int&amp; ref &#x3D; a; ref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;    func(a);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123;&#x2F;&#x2F;v +&#x3D; 10;cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;const int&amp; ref &#x3D; 10;&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量cout &lt;&lt; ref &lt;&lt; endl;&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参int a &#x3D; 10;showValue(a);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;return a + b + c;&#125;&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a &#x3D; 10, int b &#x3D; 10);int func2(int a, int b) &#123;return a + b;&#125;int main() &#123;cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-数占位参数"><a href="#3-2-数占位参数" class="headerlink" title="3.2 数占位参数"></a>3.2 数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123;cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123;func(10,10); &#x2F;&#x2F;占位参数必须填补system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数重载需要函数都在同一个作用域下void func()&#123;cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123;cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123;cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123;cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123;cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;函数返回值不可以作为函数重载条件&#x2F;&#x2F;int func(double a, int b)&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#x2F;&#x2F;&#125;int main() &#123;func();func(10);func(3.14);func(10,3.14);func(3.14 , 10);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数重载注意事项&#x2F;&#x2F;1、引用作为重载条件void func(int &amp;a)&#123;cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123;cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;2、函数重载碰到函数默认参数void func2(int a, int b &#x3D; 10)&#123;cout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123;int a &#x3D; 10;func(a); &#x2F;&#x2F;调用无constfunc(10);&#x2F;&#x2F;调用有const&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​    在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;圆周率const double PI &#x3D; 3.14;&#x2F;&#x2F;1、封装的意义&#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物&#x2F;&#x2F;封装一个圆类，求圆的周长&#x2F;&#x2F;class代表设计一个类，后面跟着的是类名class Circle&#123;public:  &#x2F;&#x2F;访问权限  公共的权限&#x2F;&#x2F;属性int m_r;&#x2F;&#x2F;半径&#x2F;&#x2F;行为&#x2F;&#x2F;获取到圆的周长double calculateZC()&#123;&#x2F;&#x2F;2 * pi  * r&#x2F;&#x2F;获取圆的周长return  2 * PI * m_r;&#125;&#125;;int main() &#123;&#x2F;&#x2F;通过圆类，创建圆的对象&#x2F;&#x2F; c1就是一个具体的圆Circle c1;c1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作&#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;学生类class Student &#123;public:void setName(string name) &#123;m_name &#x3D; name;&#125;void setID(int id) &#123;m_id &#x3D; id;&#125;void showStudent() &#123;cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;&#125;public:string m_name;int m_id;&#125;;int main() &#123;Student stu;stu.setName(&quot;德玛西亚&quot;);stu.setID(250);stu.showStudent();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;三种权限&#x2F;&#x2F;公共权限  public     类内可以访问  类外可以访问&#x2F;&#x2F;保护权限  protected  类内可以访问  类外不可以访问&#x2F;&#x2F;私有权限  private    类内可以访问  类外不可以访问class Person&#123;&#x2F;&#x2F;姓名  公共权限public:string m_Name;&#x2F;&#x2F;汽车  保护权限protected:string m_Car;&#x2F;&#x2F;银行卡密码  私有权限private:int m_Password;public:void func()&#123;m_Name &#x3D; &quot;张三&quot;;m_Car &#x3D; &quot;拖拉机&quot;;m_Password &#x3D; 123456;&#125;&#125;;int main() &#123;Person p;p.m_Name &#x3D; &quot;李四&quot;;&#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;;  &#x2F;&#x2F;保护权限类外访问不到&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class C1&#123;int  m_A; &#x2F;&#x2F;默认是私有权限&#125;;struct C2&#123;int m_A;  &#x2F;&#x2F;默认是公共权限&#125;;int main() &#123;C1 c1;c1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有C2 c2;c2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:&#x2F;&#x2F;姓名设置可读可写void setName(string name) &#123;m_Name &#x3D; name;&#125;string getName()&#123;return m_Name;&#125;&#x2F;&#x2F;获取年龄 int getAge() &#123;return m_Age;&#125;&#x2F;&#x2F;设置年龄void setAge(int age) &#123;if (age &lt; 0 || age &gt; 150) &#123;cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;return;&#125;m_Age &#x3D; age;&#125;&#x2F;&#x2F;情人设置为只写void setLover(string lover) &#123;m_Lover &#x3D; lover;&#125;private:string m_Name; &#x2F;&#x2F;可读可写  姓名int m_Age; &#x2F;&#x2F;只读  年龄string m_Lover; &#x2F;&#x2F;只写  情人&#125;;int main() &#123;Person p;&#x2F;&#x2F;姓名设置p.setName(&quot;张三&quot;);cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;&#x2F;&#x2F;年龄设置p.setAge(50);cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;&#x2F;&#x2F;情人设置p.setLover(&quot;苍井&quot;);&#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  &#x2F;&#x2F;只写属性，不可以读取system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="/post/9c88/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="/post/9c88/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:&#x2F;&#x2F;构造函数Person()&#123;cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;析构函数~Person()&#123;cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;&#125;&#125;;void test01()&#123;Person p;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​    按参数分为： 有参构造和无参构造</p><p>​    按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​    括号法</p><p>​    显示法</p><p>​    隐式转换法</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;1、构造函数分类&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造class Person &#123;public:&#x2F;&#x2F;无参（默认）构造函数Person() &#123;cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;有参构造函数Person(int a) &#123;age &#x3D; a;cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;拷贝构造函数Person(const Person&amp; p) &#123;age &#x3D; p.age;cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;析构函数~Person() &#123;cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;&#125;public:int age;&#125;;&#x2F;&#x2F;2、构造函数的调用&#x2F;&#x2F;调用无参构造函数void test01() &#123;Person p; &#x2F;&#x2F;调用无参构造函数&#125;&#x2F;&#x2F;调用有参的构造函数void test02() &#123;&#x2F;&#x2F;2.1  括号法，常用Person p1(10);&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明&#x2F;&#x2F;Person p2();&#x2F;&#x2F;2.2 显式法Person p2 &#x3D; Person(10); Person p3 &#x3D; Person(p2);&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构&#x2F;&#x2F;2.3 隐式转换法Person p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); Person p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); &#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明&#x2F;&#x2F;Person p5(p4);&#125;int main() &#123;test01();&#x2F;&#x2F;test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:Person() &#123;cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;mAge &#x3D; 0;&#125;Person(int age) &#123;cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;mAge &#x3D; age;&#125;Person(const Person&amp; p) &#123;cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;mAge &#x3D; p.mAge;&#125;&#x2F;&#x2F;析构函数在释放内存之前调用~Person() &#123;cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;&#125;public:int mAge;&#125;;&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123;Person man(100); &#x2F;&#x2F;p对象已经创建完毕Person newman(man); &#x2F;&#x2F;调用拷贝构造函数Person newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造&#x2F;&#x2F;Person newman3;&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作&#125;&#x2F;&#x2F;2. 值传递的方式给函数参数传值&#x2F;&#x2F;相当于Person p1 &#x3D; p;void doWork(Person p1) &#123;&#125;void test02() &#123;Person p; &#x2F;&#x2F;无参构造函数doWork(p);&#125;&#x2F;&#x2F;3. 以值方式返回局部对象Person doWork2()&#123;Person p1;cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;return p1;&#125;void test03()&#123;Person p &#x3D; doWork2();cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;test01();&#x2F;&#x2F;test02();test03();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li></ul><ul><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:&#x2F;&#x2F;无参（默认）构造函数Person() &#123;cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;有参构造函数Person(int a) &#123;age &#x3D; a;cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;拷贝构造函数Person(const Person&amp; p) &#123;age &#x3D; p.age;cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;析构函数~Person() &#123;cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;&#125;public:int age;&#125;;void test01()&#123;Person p1(18);&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作Person p2(p1);cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123;&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造Person p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错Person p2(10); &#x2F;&#x2F;用户提供的有参Person p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数Person p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错Person p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错Person p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:&#x2F;&#x2F;无参（默认）构造函数Person() &#123;cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;有参构造函数Person(int age ,int height) &#123;cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;m_age &#x3D; age;m_height &#x3D; new int(height);&#125;&#x2F;&#x2F;拷贝构造函数  Person(const Person&amp; p) &#123;cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题m_age &#x3D; p.m_age;m_height &#x3D; new int(*p.m_height);&#125;&#x2F;&#x2F;析构函数~Person() &#123;cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;if (m_height !&#x3D; NULL)&#123;delete m_height;&#125;&#125;public:int m_age;int* m_height;&#125;;void test01()&#123;Person p1(18, 180);Person p2(p1);cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化&#x2F;&#x2F;Person(int a, int b, int c) &#123;&#x2F;&#x2F;m_A &#x3D; a;&#x2F;&#x2F;m_B &#x3D; b;&#x2F;&#x2F;m_C &#x3D; c;&#x2F;&#x2F;&#125;&#x2F;&#x2F;初始化列表方式初始化Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;void PrintPerson() &#123;cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;&#125;private:int m_A;int m_B;int m_C;&#125;;int main() &#123;Person p(1, 2, 3);p.PrintPerson();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A &#123;&#125;class B&#123;    A a；&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Phone&#123;public:Phone(string name)&#123;m_PhoneName &#x3D; name;cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;&#125;~Phone()&#123;cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;&#125;string m_PhoneName;&#125;;class Person&#123;public:&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数Person(string name, string pName) :m_Name(name), m_Phone(pName)&#123;cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;&#125;~Person()&#123;cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;&#125;void playGame()&#123;cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;&#125;string m_Name;Phone m_Phone;&#125;;void test01()&#123;&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造&#x2F;&#x2F;析构顺序与构造相反Person p(&quot;张三&quot; , &quot;苹果X&quot;);p.playGame();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> 类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li> 所有对象共享同一个函数</li><li> 静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:static int m_A; &#x2F;&#x2F;静态成员变量&#x2F;&#x2F;静态成员变量特点：&#x2F;&#x2F;1 在编译阶段分配内存&#x2F;&#x2F;2 类内声明，类外初始化&#x2F;&#x2F;3 所有对象共享同一份数据private:static int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的&#125;;int Person::m_A &#x3D; 10;int Person::m_B &#x3D; 10;void test01()&#123;&#x2F;&#x2F;静态成员变量两种访问方式&#x2F;&#x2F;1、通过对象Person p1;p1.m_A &#x3D; 100;cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;Person p2;p2.m_A &#x3D; 200;cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据cout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;&#x2F;&#x2F;2、通过类名cout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong>静态成员函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:&#x2F;&#x2F;静态成员函数特点：&#x2F;&#x2F;1 程序共享一个函数&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量static void func()&#123;cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;m_A &#x3D; 100;&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量&#125;static int m_A; &#x2F;&#x2F;静态成员变量int m_B; &#x2F;&#x2F; private:&#x2F;&#x2F;静态成员函数也是有访问权限的static void func2()&#123;cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;&#125;&#125;;int Person::m_A &#x3D; 10;void test01()&#123;&#x2F;&#x2F;静态成员变量两种访问方式&#x2F;&#x2F;1、通过对象Person p1;p1.func();&#x2F;&#x2F;2、通过类名Person::func();&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:Person() &#123;mA &#x3D; 0;&#125;&#x2F;&#x2F;非静态成员变量占对象空间int mA;&#x2F;&#x2F;静态成员变量不占对象空间static int mB; &#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例void func() &#123;cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;&#125;&#x2F;&#x2F;静态成员函数也不占对象空间static void sfunc() &#123;&#125;&#125;;int main() &#123;cout &lt;&lt; sizeof(Person) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li> 当形参和成员变量同名时，可用this指针来区分</li><li> 在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:Person(int age)&#123;&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分this-&gt;age &#x3D; age;&#125;Person&amp; PersonAddPerson(Person p)&#123;this-&gt;age +&#x3D; p.age;&#x2F;&#x2F;返回对象本身return *this;&#125;int age;&#125;;void test01()&#123;Person p1(10);cout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;Person p2(10);p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);cout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;空指针访问成员函数class Person &#123;public:void ShowClassName() &#123;cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;&#125;void ShowPerson() &#123;if (this &#x3D;&#x3D; NULL) &#123;return;&#125;cout &lt;&lt; mAge &lt;&lt; endl;&#125;public:int mAge;&#125;;void test01()&#123;Person * p &#x3D; NULL;p-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数p-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:Person() &#123;m_A &#x3D; 0;m_B &#x3D; 0;&#125;&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数void ShowPerson() const &#123;&#x2F;&#x2F;const Type* const pointer;&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量this-&gt;m_B &#x3D; 100;&#125;void MyFunc() const &#123;&#x2F;&#x2F;mA &#x3D; 10000;&#125;public:int m_A;mutable int m_B; &#x2F;&#x2F;可修改 可变的&#125;;&#x2F;&#x2F;const修饰对象  常对象void test01() &#123;const Person person; &#x2F;&#x2F;常量对象  cout &lt;&lt; person.m_A &lt;&lt; endl;&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问person.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量&#x2F;&#x2F;常对象访问成员函数person.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Building&#123;&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容friend void goodGay(Building * building);public:Building()&#123;this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;&#125;public:string m_SittingRoom; &#x2F;&#x2F;客厅private:string m_BedRoom; &#x2F;&#x2F;卧室&#125;;void goodGay(Building * building)&#123;cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;Building b;goodGay(&amp;b);&#125;int main()&#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Building;class goodGay&#123;public:goodGay();void visit();private:Building *building;&#125;;class Building&#123;&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容friend class goodGay;public:Building();public:string m_SittingRoom; &#x2F;&#x2F;客厅private:string m_BedRoom;&#x2F;&#x2F;卧室&#125;;Building::Building()&#123;this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;building &#x3D; new Building;&#125;void goodGay::visit()&#123;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;goodGay gg;gg.visit();&#125;int main()&#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Building;class goodGay&#123;public:goodGay();void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容void visit2(); private:Building *building;&#125;;class Building&#123;&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容friend void goodGay::visit();public:Building();public:string m_SittingRoom; &#x2F;&#x2F;客厅private:string m_BedRoom;&#x2F;&#x2F;卧室&#125;;Building::Building()&#123;this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;building &#x3D; new Building;&#125;void goodGay::visit()&#123;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;goodGay  gg;gg.visit();&#125;int main()&#123;    test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;public:Person() &#123;&#125;;Person(int a, int b)&#123;this-&gt;m_A &#x3D; a;this-&gt;m_B &#x3D; b;&#125;&#x2F;&#x2F;成员函数实现 + 号运算符重载Person operator+(const Person&amp; p) &#123;Person temp;temp.m_A &#x3D; this-&gt;m_A + p.m_A;temp.m_B &#x3D; this-&gt;m_B + p.m_B;return temp;&#125;public:int m_A;int m_B;&#125;;&#x2F;&#x2F;全局函数实现 + 号运算符重载&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;&#x2F;&#x2F;Person temp(0, 0);&#x2F;&#x2F;temp.m_A &#x3D; p1.m_A + p2.m_A;&#x2F;&#x2F;temp.m_B &#x3D; p1.m_B + p2.m_B;&#x2F;&#x2F;return temp;&#x2F;&#x2F;&#125;&#x2F;&#x2F;运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val)  &#123;Person temp;temp.m_A &#x3D; p2.m_A + val;temp.m_B &#x3D; p2.m_B + val;return temp;&#125;void test() &#123;Person p1(10, 10);Person p2(20, 20);&#x2F;&#x2F;成员函数方式Person p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123;test();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person &#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public:Person(int a, int b)&#123;this-&gt;m_A &#x3D; a;this-&gt;m_B &#x3D; b;&#125;&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;&#x2F;&#x2F;&#125;private:int m_A;int m_B;&#125;;&#x2F;&#x2F;全局函数实现左移重载&#x2F;&#x2F;ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;return out;&#125;void test() &#123;Person p1(10, 20);cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程&#125;int main() &#123;test();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyInteger &#123;friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public:MyInteger() &#123;m_Num &#x3D; 0;&#125;&#x2F;&#x2F;前置++MyInteger&amp; operator++() &#123;&#x2F;&#x2F;先++m_Num++;&#x2F;&#x2F;再返回return *this;&#125;&#x2F;&#x2F;后置++MyInteger operator++(int) &#123;&#x2F;&#x2F;先返回MyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；m_Num++;return temp;&#125;private:int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;out &lt;&lt; myint.m_Num;return out;&#125;&#x2F;&#x2F;前置++ 先++ 再返回void test01() &#123;MyInteger myInt;cout &lt;&lt; ++myInt &lt;&lt; endl;cout &lt;&lt; myInt &lt;&lt; endl;&#125;&#x2F;&#x2F;后置++ 先返回 再++void test02() &#123;MyInteger myInt;cout &lt;&lt; myInt++ &lt;&lt; endl;cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123;test01();&#x2F;&#x2F;test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:Person(int age)&#123;&#x2F;&#x2F;将年龄数据开辟到堆区m_Age &#x3D; new int(age);&#125;&#x2F;&#x2F;重载赋值运算符 Person&amp; operator&#x3D;(Person &amp;p)&#123;if (m_Age !&#x3D; NULL)&#123;delete m_Age;m_Age &#x3D; NULL;&#125;&#x2F;&#x2F;编译器提供的代码是浅拷贝&#x2F;&#x2F;m_Age &#x3D; p.m_Age;&#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题m_Age &#x3D; new int(*p.m_Age);&#x2F;&#x2F;返回自身return *this;&#125;~Person()&#123;if (m_Age !&#x3D; NULL)&#123;delete m_Age;m_Age &#x3D; NULL;&#125;&#125;&#x2F;&#x2F;年龄的指针int *m_Age;&#125;;void test01()&#123;Person p1(18);Person p2(20);Person p3(30);p3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123;test01();&#x2F;&#x2F;int a &#x3D; 10;&#x2F;&#x2F;int b &#x3D; 20;&#x2F;&#x2F;int c &#x3D; 30;&#x2F;&#x2F;c &#x3D; b &#x3D; a;&#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Person&#123;public:Person(string name, int age)&#123;this-&gt;m_Name &#x3D; name;this-&gt;m_Age &#x3D; age;&#125;;bool operator&#x3D;&#x3D;(Person &amp; p)&#123;if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)&#123;return true;&#125;else&#123;return false;&#125;&#125;bool operator!&#x3D;(Person &amp; p)&#123;if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)&#123;return false;&#125;else&#123;return true;&#125;&#125;string m_Name;int m_Age;&#125;;void test01()&#123;&#x2F;&#x2F;int a &#x3D; 0;&#x2F;&#x2F;int b &#x3D; 0;Person a(&quot;孙悟空&quot;, 18);Person b(&quot;孙悟空&quot;, 18);if (a &#x3D;&#x3D; b)&#123;cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;&#125;if (a !&#x3D; b)&#123;cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;&#125;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyPrint&#123;public:void operator()(string text)&#123;cout &lt;&lt; text &lt;&lt; endl;&#125;&#125;;void test01()&#123;&#x2F;&#x2F;重载的（）操作符 也称为仿函数MyPrint myFunc;myFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public:int operator()(int v1, int v2)&#123;return v1 + v2;&#125;&#125;;void test02()&#123;MyAdd add;int ret &#x3D; add(10, 10);cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl;&#x2F;&#x2F;匿名对象调用  cout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="/post/9c88/1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;Java页面class Java &#123;public:void header()&#123;cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;&#125;void footer()&#123;cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;&#125;void left()&#123;cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;&#125;void content()&#123;cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;Python页面class Python&#123;public:void header()&#123;cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;&#125;void footer()&#123;cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;&#125;void left()&#123;cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;&#125;void content()&#123;cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;C++页面class CPP &#123;public:void header()&#123;cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;&#125;void footer()&#123;cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;&#125;void left()&#123;cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;&#125;void content()&#123;cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;&#125;&#125;;void test01()&#123;&#x2F;&#x2F;Java页面cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;Java ja;ja.header();ja.footer();ja.left();ja.content();cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;&#x2F;&#x2F;Python页面cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;Python py;py.header();py.footer();py.left();py.content();cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;&#x2F;&#x2F;C++页面cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;CPP cp;cp.header();cp.footer();cp.left();cp.content();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>继承实现：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;公共页面class BasePage&#123;public:void header()&#123;cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;&#125;void footer()&#123;cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;&#125;void left()&#123;cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;Java页面class Java : public BasePage&#123;public:void content()&#123;cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;Python页面class Python : public BasePage&#123;public:void content()&#123;cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;C++页面class CPP : public BasePage&#123;public:void content()&#123;cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;&#125;&#125;;void test01()&#123;&#x2F;&#x2F;Java页面cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;Java ja;ja.header();ja.footer();ja.left();ja.content();cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;&#x2F;&#x2F;Python页面cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;Python py;py.header();py.footer();py.left();py.content();cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;&#x2F;&#x2F;C++页面cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;CPP cp;cp.header();cp.footer();cp.left();cp.content();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="/post/9c88/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base1&#123;public: int m_A;protected:int m_B;private:int m_C;&#125;;&#x2F;&#x2F;公共继承class Son1 :public Base1&#123;public:void func()&#123;m_A; &#x2F;&#x2F;可访问 public权限m_B; &#x2F;&#x2F;可访问 protected权限&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问&#125;&#125;;void myClass()&#123;Son1 s1;s1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限&#125;&#x2F;&#x2F;保护继承class Base2&#123;public:int m_A;protected:int m_B;private:int m_C;&#125;;class Son2:protected Base2&#123;public:void func()&#123;m_A; &#x2F;&#x2F;可访问 protected权限m_B; &#x2F;&#x2F;可访问 protected权限&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问&#125;&#125;;void myClass2()&#123;Son2 s;&#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问&#125;&#x2F;&#x2F;私有继承class Base3&#123;public:int m_A;protected:int m_B;private:int m_C;&#125;;class Son3:private Base3&#123;public:void func()&#123;m_A; &#x2F;&#x2F;可访问 private权限m_B; &#x2F;&#x2F;可访问 private权限&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问&#125;&#125;;class GrandSon3 :public Son3&#123;public:void func()&#123;&#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到&#x2F;&#x2F;m_A;&#x2F;&#x2F;m_B;&#x2F;&#x2F;m_C;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base&#123;public:int m_A;protected:int m_B;private:int m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去&#125;;&#x2F;&#x2F;公共继承class Son :public Base&#123;public:int m_D;&#125;;void test01()&#123;cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用工具查看：</p><p><img src="/post/9c88/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="/post/9c88/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base &#123;public:Base()&#123;cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;&#125;~Base()&#123;cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;&#125;&#125;;class Son : public Base&#123;public:Son()&#123;cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;&#125;~Son()&#123;cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;&#125;&#125;;void test01()&#123;&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反Son s;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base &#123;public:Base()&#123;m_A &#x3D; 100;&#125;void func()&#123;cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;&#125;void func(int a)&#123;cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;&#125;public:int m_A;&#125;;class Son : public Base &#123;public:Son()&#123;m_A &#x3D; 200;&#125;&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域void func()&#123;cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;&#125;public:int m_A;&#125;;void test01()&#123;Son s;cout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;cout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;s.func();s.Base::func();s.Base::func(10);&#125;int main() &#123;test01();system(&quot;pause&quot;);return EXIT_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base &#123;public:static void func()&#123;cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;&#125;static void func(int a)&#123;cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;&#125;static int m_A;&#125;;int Base::m_A &#x3D; 100;class Son : public Base &#123;public:static void func()&#123;cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;&#125;static int m_A;&#125;;int Son::m_A &#x3D; 200;&#x2F;&#x2F;同名成员属性void test01()&#123;&#x2F;&#x2F;通过对象访问cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;Son s;cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;&#x2F;&#x2F;通过类名访问cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;&#x2F;&#x2F;同名成员函数void test02()&#123;&#x2F;&#x2F;通过对象访问cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;Son s;s.func();s.Base::func();cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;Son::func();Son::Base::func();&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问Son::Base::func(100);&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base1 &#123;public:Base1()&#123;m_A &#x3D; 100;&#125;public:int m_A;&#125;;class Base2 &#123;public:Base2()&#123;m_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确&#125;public:int m_A;&#125;;&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public:Son()&#123;m_C &#x3D; 300;m_D &#x3D; 400;&#125;public:int m_C;int m_D;&#125;;&#x2F;&#x2F;多继承容易产生成员同名的情况&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123;Son s;cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​    两个派生类继承同一个基类</p><p>​    又有某个类同时继承者两个派生类</p><p>​    这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="/post/9c88/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Animal&#123;public:int m_Age;&#125;;&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承&#x2F;&#x2F;此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo   : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123;SheepTuo st;st.Sheep::m_Age &#x3D; 100;st.Tuo::m_Age &#x3D; 200;cout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;cout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;cout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Animal&#123;public:&#x2F;&#x2F;Speak函数就是虚函数&#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。virtual void speak()&#123;cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;&#125;&#125;;class Cat :public Animal&#123;public:void speak()&#123;cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;&#125;&#125;;class Dog :public Animal&#123;public:void speak()&#123;cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123;animal.speak();&#125;&#x2F;&#x2F;&#x2F;&#x2F;多态满足条件： &#x2F;&#x2F;1、有继承关系&#x2F;&#x2F;2、子类重写父类中的虚函数&#x2F;&#x2F;多态使用：&#x2F;&#x2F;父类指针或引用指向子类对象void test01()&#123;Cat cat;DoSpeak(cat);Dog dog;DoSpeak(dog);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;普通实现class Calculator &#123;public:int getResult(string oper)&#123;if (oper &#x3D;&#x3D; &quot;+&quot;) &#123;return m_Num1 + m_Num2;&#125;else if (oper &#x3D;&#x3D; &quot;-&quot;) &#123;return m_Num1 - m_Num2;&#125;else if (oper &#x3D;&#x3D; &quot;*&quot;) &#123;return m_Num1 * m_Num2;&#125;&#x2F;&#x2F;如果要提供新的运算，需要修改源码&#125;public:int m_Num1;int m_Num2;&#125;;void test01()&#123;&#x2F;&#x2F;普通实现测试Calculator c;c.m_Num1 &#x3D; 10;c.m_Num2 &#x3D; 10;cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;&#x2F;&#x2F;多态实现&#x2F;&#x2F;抽象计算器类&#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public :virtual int getResult()&#123;return 0;&#125;int m_Num1;int m_Num2;&#125;;&#x2F;&#x2F;加法计算器class AddCalculator :public AbstractCalculator&#123;public:int getResult()&#123;return m_Num1 + m_Num2;&#125;&#125;;&#x2F;&#x2F;减法计算器class SubCalculator :public AbstractCalculator&#123;public:int getResult()&#123;return m_Num1 - m_Num2;&#125;&#125;;&#x2F;&#x2F;乘法计算器class MulCalculator :public AbstractCalculator&#123;public:int getResult()&#123;return m_Num1 * m_Num2;&#125;&#125;;void test02()&#123;&#x2F;&#x2F;创建加法计算器AbstractCalculator *abc &#x3D; new AddCalculator;abc-&gt;m_Num1 &#x3D; 10;abc-&gt;m_Num2 &#x3D; 10;cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;delete abc;  &#x2F;&#x2F;用完了记得销毁&#x2F;&#x2F;创建减法计算器abc &#x3D; new SubCalculator;abc-&gt;m_Num1 &#x3D; 10;abc-&gt;m_Num2 &#x3D; 10;cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;delete abc;  &#x2F;&#x2F;创建乘法计算器abc &#x3D; new MulCalculator;abc-&gt;m_Num1 &#x3D; 10;abc-&gt;m_Num2 &#x3D; 10;cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;delete abc;&#125;int main() &#123;&#x2F;&#x2F;test01();test02();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Base&#123;public:&#x2F;&#x2F;纯虚函数&#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类&#x2F;&#x2F;抽象类无法实例化对象&#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类virtual void func() &#x3D; 0;&#125;;class Son :public Base&#123;public:virtual void func() &#123;cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;&#125;;&#125;;void test01()&#123;Base * base &#x3D; NULL;&#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象base &#x3D; new Son;base-&gt;func();delete base;&#x2F;&#x2F;记得销毁&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="/post/9c88/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;抽象制作饮品class AbstractDrinking &#123;public:&#x2F;&#x2F;烧水virtual void Boil() &#x3D; 0;&#x2F;&#x2F;冲泡virtual void Brew() &#x3D; 0;&#x2F;&#x2F;倒入杯中virtual void PourInCup() &#x3D; 0;&#x2F;&#x2F;加入辅料virtual void PutSomething() &#x3D; 0;&#x2F;&#x2F;规定流程void MakeDrink() &#123;Boil();Brew();PourInCup();PutSomething();&#125;&#125;;&#x2F;&#x2F;制作咖啡class Coffee : public AbstractDrinking &#123;public:&#x2F;&#x2F;烧水virtual void Boil() &#123;cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;冲泡virtual void Brew() &#123;cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;倒入杯中virtual void PourInCup() &#123;cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;加入辅料virtual void PutSomething() &#123;cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;制作茶水class Tea : public AbstractDrinking &#123;public:&#x2F;&#x2F;烧水virtual void Boil() &#123;cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;冲泡virtual void Brew() &#123;cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;倒入杯中virtual void PourInCup() &#123;cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;加入辅料virtual void PutSomething() &#123;cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;业务函数void DoWork(AbstractDrinking* drink) &#123;drink-&gt;MakeDrink();delete drink;&#125;void test01() &#123;DoWork(new Coffee);cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;DoWork(new Tea);&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Animal &#123;public:Animal()&#123;cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;&#125;virtual void Speak() &#x3D; 0;&#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数&#x2F;&#x2F;virtual ~Animal()&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;&#x2F;&#x2F;&#125;virtual ~Animal() &#x3D; 0;&#125;;Animal::~Animal()&#123;cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public:Cat(string name)&#123;cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;m_Name &#x3D; new string(name);&#125;virtual void Speak()&#123;cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;&#125;~Cat()&#123;cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;if (this-&gt;m_Name !&#x3D; NULL) &#123;delete m_Name;m_Name &#x3D; NULL;&#125;&#125;public:string *m_Name;&#125;;void test01()&#123;Animal *animal &#x3D; new Cat(&quot;Tom&quot;);animal-&gt;Speak();&#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏&#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数&#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象delete animal;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​    3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F;抽象CPU类class CPU&#123;public:&#x2F;&#x2F;抽象的计算函数virtual void calculate() &#x3D; 0;&#125;;&#x2F;&#x2F;抽象显卡类class VideoCard&#123;public:&#x2F;&#x2F;抽象的显示函数virtual void display() &#x3D; 0;&#125;;&#x2F;&#x2F;抽象内存条类class Memory&#123;public:&#x2F;&#x2F;抽象的存储函数virtual void storage() &#x3D; 0;&#125;;&#x2F;&#x2F;电脑类class Computer&#123;public:Computer(CPU * cpu, VideoCard * vc, Memory * mem)&#123;m_cpu &#x3D; cpu;m_vc &#x3D; vc;m_mem &#x3D; mem;&#125;&#x2F;&#x2F;提供工作的函数void work()&#123;&#x2F;&#x2F;让零件工作起来，调用接口m_cpu-&gt;calculate();m_vc-&gt;display();m_mem-&gt;storage();&#125;&#x2F;&#x2F;提供析构函数 释放3个电脑零件~Computer()&#123;&#x2F;&#x2F;释放CPU零件if (m_cpu !&#x3D; NULL)&#123;delete m_cpu;m_cpu &#x3D; NULL;&#125;&#x2F;&#x2F;释放显卡零件if (m_vc !&#x3D; NULL)&#123;delete m_vc;m_vc &#x3D; NULL;&#125;&#x2F;&#x2F;释放内存条零件if (m_mem !&#x3D; NULL)&#123;delete m_mem;m_mem &#x3D; NULL;&#125;&#125;private:CPU * m_cpu; &#x2F;&#x2F;CPU的零件指针VideoCard * m_vc; &#x2F;&#x2F;显卡零件指针Memory * m_mem; &#x2F;&#x2F;内存条零件指针&#125;;&#x2F;&#x2F;具体厂商&#x2F;&#x2F;Intel厂商class IntelCPU :public CPU&#123;public:virtual void calculate()&#123;cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;&#125;&#125;;class IntelVideoCard :public VideoCard&#123;public:virtual void display()&#123;cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;&#125;&#125;;class IntelMemory :public Memory&#123;public:virtual void storage()&#123;cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;Lenovo厂商class LenovoCPU :public CPU&#123;public:virtual void calculate()&#123;cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;&#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public:virtual void display()&#123;cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;&#125;&#125;;class LenovoMemory :public Memory&#123;public:virtual void storage()&#123;cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;&#125;&#125;;void test01()&#123;&#x2F;&#x2F;第一台电脑零件CPU * intelCpu &#x3D; new IntelCPU;VideoCard * intelCard &#x3D; new IntelVideoCard;Memory * intelMem &#x3D; new IntelMemory;cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;&#x2F;&#x2F;创建第一台电脑Computer * computer1 &#x3D; new Computer(intelCpu, intelCard, intelMem);computer1-&gt;work();delete computer1;cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;&#x2F;&#x2F;第二台电脑组装Computer * computer2 &#x3D; new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;computer2-&gt;work();delete computer2;cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;&#x2F;&#x2F;第三台电脑组装Computer * computer3 &#x3D; new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;computer3-&gt;work();delete computer3;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;fstream&gt;void test01()&#123;ofstream ofs;ofs.open(&quot;test.txt&quot;, ios::out);ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;ofs.close();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>  #include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123;ifstream ifs;ifs.open(&quot;test.txt&quot;, ios::in);if (!ifs.is_open())&#123;cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;return;&#125;&#x2F;&#x2F;第一种方式&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;&#x2F;&#x2F;while (ifs &gt;&gt; buf)&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;&#x2F;&#x2F;&#125;&#x2F;&#x2F;第二种&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;&#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf)))&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;&#x2F;&#x2F;&#125;&#x2F;&#x2F;第三种&#x2F;&#x2F;string buf;&#x2F;&#x2F;while (getline(ifs, buf))&#x2F;&#x2F;&#123;&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;&#x2F;&#x2F;&#125;char c;while ((c &#x3D; ifs.get()) !&#x3D; EOF)&#123;cout &lt;&lt; c;&#125;ifs.close();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件 </li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:char m_Name[64];int m_Age;&#125;;&#x2F;&#x2F;二进制文件  写文件void test01()&#123;&#x2F;&#x2F;1、包含头文件&#x2F;&#x2F;2、创建输出流对象ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);&#x2F;&#x2F;3、打开文件&#x2F;&#x2F;ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);Person p &#x3D; &#123;&quot;张三&quot;  , 18&#125;;&#x2F;&#x2F;4、写文件ofs.write((const char *)&amp;p, sizeof(p));&#x2F;&#x2F;5、关闭文件ofs.close();&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:char m_Name[64];int m_Age;&#125;;void test01()&#123;ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);if (!ifs.is_open())&#123;cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;&#125;Person p;ifs.read((char *)&amp;p, sizeof(p));cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123;test01();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++基础入门</title>
      <link href="post/efeb.html"/>
      <url>post/efeb.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h1><p>内容来源于黑马程序员</p><h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p><ul><li>创建项目</li><li>创建文件</li><li>编写代码</li><li>运行程序</li></ul><h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p><p><img src="/post/efeb/1541383178746.png" alt="1541383178746"></p><p><img src="/post/efeb/1541384366413.png" alt="1541384366413"></p><h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p><p><img src="/post/efeb/1541383817248.png" alt="1541383817248"></p><p>给C++文件起个名称，然后点击添加即可。</p><p><img src="/post/efeb/1541384140042.png" alt="1541384140042"></p><h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main() &#123;cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="/post/efeb/1541384818688.png" alt="1541384818688"></p><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p><p><strong>两种格式</strong></p><ol><li><strong>单行注释</strong>：<code>// 描述信息</code> <ul><li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li></ul></li><li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul><li>通常放在一段代码的上方，==对该段代码做整体说明==</li></ul></li></ol><blockquote><p>提示：编译器在编译代码时，会忽略注释的内容</p></blockquote><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p><p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main() &#123;&#x2F;&#x2F;变量的定义&#x2F;&#x2F;语法：数据类型  变量名 &#x3D; 初始值int a &#x3D; 10;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p></blockquote><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p><p>C++定义常量两种方式</p><ol><li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul><li>==通常在文件上方定义==，表示一个常量</li></ul></li></ol><ol start="2"><li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul><li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li></ul></li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;1、宏常量#define day 7int main() &#123;cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl;&#x2F;&#x2F;day &#x3D; 8;  &#x2F;&#x2F;报错，宏常量不可以修改&#x2F;&#x2F;2、const修饰变量const int month &#x3D; 12;cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl;&#x2F;&#x2F;month &#x3D; 24; &#x2F;&#x2F;报错，常量是不可以修改的system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p><ul><li><strong>在定义变量或者常量时候，不要用关键字</strong></li></ul><p>C++关键字如下：</p><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p><h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><blockquote><p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p></blockquote><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p><p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p><p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= long long==</p></blockquote><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于==表示小数==</p><p>浮点型变量分为两种：</p><ol><li>单精度float </li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;float f1 &#x3D; 3.14f;double d1 &#x3D; 3.14;cout &lt;&lt; f1 &lt;&lt; endl;cout &lt;&lt; d1&lt;&lt; endl;cout &lt;&lt; &quot;float  sizeof &#x3D; &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl;cout &lt;&lt; &quot;double sizeof &#x3D; &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl;&#x2F;&#x2F;科学计数法float f2 &#x3D; 3e2; &#x2F;&#x2F; 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 &#x3D; &quot; &lt;&lt; f2 &lt;&lt; endl;float f3 &#x3D; 3e-2;  &#x2F;&#x2F; 3 * 0.1 ^ 2cout &lt;&lt; &quot;f3 &#x3D; &quot; &lt;&lt; f3 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p><p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不可以是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用==1个字节==。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;char ch &#x3D; &#39;a&#39;;cout &lt;&lt; ch &lt;&lt; endl;cout &lt;&lt; sizeof(char) &lt;&lt; endl;&#x2F;&#x2F;ch &#x3D; &quot;abcde&quot;; &#x2F;&#x2F;错误，不可以用双引号&#x2F;&#x2F;ch &#x3D; &#39;abcde&#39;; &#x2F;&#x2F;错误，单引号内只能引用一个字符cout &lt;&lt; (int)ch &lt;&lt; endl;  &#x2F;&#x2F;查看字符a对应的ASCII码ch &#x3D; 97; &#x2F;&#x2F;可以直接用ASCII给字符型变量赋值cout &lt;&lt; ch &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ASCII码表格：</p><table><thead><tr><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><p>ASCII 码大致由以下<strong>两部分组</strong>成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p><p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td><strong>\n</strong></td><td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td><strong>010</strong></td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td><strong>\t</strong></td><td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td><td><strong>009</strong></td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>*<em>\\*</em></td><td><strong>代表一个反斜线字符”&quot;</strong></td><td><strong>092</strong></td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td>3位16进制</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;cout &lt;&lt; &quot;\tHello&quot; &lt;&lt; endl;cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p><p><strong>两种风格</strong></p><ol><li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;char str1[] &#x3D; &quot;hello world&quot;;cout &lt;&lt; str1 &lt;&lt; endl;    system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>注意：C风格的字符串要用双引号括起来</p></blockquote><ol><li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;string str &#x3D; &quot;hello world&quot;;cout &lt;&lt; str &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p></blockquote><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p><p>bool类型只有两个值：</p><ul><li>true  — 真（本质是1）</li><li>false — 假（本质是0）</li></ul><p><strong>bool类型占==1个字节==大小</strong></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;bool flag &#x3D; true;cout &lt;&lt; flag &lt;&lt; endl; &#x2F;&#x2F; 1flag &#x3D; false;cout &lt;&lt; flag &lt;&lt; endl; &#x2F;&#x2F; 0cout &lt;&lt; &quot;size of bool &#x3D; &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; &#x2F;&#x2F;1system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p><p><strong>关键字：</strong>cin</p><p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;&#x2F;&#x2F;整型输入int a &#x3D; 0;cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl;cin &gt;&gt; a;cout &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;浮点型输入double d &#x3D; 0;cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl;cin &gt;&gt; d;cout &lt;&lt; d &lt;&lt; endl;&#x2F;&#x2F;字符型输入char ch &#x3D; 0;cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl;cin &gt;&gt; ch;cout &lt;&lt; ch &lt;&lt; endl;&#x2F;&#x2F;字符串型输入string str;cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl;cin &gt;&gt; str;cout &lt;&lt; str &lt;&lt; endl;&#x2F;&#x2F;布尔类型输入bool flag &#x3D; true;cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl;cin &gt;&gt; flag;cout &lt;&lt; flag &lt;&lt; endl;system(&quot;pause&quot;);return EXIT_SUCCESS;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：</p><table><thead><tr><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p><p>算术运算符包括以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr><td>–</td><td>前置递减</td><td>a=2; b=–a;</td><td>a=1; b=1;</td></tr><tr><td>–</td><td>后置递减</td><td>a=2; b=a–;</td><td>a=1; b=2;</td></tr></tbody></table><p><strong>示例1：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;加减乘除int main() &#123;int a1 &#x3D; 10;int b1 &#x3D; 3;cout &lt;&lt; a1 + b1 &lt;&lt; endl;cout &lt;&lt; a1 - b1 &lt;&lt; endl;cout &lt;&lt; a1 * b1 &lt;&lt; endl;cout &lt;&lt; a1 &#x2F; b1 &lt;&lt; endl;  &#x2F;&#x2F;两个整数相除结果依然是整数int a2 &#x3D; 10;int b2 &#x3D; 20;cout &lt;&lt; a2 &#x2F; b2 &lt;&lt; endl; int a3 &#x3D; 10;int b3 &#x3D; 0;&#x2F;&#x2F;cout &lt;&lt; a3 &#x2F; b3 &lt;&lt; endl; &#x2F;&#x2F;报错，除数不可以为0&#x2F;&#x2F;两个小数可以相除double d1 &#x3D; 0.5;double d2 &#x3D; 0.25;cout &lt;&lt; d1 &#x2F; d2 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：在除法运算中，除数不能为0</p></blockquote><p><strong>示例2：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;取模int main() &#123;int a1 &#x3D; 10;int b1 &#x3D; 3;cout &lt;&lt; 10 % 3 &lt;&lt; endl;int a2 &#x3D; 10;int b2 &#x3D; 20;cout &lt;&lt; a2 % b2 &lt;&lt; endl;int a3 &#x3D; 10;int b3 &#x3D; 0;&#x2F;&#x2F;cout &lt;&lt; a3 % b3 &lt;&lt; endl; &#x2F;&#x2F;取模运算时，除数也不能为0&#x2F;&#x2F;两个小数不可以取模double d1 &#x3D; 3.14;double d2 &#x3D; 1.1;&#x2F;&#x2F;cout &lt;&lt; d1 % d2 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：只有整型变量可以进行取模运算</p></blockquote><p><strong>示例3：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递增int main() &#123;&#x2F;&#x2F;后置递增int a &#x3D; 10;a++; &#x2F;&#x2F;等价于a &#x3D; a + 1cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; 11&#x2F;&#x2F;前置递增int b &#x3D; 10;++b;cout &lt;&lt; b &lt;&lt; endl; &#x2F;&#x2F; 11&#x2F;&#x2F;区别&#x2F;&#x2F;前置递增先对变量进行++，再计算表达式int a2 &#x3D; 10;int b2 &#x3D; ++a2 * 10;cout &lt;&lt; b2 &lt;&lt; endl;&#x2F;&#x2F;后置递增先计算表达式，后对变量进行++int a3 &#x3D; 10;int b3 &#x3D; a3++ * 10;cout &lt;&lt; b3 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;赋值运算符&#x2F;&#x2F; &#x3D;int a &#x3D; 10;a &#x3D; 100;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F; +&#x3D;a &#x3D; 10;a +&#x3D; 2; &#x2F;&#x2F; a &#x3D; a + 2;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F; -&#x3D;a &#x3D; 10;a -&#x3D; 2; &#x2F;&#x2F; a &#x3D; a - 2cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F; *&#x3D;a &#x3D; 10;a *&#x3D; 2; &#x2F;&#x2F; a &#x3D; a * 2cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F; &#x2F;&#x3D;a &#x3D; 10;a &#x2F;&#x3D; 2;  &#x2F;&#x2F; a &#x3D; a &#x2F; 2;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F; %&#x3D;a &#x3D; 10;a %&#x3D; 2;  &#x2F;&#x2F; a &#x3D; a % 2;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int a &#x3D; 10;int b &#x3D; 20;cout &lt;&lt; (a &#x3D;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; (a !&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 1cout &lt;&lt; (a &gt; b) &lt;&lt; endl; &#x2F;&#x2F; 0cout &lt;&lt; (a &lt; b) &lt;&lt; endl; &#x2F;&#x2F; 1cout &lt;&lt; (a &gt;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 0cout &lt;&lt; (a &lt;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 1system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== </p></blockquote><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；  如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><p><strong>示例1：</strong>逻辑非</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;逻辑运算符  --- 非int main() &#123;int a &#x3D; 10;cout &lt;&lt; !a &lt;&lt; endl; &#x2F;&#x2F; 0cout &lt;&lt; !!a &lt;&lt; endl; &#x2F;&#x2F; 1system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 真变假，假变真</p></blockquote><p><strong>示例2：</strong>逻辑与</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;逻辑运算符  --- 与int main() &#123;int a &#x3D; 10;int b &#x3D; 10;cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 1a &#x3D; 10;b &#x3D; 0;cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 0 a &#x3D; 0;b &#x3D; 0;cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 0system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p></blockquote><p><strong>示例3：</strong>逻辑或</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;逻辑运算符  --- 或int main() &#123;int a &#x3D; 10;int b &#x3D; 10;cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 1a &#x3D; 10;b &#x3D; 0;cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 1 a &#x3D; 0;b &#x3D; 0;cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 0system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>逻辑==或==运算符总结： ==同假为假，其余为真==</p></blockquote><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p><p>if语句的三种形式</p><ul><li><p>单行格式if语句</p></li><li><p>多行格式if语句</p></li><li><p>多条件的if语句</p></li></ul><ol><li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p><p><img src="/post/efeb/clip_image002.png" alt="img"></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;选择结构-单行if语句&#x2F;&#x2F;输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印int score &#x3D; 0;cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl;cin &gt;&gt; score;cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl;&#x2F;&#x2F;if语句&#x2F;&#x2F;注意事项，在if判断语句后面，不要加分号if (score &gt; 600)&#123;cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>注意：if条件表达式后不要加分号</p></blockquote><ol start="2"><li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li></ol><p><img src="/post/efeb/clip_image002-1541662519170.png" alt="img"></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int score &#x3D; 0;cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;cin &gt;&gt; score;if (score &gt; 600)&#123;cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li></ol><p><img src="/post/efeb/clip_image002-1541662566808.png" alt="img"></p><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int score &#x3D; 0;cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;cin &gt;&gt; score;if (score &gt; 600)&#123;cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;&#125;else if (score &gt; 500)&#123;cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;&#125;else if (score &gt; 400)&#123;cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><ul><li>提示用户输入一个高考考试分数，根据分数做如下判断</li><li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li><li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;int score &#x3D; 0;cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl;cin &gt;&gt; score;if (score &gt; 600)&#123;cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl;if (score &gt; 700)&#123;cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl;&#125;else if (score &gt; 650)&#123;cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl;&#125;&#125;else if (score &gt; 500)&#123;cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl;&#125;else if (score &gt; 400)&#123;cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl;&#125;else&#123;cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习案例：</strong> 三只小猪称体重</p><p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img src="/post/efeb/%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA.jpg" alt="三只小猪"></p><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int a &#x3D; 10;int b &#x3D; 20;int c &#x3D; 0;c &#x3D; a &gt; b ? a : b;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;&#x2F;&#x2F;C++中三目运算符返回的是变量,可以继续赋值(a &gt; b ? a : b) &#x3D; 100;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">switch(表达式)&#123;case 结果1：执行语句;break;case 结果2：执行语句;break;...default:执行语句;break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;请给电影评分 &#x2F;&#x2F;10 ~ 9   经典   &#x2F;&#x2F; 8 ~ 7   非常好&#x2F;&#x2F; 6 ~ 5   一般&#x2F;&#x2F; 5分以下 烂片int score &#x3D; 0;cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl;cin &gt;&gt; score;switch (score)&#123;case 10:case 9:cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl;break;case 8:cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl;break;case 7:case 6:cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl;break;default:cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl;break;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意1：switch语句中表达式类型只能是整型或者字符型</p></blockquote><blockquote><p>注意2：case里如果没有break，那么程序会一直向下执行</p></blockquote><blockquote><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p></blockquote><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p><p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p><p><img src="/post/efeb/clip_image002-1541668640382.png" alt="img"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int num &#x3D; 0;while (num &lt; 10)&#123;cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl;num++;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><p><strong>while循环练习案例：</strong>==猜数字==</p><p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p><p><img src="/post/efeb/%E7%8C%9C%E6%95%B0%E5%AD%97.jpg" alt="猜数字"></p><h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p><p><strong>注意：</strong>与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件</p><p><img src="/post/efeb/clip_image002-1541671163478.png" alt="img"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int num &#x3D; 0;do&#123;cout &lt;&lt; num &lt;&lt; endl;num++;&#125; while (num &lt; 10);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p></blockquote><p><strong>练习案例：水仙花数</strong></p><p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>例如：1^3 + 5^3+ 3^3 = 153</p><p>请利用do…while语句，求出所有3位数中的水仙花数</p><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;for (int i &#x3D; 0; i &lt; 10; i++)&#123;cout &lt;&lt; i &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>详解：</strong></p><p><img src="/post/efeb/1541673704101.png" alt="1541673704101"></p><blockquote><p>注意：for循环中的表达式，要用分号进行分隔</p></blockquote><blockquote><p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><p><strong>练习案例：敲桌子</strong></p><p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p><p><img src="/post/efeb/timg.gif" alt="timg"></p><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p><p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p><p><img src="/post/efeb/1541676003486.png" alt="1541676003486"></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;外层循环执行1次，内层循环执行1轮for (int i &#x3D; 0; i &lt; 10; i++)&#123;for (int j &#x3D; 0; j &lt; 10; j++)&#123;cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习案例：</strong>乘法口诀表</p><p>案例描述：利用嵌套循环，实现九九乘法表</p><p><img src="/post/efeb/0006018857256120_b.jpg" alt="0006018857256120_b"></p><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><p><strong>示例1：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;1、在switch 语句中使用breakcout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl;cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl;cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl;cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl;int num &#x3D; 0;cin &gt;&gt; num;switch (num)&#123;case 1:cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl;break;case 2:cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl;break;case 3:cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl;break;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;2、在循环语句中用breakfor (int i &#x3D; 0; i &lt; 10; i++)&#123;if (i &#x3D;&#x3D; 5)&#123;break; &#x2F;&#x2F;跳出循环语句&#125;cout &lt;&lt; i &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;在嵌套循环语句中使用break，退出内层循环for (int i &#x3D; 0; i &lt; 10; i++)&#123;for (int j &#x3D; 0; j &lt; 10; j++)&#123;if (j &#x3D;&#x3D; 5)&#123;break;&#125;cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;for (int i &#x3D; 0; i &lt; 100; i++)&#123;if (i % 2 &#x3D;&#x3D; 0)&#123;continue;&#125;cout &lt;&lt; i &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：continue并没有使整个循环终止，而break会跳出循环</p></blockquote><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong> <code>goto 标记;</code></p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;goto FLAG;cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;FLAG:cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p></blockquote><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p><p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p><p><img src="/post/efeb/1541748375356.png" alt="1541748375356"></p><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p><ol><li><code>数据类型  数组名[ 数组长度 ];</code></li><li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li><li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li></ol><p>示例</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;定义方式1&#x2F;&#x2F;数据类型 数组名[元素个数];int score[10];&#x2F;&#x2F;利用下标赋值score[0] &#x3D; 100;score[1] &#x3D; 99;score[2] &#x3D; 85;&#x2F;&#x2F;利用下标输出cout &lt;&lt; score[0] &lt;&lt; endl;cout &lt;&lt; score[1] &lt;&lt; endl;cout &lt;&lt; score[2] &lt;&lt; endl;&#x2F;&#x2F;第二种定义方式&#x2F;&#x2F;数据类型 数组名[元素个数] &#x3D;  &#123;值1，值2 ，值3 ...&#125;;&#x2F;&#x2F;如果&#123;&#125;内不足10个数据，剩余数据用0补全int score2[10] &#x3D; &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;;&#x2F;&#x2F;逐个输出&#x2F;&#x2F;cout &lt;&lt; score2[0] &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; score2[1] &lt;&lt; endl;&#x2F;&#x2F;一个一个输出太麻烦，因此可以利用循环进行输出for (int i &#x3D; 0; i &lt; 10; i++)&#123;cout &lt;&lt; score2[i] &lt;&lt; endl;&#125;&#x2F;&#x2F;定义方式3&#x2F;&#x2F;数据类型 数组名[] &#x3D;  &#123;值1，值2 ，值3 ...&#125;;int score3[] &#x3D; &#123; 100,90,80,70,60,50,40,30,20,10 &#125;;for (int i &#x3D; 0; i &lt; 10; i++)&#123;cout &lt;&lt; score3[i] &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p></blockquote><blockquote><p>总结2：数组中下标是从0开始索引</p></blockquote><h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p><ol><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;数组名用途&#x2F;&#x2F;1、可以获取整个数组占用内存空间大小int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;&#x2F;&#x2F;2、可以通过数组名获取到数组首地址cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl;cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl;cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl;&#x2F;&#x2F;arr &#x3D; 100; 错误，数组名是常量，因此不可以赋值system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：数组名是常量，不可以赋值</p></blockquote><blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p></blockquote><blockquote><p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p></blockquote><p><strong>练习案例1</strong>：五只小猪称体重</p><p><strong>案例描述：</strong></p><p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p><p>找出并打印最重的小猪体重。</p><p><strong>练习案例2：</strong>数组元素逆置</p><p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p><p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><p><img src="/post/efeb/1541905327273.png" alt="1541905327273"></p><p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int arr[9] &#x3D; &#123; 4,2,8,0,5,7,1,3,9 &#125;;for (int i &#x3D; 0; i &lt; 9 - 1; i++)&#123;for (int j &#x3D; 0; j &lt; 9 - 1 - i; j++)&#123;if (arr[j] &gt; arr[j + 1])&#123;int temp &#x3D; arr[j];arr[j] &#x3D; arr[j + 1];arr[j + 1] &#x3D; temp;&#125;&#125;&#125;for (int i &#x3D; 0; i &lt; 9; i++)&#123;cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;    system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p><p><img src="/post/efeb/1541905559138.png" alt="1541905559138"></p><h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p><ol><li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol><blockquote><p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p></blockquote><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;方式1  &#x2F;&#x2F;数组类型 数组名 [行数][列数]int arr[2][3];arr[0][0] &#x3D; 1;arr[0][1] &#x3D; 2;arr[0][2] &#x3D; 3;arr[1][0] &#x3D; 4;arr[1][1] &#x3D; 5;arr[1][2] &#x3D; 6;for (int i &#x3D; 0; i &lt; 2; i++)&#123;for (int j &#x3D; 0; j &lt; 3; j++)&#123;cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;&#125;&#x2F;&#x2F;方式2 &#x2F;&#x2F;数据类型 数组名[行数][列数] &#x3D; &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;int arr2[2][3] &#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;&#x2F;&#x2F;方式3&#x2F;&#x2F;数据类型 数组名[行数][列数] &#x3D; &#123; 数据1，数据2 ,数据3，数据4  &#125;;int arr3[2][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;; &#x2F;&#x2F;方式4 &#x2F;&#x2F;数据类型 数组名[][列数] &#x3D; &#123; 数据1，数据2 ,数据3，数据4  &#125;;int arr4[][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;二维数组数组名int arr[2][3] &#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;&#x2F;&#x2F;地址cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结1：二维数组名就是这个数组的首地址</p></blockquote><blockquote><p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p></blockquote><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p><p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p><table><thead><tr><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>张三</td><td>100</td><td>100</td><td>100</td></tr><tr><td>李四</td><td>90</td><td>50</td><td>100</td></tr><tr><td>王五</td><td>60</td><td>70</td><td>80</td></tr></tbody></table><p><strong>参考答案：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int scores[3][3] &#x3D;&#123;&#123;100,100,100&#125;,&#123;90,50,100&#125;,&#123;60,70,80&#125;,&#125;;string names[3] &#x3D; &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;;for (int i &#x3D; 0; i &lt; 3; i++)&#123;int sum &#x3D; 0;for (int j &#x3D; 0; j &lt; 3; j++)&#123;sum +&#x3D; scores[i][j];&#125;cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型 </p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句 </p><p>5、return 表达式</p><p><strong>语法：</strong> </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">返回值类型 函数名 （参数列表）&#123;       函数体语句       return表达式&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数定义int add(int num1, int num2)&#123;int sum &#x3D; num1 + num2;return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p><p><strong>语法：</strong><code> 函数名（参数）</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数定义int add(int num1, int num2) &#x2F;&#x2F;定义中的num1,num2称为形式参数，简称形参&#123;int sum &#x3D; num1 + num2;return sum;&#125;int main() &#123;int a &#x3D; 10;int b &#x3D; 10;&#x2F;&#x2F;调用add函数int sum &#x3D; add(a, b);&#x2F;&#x2F;调用时的a，b称为实际参数，简称实参cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;a &#x3D; 100;b &#x3D; 100;sum &#x3D; add(a, b);cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p></blockquote><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，==如果形参发生，并不会影响实参==</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void swap(int num1, int num2)&#123;cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl;cout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl;cout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl;int temp &#x3D; num1;num1 &#x3D; num2;num2 &#x3D; temp;cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl;cout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl;cout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl;&#x2F;&#x2F;return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123;int a &#x3D; 10;int b &#x3D; 20;swap(a, b);cout &lt;&lt; &quot;mian中的 a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;mian中的 b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数常见样式&#x2F;&#x2F;1、 无参无返void test01()&#123;&#x2F;&#x2F;void a &#x3D; 10; &#x2F;&#x2F;无类型不可以创建变量,原因无法分配内存cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;&#x2F;&#x2F;test01(); 函数调用&#125;&#x2F;&#x2F;2、 有参无返void test02(int a)&#123;cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;&#125;&#x2F;&#x2F;3、无参有返int test03()&#123;cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl;return 10;&#125;&#x2F;&#x2F;4、有参有返int test04(int a, int b)&#123;cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl;int sum &#x3D; a + b;return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li> 函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;声明可以多次，定义只能一次&#x2F;&#x2F;声明int max(int a, int b);int max(int a, int b);&#x2F;&#x2F;定义int max(int a, int b)&#123;return a &gt; b ? a : b;&#125;int main() &#123;int a &#x3D; 100;int b &#x3D; 200;cout &lt;&lt; max(a, b) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol><li>创建后缀名为.h的头文件  </li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;swap.h文件#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F;实现两个数字交换的函数声明void swap(int a, int b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;swap.cpp文件#include &quot;swap.h&quot;void swap(int a, int b)&#123;int temp &#x3D; a;a &#x3D; b;b &#x3D; temp;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;main函数文件#include &quot;swap.h&quot;int main() &#123;int a &#x3D; 100;int b &#x3D; 200;swap(a, b);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;1、指针的定义int a &#x3D; 10; &#x2F;&#x2F;定义整型变量a&#x2F;&#x2F;指针定义语法： 数据类型 * 变量名 ;int * p;&#x2F;&#x2F;指针变量赋值p &#x3D; &amp;a; &#x2F;&#x2F;指针指向变量a的地址cout &lt;&lt; &amp;a &lt;&lt; endl; &#x2F;&#x2F;打印数据a的地址cout &lt;&lt; p &lt;&lt; endl;  &#x2F;&#x2F;打印指针变量p&#x2F;&#x2F;2、指针的使用&#x2F;&#x2F;通过*操作指针变量指向的内存cout &lt;&lt; &quot;*p &#x3D; &quot; &lt;&lt; *p &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><blockquote><p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p></blockquote><blockquote><p>总结2：利用指针可以记录地址</p></blockquote><blockquote><p>总结3：对指针变量解引用，可以操作指针指向的内存</p></blockquote><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int a &#x3D; 10;int * p;p &#x3D; &amp;a; &#x2F;&#x2F;指针指向数据a的地址cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;* 解引用cout &lt;&lt; sizeof(p) &lt;&lt; endl;cout &lt;&lt; sizeof(char *) &lt;&lt; endl;cout &lt;&lt; sizeof(float *) &lt;&lt; endl;cout &lt;&lt; sizeof(double *) &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：所有指针类型在32位操作系统下是4个字节</p></blockquote><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><p><strong>示例1：空指针</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;指针变量p指向内存地址编号为0的空间int * p &#x3D; NULL;&#x2F;&#x2F;访问空指针报错 &#x2F;&#x2F;内存编号0 ~255为系统占用内存，不允许用户访问cout &lt;&lt; *p &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><p><strong>示例2：野指针</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;&#x2F;&#x2F;指针变量p指向内存地址编号为0x1100的空间int * p &#x3D; (int *)0x1100;&#x2F;&#x2F;访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p><ol><li>const修饰指针   — 常量指针</li><li>const修饰常量   — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;int a &#x3D; 10;int b &#x3D; 10;&#x2F;&#x2F;const修饰的是指针，指针指向可以改，指针指向的值不可以更改const int * p1 &#x3D; &amp;a; p1 &#x3D; &amp;b; &#x2F;&#x2F;正确&#x2F;&#x2F;*p1 &#x3D; 100;  报错&#x2F;&#x2F;const修饰的是常量，指针指向不可以改，指针指向的值可以更改int * const p2 &#x3D; &amp;a;&#x2F;&#x2F;p2 &#x3D; &amp;b; &#x2F;&#x2F;错误*p2 &#x3D; 100; &#x2F;&#x2F;正确    &#x2F;&#x2F;const既修饰指针又修饰常量const int * const p3 &#x3D; &amp;a;&#x2F;&#x2F;p3 &#x3D; &amp;b; &#x2F;&#x2F;错误&#x2F;&#x2F;*p3 &#x3D; 100; &#x2F;&#x2F;错误system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p></blockquote><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main() &#123;int arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int * p &#x3D; arr;  &#x2F;&#x2F;指向数组的指针cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl;cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl;for (int i &#x3D; 0; i &lt; 10; i++)&#123;&#x2F;&#x2F;利用指针遍历数组cout &lt;&lt; *p &lt;&lt; endl;p++;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;值传递void swap1(int a ,int b)&#123;int temp &#x3D; a;a &#x3D; b; b &#x3D; temp;&#125;&#x2F;&#x2F;地址传递void swap2(int * p1, int *p2)&#123;int temp &#x3D; *p1;*p1 &#x3D; *p2;*p2 &#x3D; temp;&#125;int main() &#123;int a &#x3D; 10;int b &#x3D; 20;swap1(a, b); &#x2F;&#x2F; 值传递不会改变实参swap2(&amp;a, &amp;b); &#x2F;&#x2F;地址传递会改变实参cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p></blockquote><h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p><p><strong>示例：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;冒泡排序函数void bubbleSort(int * arr, int len)  &#x2F;&#x2F;int * arr 也可以写为int arr[]&#123;for (int i &#x3D; 0; i &lt; len - 1; i++)&#123;for (int j &#x3D; 0; j &lt; len - 1 - i; j++)&#123;if (arr[j] &gt; arr[j + 1])&#123;int temp &#x3D; arr[j];arr[j] &#x3D; arr[j + 1];arr[j + 1] &#x3D; temp;&#125;&#125;&#125;&#125;&#x2F;&#x2F;打印数组函数void printArray(int arr[], int len)&#123;for (int i &#x3D; 0; i &lt; len; i++)&#123;cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;&#125;int main() &#123;int arr[10] &#x3D; &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;int len &#x3D; sizeof(arr) &#x2F; sizeof(int);bubbleSort(arr, len);printArray(arr, len);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;stu3; &#x2F;&#x2F;结构体变量创建方式3 int main() &#123;&#x2F;&#x2F;结构体变量创建方式1struct student stu1; &#x2F;&#x2F;struct 关键字可以省略stu1.name &#x3D; &quot;张三&quot;;stu1.age &#x3D; 18;stu1.score &#x3D; 100;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl;&#x2F;&#x2F;结构体变量创建方式2struct student stu2 &#x3D; &#123; &quot;李四&quot;,19,60 &#125;;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl;stu3.name &#x3D; &quot;王五&quot;;stu3.age &#x3D; 18;stu3.score &#x3D; 80;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p></blockquote><blockquote><p>总结2：创建结构体变量时，关键字struct可以省略</p></blockquote><blockquote><p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p></blockquote><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;int main() &#123;&#x2F;&#x2F;结构体数组struct student arr[3]&#x3D;&#123;&#123;&quot;张三&quot;,18,80 &#125;,&#123;&quot;李四&quot;,19,60 &#125;,&#123;&quot;王五&quot;,20,70 &#125;&#125;;for (int i &#x3D; 0; i &lt; 3; i++)&#123;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;;int main() &#123;struct student stu &#x3D; &#123; &quot;张三&quot;,18,100, &#125;;struct student * p &#x3D; &amp;stu;p-&gt;score &#x3D; 80; &#x2F;&#x2F;指针通过 -&gt; 操作符可以访问成员cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p></blockquote><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;学生结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;;&#x2F;&#x2F;教师结构体定义struct teacher&#123;    &#x2F;&#x2F;成员列表int id; &#x2F;&#x2F;职工编号string name;  &#x2F;&#x2F;教师姓名int age;   &#x2F;&#x2F;教师年龄struct student stu; &#x2F;&#x2F;子结构体 学生&#125;;int main() &#123;struct teacher t1;t1.id &#x3D; 10000;t1.name &#x3D; &quot;老王&quot;;t1.age &#x3D; 40;t1.stu.name &#x3D; &quot;张三&quot;;t1.stu.age &#x3D; 18;t1.stu.score &#x3D; 100;cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl;cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;学生结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;;&#x2F;&#x2F;值传递void printStudent(student stu )&#123;stu.age &#x3D; 28;cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;&#125;&#x2F;&#x2F;地址传递void printStudent2(student *stu)&#123;stu-&gt;age &#x3D; 28;cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;student stu &#x3D; &#123; &quot;张三&quot;,18,100&#125;;&#x2F;&#x2F;值传递printStudent(stu);cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;cout &lt;&lt; endl;&#x2F;&#x2F;地址传递printStudent2(&amp;stu);cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age  &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;学生结构体定义struct student&#123;&#x2F;&#x2F;成员列表string name;  &#x2F;&#x2F;姓名int age;      &#x2F;&#x2F;年龄int score;    &#x2F;&#x2F;分数&#125;;&#x2F;&#x2F;const使用场景void printStudent(const student *stu) &#x2F;&#x2F;加const防止函数体中的误操作&#123;&#x2F;&#x2F;stu-&gt;age &#x3D; 100; &#x2F;&#x2F;操作失败，因为加了const修饰cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123;student stu &#x3D; &#123; &quot;张三&quot;,18,100 &#125;;printStudent(&amp;stu);system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Student&#123;string name;int score;&#125;;struct Teacher&#123;string name;Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123;string tName &#x3D; &quot;教师&quot;;string sName &#x3D; &quot;学生&quot;;string nameSeed &#x3D; &quot;ABCDE&quot;;for (int i &#x3D; 0; i &lt; len; i++)&#123;tArray[i].name &#x3D; tName + nameSeed[i];for (int j &#x3D; 0; j &lt; 5; j++)&#123;tArray[i].sArray[j].name &#x3D; sName + nameSeed[j];tArray[i].sArray[j].score &#x3D; rand() % 61 + 40;&#125;&#125;&#125;void printTeachers(Teacher tArray[], int len)&#123;for (int i &#x3D; 0; i &lt; len; i++)&#123;cout &lt;&lt; tArray[i].name &lt;&lt; endl;for (int j &#x3D; 0; j &lt; 5; j++)&#123;cout &lt;&lt; &quot;\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;&#125;&#125;&#125;int main() &#123;srand((unsigned int)time(NULL)); &#x2F;&#x2F;随机数种子 头文件 #include &lt;ctime&gt;Teacher tArray[3]; &#x2F;&#x2F;老师数组int len &#x3D; sizeof(tArray) &#x2F; sizeof(Teacher);allocateSpace(tArray, len); &#x2F;&#x2F;创建数据printTeachers(tArray, len); &#x2F;&#x2F;打印数据system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p><p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;英雄结构体struct hero&#123;string name;int age;string sex;&#125;;&#x2F;&#x2F;冒泡排序void bubbleSort(hero arr[] , int len)&#123;for (int i &#x3D; 0; i &lt; len - 1; i++)&#123;for (int j &#x3D; 0; j &lt; len - 1 - i; j++)&#123;if (arr[j].age &gt; arr[j + 1].age)&#123;hero temp &#x3D; arr[j];arr[j] &#x3D; arr[j + 1];arr[j + 1] &#x3D; temp;&#125;&#125;&#125;&#125;&#x2F;&#x2F;打印数组void printHeros(hero arr[], int len)&#123;for (int i &#x3D; 0; i &lt; len; i++)&#123;cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl;&#125;&#125;int main() &#123;struct hero arr[5] &#x3D;&#123;&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,&#125;;int len &#x3D; sizeof(arr) &#x2F; sizeof(hero); &#x2F;&#x2F;获取数组元素个数bubbleSort(arr, len); &#x2F;&#x2F;排序printHeros(arr, len); &#x2F;&#x2F;打印system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编译语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bayer图像格式</title>
      <link href="post/f067.html"/>
      <url>post/f067.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>背景：</strong></p><p>可感受光强度的传感器可以制造出能拍出黑白照片（是灰度图）的相机。但如果需要彩色图像，这种技术就无能为力了，因为当时的传感器只能感知光的强度，而无法感知颜色，也就是频率或波段。如果想要获得不同波段的光，最直接的做法是加入不同颜色的滤镜，从而滤出RGB三个通道的颜色。但是用这种方法如果对每个pixel都获得三个通道的光强的话，则需要对每个pixel都应用三个滤镜，成本过高。柯达公司的工程师Bryce Bayer ，也就是拜耳阵列的发明人，想到了一种解决方案，就是Bayer pattern。</p></li></ul><h2 id="1-关于bayer图像格式"><a href="#1-关于bayer图像格式" class="headerlink" title="1. 关于bayer图像格式"></a>1. 关于bayer图像格式</h2><ul><li>bayer 是相机内部的原始图片, 一般后缀名为 <code>raw</code>。一般需要转换为其他格式才方便查看与存储。但不同厂商的摄像头出来的 bayer 也有一些差别，主要表现在 RGB 颜色值的排列顺序上的不同。需要注意的是，我们常说的 RGB图, 即为三色图, 一个像素点就由RGB三种颜色构成的混合色, 而bayer图一个像素就只有一个颜色, 或R或G或B. 因为bayer一个像素点只有一种颜色, 需要借助这个像素点周围的颜色对它进行插值(填充)另外的两种颜色, 它本身的颜色就不用插了. 绿色占像素总数的一半，而红色和蓝色占总数的四分之一，因此也称做<code>BGGR</code>, <code>RGBG</code>, <code>GRBG</code>, <code>RGGB</code>。</li></ul><ul><li><p>数据排列格式有四种如下表：</p><p><img src="/post/f067/image-20210601230949424.png" alt="image-20210601230949424"></p></li></ul><h2 id="2-RAW数据格式"><a href="#2-RAW数据格式" class="headerlink" title="2. RAW数据格式"></a>2. RAW数据格式</h2><ul><li><p>raw格式是<code>sensor</code>的输出格式，是未经处理过的数据.</p></li><li><p>raw数据在输出的时候是有一定的顺序的，一般为以下四种:</p><ul><li>GR/BG</li><li>RG/GB</li><li>BG/GR</li><li>GB/RG</li></ul></li><li><p>raw数据几种常用的格式</p><ul><li><p><strong>raw8</strong></p><p>raw8即是用8bits表示 <code>G/R/B/G</code> 中的一个分量，而不是使用8bits表示 <code>RG/GB</code> 四个分量。在sensor中，为了降低功耗，使用一个晶体来表示一种颜色，然后利用差值计算出相邻像素的值。</p></li><li><p><strong>raw10</strong></p><p>raw10就是使用 10bit 表示上述的一个 <code>G/R/B/G</code>，但是数据中是16bit的，高6位没用。</p></li><li><p><strong>raw12</strong></p><p>raw12就是使用 12bit 表示上述的一个 <code>G/R/B/G</code>，但是数据中是16bit的，高4位没用。</p></li></ul></li></ul><h2 id="3-bayer2rgb工具"><a href="#3-bayer2rgb工具" class="headerlink" title="3. bayer2rgb工具"></a>3. bayer2rgb工具</h2><blockquote><p>bayer2rgb工具用于将摄像头采集的 RAW 图片转换为 tiff 格式后，可以在window或者ubuntu下使用图片查看器来打开。</p></blockquote><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><ul><li><p>克隆bayer2rgb项目（项目地址：<a href="https://github.com/jdthomas/bayer2rgb%EF%BC%89">https://github.com/jdthomas/bayer2rgb）</a></p><p>git clone <a href="https://github.com/jdthomas/bayer2rgb.git">https://github.com/jdthomas/bayer2rgb.git</a></p></li><li><p>编译</p><p>make</p><p><img src="/post/f067/image-20210601161503847.png" alt="image-20210601161503847"></p></li></ul><h3 id="3-2-bayer2rgb使用"><a href="#3-2-bayer2rgb使用" class="headerlink" title="3.2 bayer2rgb使用"></a>3.2 bayer2rgb使用</h3><ul><li><p>将生成的raw图像转换为RGB图像</p><p>./bayer2rgb -i ./test.raw -o ./test.tiff -w 1920 -v 1080 -b 8 -f BGGR -t</p><p><img src="/post/f067/image-20210601161958624.png" alt="image-20210601161958624"></p><p>参数说明：</p><p>-i： RAW图像文件</p><p>-o：输出rgb图像文件名</p><p>-w：图像分辨率(宽)</p><p>-v：图像分辨率(高)</p><p>-b：像素位数</p><p>-f：RAW图像格式</p><p>-t：给生成的tiff文件添加头信息(<code>如果不加上这个参数，则生成的图像只有数据信息，没有文件头信息，图片查看软件无法获知其对应格式，直接打开会提示无效图片</code>)</p></li></ul><p>参考：</p><p><a href="https://www.cnblogs.com/linhaostudy/p/11225815.html">https://www.cnblogs.com/linhaostudy/p/11225815.html</a></p><p><a href="https://blog.csdn.net/qq_29575685/article/details/103954096">https://blog.csdn.net/qq_29575685/article/details/103954096</a></p><p><a href="https://blog.csdn.net/hou5233/article/details/108595743">https://blog.csdn.net/hou5233/article/details/108595743</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/12/bayer_filter.html">http://www.ruanyifeng.com/blog/2012/12/bayer_filter.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戴尔服务器添加硬盘</title>
      <link href="post/cc06.html"/>
      <url>post/cc06.html</url>
      
        <content type="html"><![CDATA[<p>​        给<code>戴尔服务器R330</code>添加<code>12TB</code>硬盘。该服务器有4个盘位。</p><h2 id="1-添加硬盘流程"><a href="#1-添加硬盘流程" class="headerlink" title="1. 添加硬盘流程"></a>1. 添加硬盘流程</h2><h3 id="1-1-服务器关机并打开服务器后盖"><a href="#1-1-服务器关机并打开服务器后盖" class="headerlink" title="1.1 服务器关机并打开服务器后盖"></a>1.1 服务器关机并打开服务器后盖</h3><p><img src="/post/cc06/image-20210514142830314.png" alt="image-20210514142830314"></p><p><img src="/post/cc06/image-20210514142931891.png" alt="image-20210514142931891"></p><p>硬盘装好后，接上线。如下图：</p><p><img src="/post/cc06/image-20210514143235080.png" alt="image-20210514143235080"></p><h3 id="1-2-开机配置阵列"><a href="#1-2-开机配置阵列" class="headerlink" title="1.2 开机配置阵列"></a>1.2 开机配置阵列</h3><p>在开机过程中，看到有 <code>ctrl + r</code>  的提示，然后按<code>ctrl + r</code>，进入阵列卡配置界面，如下：</p><p><img src="/post/cc06/image-20210514143537833.png" alt="image-20210514143537833"></p><p>现在这块硬盘的状态是<code>NON-RAid</code>， 在系统里面可以是直接识别到的，如果做<code>RAID 0</code> 也是可以的。</p><p><img src="/post/cc06/image-20210514143615279.png" alt="image-20210514143615279"></p><p>下面将进行做<code>RAID0</code></p><p><img src="/post/cc06/image-20210514144050384.png" alt="image-20210514144050384"></p><p><img src="/post/cc06/image-20210514144131646.png" alt="image-20210514144131646"></p><p><img src="/post/cc06/image-20210514144515786.png" alt="image-20210514144515786"></p><p><img src="/post/cc06/image-20210514144610133.png" alt="image-20210514144610133"></p><p><img src="/post/cc06/image-20210514144714565.png" alt="image-20210514144714565"></p><p><img src="/post/cc06/image-20210514144822926.png" alt="image-20210514144822926"></p><p><img src="/post/cc06/image-20210514144930586.png" alt="image-20210514144930586"></p><p><img src="/post/cc06/image-20210514144955692.png" alt="image-20210514144955692"></p><p><img src="/post/cc06/image-20210514145026564.png" alt="image-20210514145026564"></p><p><img src="/post/cc06/image-20210514145059367.png" alt="image-20210514145059367"></p><p><img src="/post/cc06/image-20210514145117328.png" alt="image-20210514145117328"></p><p>到此已完成给添加的硬盘做<code>RAID0</code>，如下图</p><p><img src="/post/cc06/image-20210514145220417.png" alt="image-20210514145220417"></p><h3 id="1-3-重启机器，进入系统后在新添加的硬盘新建卷"><a href="#1-3-重启机器，进入系统后在新添加的硬盘新建卷" class="headerlink" title="1.3 重启机器，进入系统后在新添加的硬盘新建卷"></a>1.3 重启机器，进入系统后在新添加的硬盘<code>新建卷</code></h3><p><img src="/post/cc06/image-20210514145344393.png" alt="image-20210514145344393"></p><p><img src="/post/cc06/image-20210514145427221.png" alt="image-20210514145427221"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式gdb调试</title>
      <link href="post/c850.html"/>
      <url>post/c850.html</url>
      
        <content type="html"><![CDATA[<p>​        gdb 工具是 GNU 项目调试器，基于命令行。和其他的调试器一样，我们可以使用 gdb 来一行行的运行程序、单步执行、跳入/跳出函数、设置断点、查看变量等等，它是 UNIX/LINUX 操作系统下强大的程序调试工具。 gdb 支持多种语言，包括 Ada、汇编、 C/C++、 D、 Fortran、 GO、Objective-C、 OpenCL、 Modula-2、 Pascal 和 Rust。</p><p>gdb官网：<a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></p><h2 id="1-gdb和gdbserver"><a href="#1-gdb和gdbserver" class="headerlink" title="1. gdb和gdbserver"></a>1. gdb和gdbserver</h2><ul><li><p>一般交叉编译已经自带了 <code>gdb</code> 和 <code>gdbserver</code>，因此可以不用移植，直接使用交叉编译器自带的即可。如下图</p><p><img src="/post/c850/image-20210509223545066.png" alt="image-20210509223545066"></p><p>只需要将 <code>gdbserver</code> 拷贝到开发板根文件系统下即可</p></li></ul><h2 id="2-编写一个测试应用"><a href="#2-编写一个测试应用" class="headerlink" title="2. 编写一个测试应用"></a>2. 编写一个测试应用</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"runing times:%d\r\n"</span><span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>        times<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">arm-linux-gnueabihf-gcc -g main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编译的时候必须加上 <code>-g</code> 选项，这样编译出来的可执行文件才带有调试信息</p></blockquote></li></ul><h2 id="3-使用gdb调试程序"><a href="#3-使用gdb调试程序" class="headerlink" title="3. 使用gdb调试程序"></a>3. 使用gdb调试程序</h2><ul><li><p>开发板启动gdbserver </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdbserver 192.168.5.107:1234 a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/c850/image-20210509224453645.png" alt="image-20210509224453645"></p><blockquote><p>上述命令中 <code>192.168.5.107</code> 为ubuntu的 IP 地址，， <code>1234</code>是端口号，可以任意给一个端口号， <code>a.out</code>是要调试的可执行文件。</p></blockquote></li><li><p>在 ubuntu 中输入以下命令启动 gdb 调试工具</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">arm-linux-gnueabihf-gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/c850/image-20210509224755653.png" alt="image-20210509224755653"></p></li><li><p>输入如下命令连接到开发板</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">target remote 192.168.5.105:1234<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>上述命令表示连接到开发板上，其中 <code>192.168.5.105</code> 就是开发板 IP 地址， <code>1234</code> 就是开发板 <code>gdbserver</code> 设置的端口号</p></blockquote><p><img src="/post/c850/image-20210509225212458.png" alt="image-20210509225212458"></p><p>连接成功以后开发板中的 <code>gdbserver</code> 就会提示连接信息，如下图：</p><p><img src="/post/c850/image-20210509225619777.png" alt="image-20210509225619777"></p><blockquote><p>连接成功以后就可以在 <code>ubuntu</code> 上进行代码调试了</p></blockquote></li></ul><h2 id="4-VScode-gdbserver-图形化调试"><a href="#4-VScode-gdbserver-图形化调试" class="headerlink" title="4. VScode+gdbserver 图形化调试"></a>4. VScode+gdbserver 图形化调试</h2><h3 id="4-1-VSCode-设置"><a href="#4-1-VSCode-设置" class="headerlink" title="4.1 VSCode 设置"></a>4.1 VSCode 设置</h3><ul><li><p>给 VScode 安装远程调试插件<code>Remote Development</code>，点击<code>运行和调试</code>，然后选择 <code>C++(GDB/LLDB)</code> 选项，如下图：</p><p><img src="/post/c850/image-20210509234726012.png" alt="image-20210509234726012"></p><p><img src="/post/c850/image-20210509235227757.png" alt="image-20210509235227757"></p><p>选择<code>默认配置</code>后，会在当前文件夹新建一个名为 <code>launch.json</code> 的文件，此文件会存放在 <code>.vscode</code> 目录下，如下图：</p><p><img src="/post/c850/image-20210509235419305.png" alt="image-20210509235419305"></p><p><code>launch.json</code> 文件默认的内容如下所示</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="token comment">// 悬停以查看现有属性的描述。</span>    <span class="token comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"(gdb) 启动"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"输入程序名称，例如 $&#123;workspaceFolder&#125;/a.out"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"为 gdb 启用整齐打印"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>launch.json</code> 文件中有几个项目是需要我们根据实际情况配置的：</p><ul><li><strong>name</strong>：调试的项目名</li><li><strong>program</strong>：需要调试的应用程序可执行文件路径。</li><li><strong>cwd</strong>：需要调试的应用程序源码路径。</li><li><strong>miDebuggerPath</strong>：此项需要手动添加，用于指定所使用的交叉编译器 gdb 路径。</li><li><strong>miDebuggerServerAddress</strong>：此项需要手动添加，远程 gdbserver 服务器地址。  </li></ul></li><li><p>修改完成以后的 <code>launch.json</code> 文件内容如下所示 </p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="token comment">// 悬停以查看现有属性的描述。</span>    <span class="token comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"a.out"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/a.out"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"为 gdb 启用整齐打印"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"miDebuggerPath"</span><span class="token operator">:</span> <span class="token string">"/home/llr/work/am335x/sdk/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gdb"</span><span class="token punctuation">,</span>            <span class="token property">"miDebuggerServerAddress"</span><span class="token operator">:</span> <span class="token string">"192.168.5.105:1234"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-VScode-调试方法"><a href="#4-2-VScode-调试方法" class="headerlink" title="4.2 VScode 调试方法"></a>4.2 VScode 调试方法</h3><h4 id="4-2-1-启动调试"><a href="#4-2-1-启动调试" class="headerlink" title="4.2.1 启动调试"></a>4.2.1 启动调试</h4><ul><li><p>VSCode 设置好以后就可以进行调试了，首先要启动开发板上的 gdbserver，输入如下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdbserver 192.168.5.107:1234 a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>接下来再点击 VSCode 上的<code>开始调试</code>按钮 </p><p><img src="/post/c850/image-20210510000633382.png" alt="image-20210510000633382"></p><p>由于是通过网络进行调试的，因此启动调试以后会有一个建立连接的过程，可能需要几秒钟，建立成功以后如下图： </p><p><img src="/post/c850/image-20210510000921913.png" alt="image-20210510000921913"></p><p>下图为vscode调试面板</p><p><img src="/post/c850/image-20210510001038179.png" alt="image-20210510001038179"></p><p>一共有 6 个控制按钮，这 6 个按钮从左往右功能及快捷键依次如下</p><ul><li>继续按钮，快捷键为 F5，用于控制程序的运行和暂停，程序运行到断点暂停以后可以按下此按钮继续运行</li><li>单步跳过按钮，快捷键为 F10</li><li>单步调试按钮，快捷键为 F11</li><li>单步跳出按钮，快捷键为 Shift+F11</li><li>重启按钮，快捷键为 Ctrl+Shift+F5</li><li>停止按钮，快捷键为 Shift+F5</li></ul></li></ul><h4 id="4-2-2-添加断点"><a href="#4-2-2-添加断点" class="headerlink" title="4.2.2 添加断点"></a>4.2.2 添加断点</h4><ul><li><p>在需要添加断点的行前面，直接点击即可添加或取消断点，点添加成功以后会在所在行前面显示一个小红点，如下图</p><p><img src="/post/c850/image-20210510001540706.png" alt="image-20210510001540706"></p></li></ul><h4 id="4-2-3-添加监视"><a href="#4-2-3-添加监视" class="headerlink" title="4.2.3 添加监视"></a>4.2.3 添加监视</h4><ul><li><p>如果需要监视一个变量的变化，鼠标双击选中需要监视的变量名上，然后点击鼠标右键，选择“添加到监视”，如下图</p><p><img src="/post/c850/image-20210510001850839.png" alt="image-20210510001850839"></p><p>添加成功以后我们就可以在左侧的 <code>监视</code> 窗口看到刚刚添加的变量，如下图</p><p><img src="/post/c850/image-20210510002001200.png" alt="image-20210510002001200"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb使用</title>
      <link href="post/4d4b.html"/>
      <url>post/4d4b.html</url>
      
        <content type="html"><![CDATA[<p>​        gdb 工具是 GNU 项目调试器，基于命令行。和其他的调试器一样，我们可以使用 gdb 来一行行的运行程序、单步执行、跳入/跳出函数、设置断点、查看变量等等，它是 UNIX/LINUX 操作系统下强大的程序调试工具。 gdb 支持多种语言，包括 Ada、汇编、 C/C++、 D、 Fortran、 GO、Objective-C、 OpenCL、 Modula-2、 Pascal 和 Rust。</p><p>gdb官网：<a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></p><h2 id="1-gdb基本命令"><a href="#1-gdb基本命令" class="headerlink" title="1. gdb基本命令"></a>1. gdb基本命令</h2><ul><li><p>测试代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"show\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr[%d]: %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc **-g** main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编译的时候必须加上 <code>&quot;-g&quot;</code> 选项，这样编译出来的可执行文件才带有调试信息</p></blockquote></li><li><p>使用gdb调试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4d4b/image-20210509184628858.png" alt="image-20210509184628858"></p></li></ul><h3 id="1-2-run命令"><a href="#1-2-run命令" class="headerlink" title="1.2 run命令"></a>1.2 run命令</h3><ul><li><p>用于启动程序，简写：<code>r</code></p><p><img src="/post/4d4b/image-20210509184726139.png" alt="image-20210509184726139"></p></li></ul><h3 id="1-3-quit命令"><a href="#1-3-quit命令" class="headerlink" title="1.3 quit命令"></a>1.3 quit命令</h3><ul><li>退出gdb模式，简写：<code>q</code></li></ul><h3 id="1-4-break命令"><a href="#1-4-break命令" class="headerlink" title="1.4 break命令"></a>1.4 break命令</h3><ul><li><p>设置断点，简写：<code>b</code></p><p><img src="/post/4d4b/image-20210509185748811.png" alt="image-20210509185748811"></p></li></ul><h3 id="1-5-info命令"><a href="#1-5-info命令" class="headerlink" title="1.5 info命令"></a>1.5 info命令</h3><ul><li>用于显示有关正在调试的程序的内容的通用命令</li></ul><h4 id="1-5-1-info-breakpoints-b"><a href="#1-5-1-info-breakpoints-b" class="headerlink" title="1.5.1 info breakpoints(b)"></a>1.5.1 info breakpoints(<code>b</code>)</h4><ul><li><p>显示断点的状态</p><p><img src="/post/4d4b/image-20210509190348243.png" alt="image-20210509190348243"></p></li></ul><h3 id="1-6-list命令"><a href="#1-6-list命令" class="headerlink" title="1.6 list命令"></a>1.6 list命令</h3><ul><li><p>​    用于列出源码，简写：<code>l</code></p><p><img src="/post/4d4b/image-20210509190745817.png" alt="image-20210509190745817"></p></li></ul><h3 id="1-7-print命令"><a href="#1-7-print命令" class="headerlink" title="1.7 print命令"></a>1.7 print命令</h3><ul><li>用于打印变量或者变量地址，简写：<code>p</code></li></ul><h3 id="1-8-step命令"><a href="#1-8-step命令" class="headerlink" title="1.8 step命令"></a>1.8 step命令</h3><ul><li>单步调试，此命令会进入到函数里面调试</li></ul><h3 id="1-9-next命令"><a href="#1-9-next命令" class="headerlink" title="1.9 next命令"></a>1.9 next命令</h3><ul><li>单步调试，此命令<code>不会</code>进入到函数里面调试</li></ul><h3 id="1-10-shell命令"><a href="#1-10-shell命令" class="headerlink" title="1.10 shell命令"></a>1.10 shell命令</h3><ul><li><p>用于执行shell命令</p><p><img src="/post/4d4b/image-20210509192722613.png" alt="image-20210509192722613"></p></li></ul><h3 id="1-10-watchpoint命令"><a href="#1-10-watchpoint命令" class="headerlink" title="1.10 watchpoint命令"></a>1.10 watchpoint命令</h3><ul><li>用于观察变量是否变化</li></ul><h2 id="2-gdb技巧"><a href="#2-gdb技巧" class="headerlink" title="2. gdb技巧"></a>2. gdb技巧</h2><h3 id="2-1-日志功能"><a href="#2-1-日志功能" class="headerlink" title="2.1 日志功能"></a>2.1 日志功能</h3><ul><li><p>用于记录在gdb调试的日志，执行以下指令开启日志功能</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">set logging on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4d4b/image-20210509193316534.png" alt="image-20210509193316534"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux调试技术</title>
      <link href="post/21b4.html"/>
      <url>post/21b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Coredump调试"><a href="#1-Coredump调试" class="headerlink" title="1. Coredump调试"></a>1. Coredump调试</h2><blockquote><p>Coredump中文翻译核心转储，核心（Core）指的是内存映像，当进程发生错误时，系统会把核心映像写入一个文件(Core文件)，我们称为核心转储（Coredump）。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/* 内存越界,不一定会引发coredump，只有越界的地址是非法地址的时候才会出现 */</span><span class="token keyword">int</span> <span class="token function">coredump_test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0123456789abcdefg"</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 不会引发coredump */</span>    buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 会引发coredump */</span>    buf<span class="token punctuation">[</span><span class="token number">100000000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>     <span class="token comment">/* 不会引发coredump */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof buf: %ld, sizeof str: %ld\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf => %s\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 非法地址 */</span><span class="token keyword">int</span> <span class="token function">coredump_test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 空指针 */</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 没有访问权限的地址 */</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x123456</span><span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 重复释放 */</span><span class="token keyword">int</span> <span class="token function">coredump_test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 重复释放会触发coredump */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 正确释放操作 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 栈溢出 */</span><span class="token keyword">int</span> <span class="token function">coredump_test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 正常 */</span>    <span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 栈溢出，会引发coredump */</span>    <span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 无限递归调用，栈溢出, 引发coredump */</span><span class="token keyword">int</span> <span class="token function">coredump_test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">coredump_test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 除0错误 */</span><span class="token keyword">int</span> <span class="token function">coredump_test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> den <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> num <span class="token operator">/</span> den<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//coredump_test1();</span>    <span class="token comment">//coredump_test2();</span>    <span class="token comment">//coredump_test3();</span>    <span class="token comment">//coredump_test4();</span>    <span class="token comment">//coredump_test5();</span>    <span class="token function">coredump_test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><p>gcc -g coredump.c</p></li><li><p>运行</p><p><img src="/post/21b4/image-20210507234631788.png" alt="image-20210507234631788"></p></li><li><p>使用gdb调试<code>core</code></p><p>gdb <code>可执行文件</code> <code>core文件</code></p><p><img src="/post/21b4/image-20210507235042047.png" alt="image-20210507235042047"></p></li></ul><h2 id="2-内存错误调试"><a href="#2-内存错误调试" class="headerlink" title="2. 内存错误调试"></a>2. 内存错误调试</h2><h3 id="2-1-Valgrind"><a href="#2-1-Valgrind" class="headerlink" title="2.1  Valgrind"></a>2.1  Valgrind</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token comment">/* 非法读写 */</span><span class="token keyword">int</span> <span class="token function">memory_error1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 非法读 */</span>    <span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 非法写 */</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">120</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 使用未初始化的值 */</span><span class="token keyword">int</span> <span class="token function">memory_error2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value = %d\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 系统调用时使用未初始化的值或者地址 */</span><span class="token keyword">int</span> <span class="token function">memory_error3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 非法释放 */</span><span class="token keyword">int</span> <span class="token function">memory_error4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 不匹配的释放 */</span><span class="token keyword">int</span> <span class="token function">memory_error5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 不匹配的释放 */</span>    delete p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 参数不合法 */</span><span class="token keyword">int</span> <span class="token function">memory_error6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>           <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 源地址和目标地址重叠 */</span><span class="token keyword">int</span> <span class="token function">memory_error7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefghijk"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before src: %s\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>src <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after src: %s\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 内存泄露 */</span><span class="token keyword">int</span> <span class="token function">memory_error8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//memory_error1();</span>    <span class="token comment">//memory_error2();</span>    <span class="token comment">//memory_error3();</span>    <span class="token comment">//memory_error4();</span>    <span class="token comment">//memory_error5();</span>        <span class="token comment">//memory_error6();</span>    <span class="token comment">//memory_error7();</span>    <span class="token function">memory_error8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><p>g++ -g memory_valgrind.cpp</p></li><li><p>使用Valgrind运行程序</p><p><img src="/post/21b4/image-20210508223447727.png" alt="image-20210508223447727"></p></li></ul><h3 id="2-2-Asan"><a href="#2-2-Asan" class="headerlink" title="2.2 Asan"></a>2.2 Asan</h3><h2 id="3-CPU占用过高调试-多线程"><a href="#3-CPU占用过高调试-多线程" class="headerlink" title="3. CPU占用过高调试 (多线程)"></a>3. CPU占用过高调试 (<code>多线程</code>)</h2><ol><li>打印每个线程的线程id</li><li><code>top -H -p 主线程id</code>，显示每个线程占用cpu的情况</li><li>通过strace命令查看线程<code>系统调用</code>情况</li><li>通过显示信息和打印信息找到出问题的线程</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> coredump </tag>
            
            <tag> 内存错误 </tag>
            
            <tag> cpu错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核-驱动的一些命令</title>
      <link href="post/72e4.html"/>
      <url>post/72e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><h3 id="1-2-linux系统中查看设备树"><a href="#1-2-linux系统中查看设备树" class="headerlink" title="1.2 linux系统中查看设备树"></a>1.2 linux系统中查看设备树</h3><blockquote><p>以目录的形式体现设备树结构</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls &#x2F;sys&#x2F;firmware&#x2F;devicetree&#x2F;base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls &#x2F;proc&#x2F;device-tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-linux系统查看中断信息"><a href="#1-3-linux系统查看中断信息" class="headerlink" title="1.3 linux系统查看中断信息"></a>1.3 linux系统查看中断信息</h3><pre class="line-numbers language-she" data-language="she"><code class="language-she">cat &#x2F;proc&#x2F;interrupts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emmc节点挂载问题调试</title>
      <link href="post/7e72.html"/>
      <url>post/7e72.html</url>
      
        <content type="html"><![CDATA[<p>​        在zynq平台中出现使用<code>spi+emmc</code>方式启动，sd卡分区会覆盖emmc的分区</p><h2 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h2><ul><li><p>调试过程中发现有以下两种异常情况</p><p><img src="/post/7e72/image-20210427172723421.png" alt="image-20210427172723421"></p><blockquote><p>异常分别为：<code>EMMC分区没有正常挂载</code>和<code>EMMC、sd卡两个设备只有部分分区被挂载</code></p></blockquote></li></ul><h2 id="2-调试"><a href="#2-调试" class="headerlink" title="2. 调试"></a>2. 调试</h2><ul><li><p>从SPI启动，并插入sd卡，如下图</p><p><img src="/post/7e72/image-20210428101449869.png" alt="image-20210428101449869"></p><blockquote><p>EMMC和sd卡只有部分分区被挂载，并且<code>/run/media/mmcblk1p3</code>目录下的文件是<code>sd卡的p3分区</code>的文件，即emmc的分区被sd卡分区覆盖了</p></blockquote></li></ul><h3 id="2-1-修改udev用于挂载块设备的脚本"><a href="#2-1-修改udev用于挂载块设备的脚本" class="headerlink" title="2.1 修改udev用于挂载块设备的脚本"></a>2.1 修改udev用于挂载块设备的脚本</h3><ul><li><blockquote><p>这个修改，用于确认udev有没有接收到从内核发送来的关于emmc和sd卡所有分区的netlink消息</p></blockquote></li><li><p>修改<code>/etc/udev/scripts/mount.sh</code></p><p><img src="/post/7e72/image-20210427173703255.png" alt="image-20210427173703255"></p><p>执行以下命令使内核触发设备事件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm trigger --subsystem-match&#x3D;block --action&#x3D;add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/7e72/image-20210428105235593.png" alt="image-20210428105235593"></p><blockquote><p>通过结果来看，udev能正常接收到内核触发EMMC和sd卡设备每个分区的事件，由此可得出udev挂载这个环节是正常的</p></blockquote><p>通过<code>df -a</code>命令查看</p><p><img src="/post/7e72/image-20210428111422210.png" alt="image-20210428111422210"></p><blockquote><p>以上两个分区的信息异常，具体原因未知</p></blockquote></li></ul><h3 id="2-2-分析udev自启动脚本"><a href="#2-2-分析udev自启动脚本" class="headerlink" title="2.2 分析udev自启动脚本"></a>2.2 分析udev自启动脚本</h3><ol><li><p>通过分析udev启动脚本发现，udev在启动过程中，会<code>检查有没有cache</code>，如果有则解压cache tar包到<code>/</code>目录下</p><p><img src="/post/7e72/image-20210428120542010.png" alt="image-20210428120542010"></p><p>udev-cache.tar.gz包包含文件系统/dev目录下的设备节点文件，如下</p><p><img src="/post/7e72/image-20210428142554240.png" alt="image-20210428142554240"></p></li><li><p>udev-cache.tar.gz包由udev-cache服务生成，如下为udev-cache脚本</p><p><img src="/post/7e72/image-20210428143205989.png" alt="image-20210428143205989"></p><p>有关udev cache的作用，查看以下链接：</p><p><a href="https://elinux.org/Caching_of_information_on_udev">https://elinux.org/Caching_of_information_on_udev</a></p></li><li><p>尝试删除<code>udev-cache.tar.gz</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm &#x2F;etc&#x2F;udev-cache.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除后，reboot。发现eMMc和sd卡分区挂载正常（<code>各分区的文件显示正常</code>），如下图</p><p><img src="/post/7e72/image-20210428143931299.png" alt="image-20210428143931299"></p></li><li><p>结论</p><blockquote><p><strong>emmc节点挂载问题和udev cahce有关</strong></p></blockquote></li></ol><h3 id="2-3-排查udev-cache"><a href="#2-3-排查udev-cache" class="headerlink" title="2.3  排查udev cache"></a>2.3  排查udev cache</h3><ul><li><blockquote><p>排查udev cache影响emmc分区挂载的原因</p></blockquote></li></ul><ol><li><p>分析emmc和sd卡设备分区的<code>主次设备号</code>，<code>正常情况下</code>主次设备号如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;dev&#x2F;mmcblk0p1  主设备号179  次设备号1&#x2F;dev&#x2F;mmcblk0p2  主设备号179  次设备号2&#x2F;dev&#x2F;mmcblk0p3  主设备号179  次设备号3&#x2F;dev&#x2F;mmcblk1p1  主设备号179  次设备号9&#x2F;dev&#x2F;mmcblk1p2  主设备号179  次设备号10&#x2F;dev&#x2F;mmcblk1p3  主设备号179  次设备号11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/post/7e72/image-20210428151638109.png" alt="image-20210428151638109"></p></li><li><p>从SPI启动，不插sd卡，<code>正常情况</code>eMMC的主次设备如下：</p><p><img src="/post/7e72/image-20210428153035929.png" alt="image-20210428153035929"></p></li><li><p>从SPI启动，插入sd卡。<code>异常情况</code>下eMMC和sd卡的主次设备</p><p><img src="/post/7e72/image-20210428153804595.png" alt="image-20210428153804595"></p><blockquote><p>sd和emmc的主次设备号一样，从而导致emmc节点挂载异常</p></blockquote></li></ol><h2 id="3-分析udev生成cache和使用cache"><a href="#3-分析udev生成cache和使用cache" class="headerlink" title="3. 分析udev生成cache和使用cache"></a>3. 分析udev生成cache和使用cache</h2><ol><li>在烧写eMMC后，拔了sd卡，然后从<code>SPI+eMMC</code>启动</li><li>第一次启动udev-cache服务会在<code>/etc</code>目录下生成<code>udev-cache.tar.gz</code>（已经将eMMC节点和主次设备号保存了下来。分别为<code>179,1</code>、<code>179, 2</code>、<code>179,3</code>）</li><li>第二次从<code>SPI+eMMC</code>启动(<code>插上sd卡</code>)，udev在启动过程中发现有<code>udev-cache.tar.gz</code>，将会解压这个tar到<code>/dev</code>目录下进行覆盖。导致eMMC节点的主次设备号从<code>179,9</code>、<code>179,10</code>、<code>179,11</code>变为了<code>179,1</code>、<code>179, 2</code>、<code>179,3</code>。和sd卡一样的设备号。</li></ol><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><ul><li>文件系统关闭自启动udev-cache服务，不生成udev-cache.tar.gz。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> udev </tag>
            
            <tag> 问题记录 </tag>
            
            <tag> emmc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序在系统获取ip后再启动</title>
      <link href="post/b08.html"/>
      <url>post/b08.html</url>
      
        <content type="html"><![CDATA[<p>基于IMX8（<code>systemd</code>）板卡，让系统获取ip并且可以对外通信后，再启动应用程序。</p><h2 id="1-systemd-networkd-wait-online服务简介"><a href="#1-systemd-networkd-wait-online服务简介" class="headerlink" title="1. systemd-networkd-wait-online服务简介"></a>1. systemd-networkd-wait-online服务简介</h2><ul><li><p><code>systemd-networkd-wait-online</code> 是一个 一次性系统服务，用于等待网络连线成功(可以对外通信)。 默认情况下，它会一直等待到 所有被其监视且由 <code>systemd-networkd.service</code>管理的网络接口连线成功或者超时失败，并且至少有一个连接 可以对外通信。</p><blockquote><p>systemd-networkd-wait-online服务会等待网络是否连接成功，如果网络没有连接成功，该服务会一直阻塞，而其他指定了在systemd-networkd-wait-online服务之后才运行的服务，都不会运行。在由此可编写应用程序的自启动服务，让该服务在systemd-networkd-wait-online服务后才运行即可</p></blockquote></li><li><p>由于systemd-networkd-wait-online服务会等待板卡所有的网口都正常连接成功后，才继续执行其他任务。如需等待某一个网口是否连接成功。可修改<code>/lib/systemd/system/systemd-networkd-wait-online.service</code>文件，如下指定等待<code>eth0网口</code>连接成功即可</p><p><img src="/post/b08/image-20210421095349245.png" alt="image-20210421095349245"></p></li></ul><h2 id="2-编写应用程序自启动服务-service"><a href="#2-编写应用程序自启动服务-service" class="headerlink" title="2. 编写应用程序自启动服务(.service)"></a>2. 编写应用程序自启动服务(.service)</h2><ul><li><p>新建helloworld.service文件，内容如下：</p><pre class="line-numbers language-code" data-language="code"><code class="language-code">[Unit]Description&#x3D;HelloworldAfter&#x3D;basic.service systemd-networkd-wait-online.service[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;home&#x2F;root&#x2F;demo.shStandardOutput&#x3D;tty[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ExecStart： 指定要执行的程序</p><p>将该文件放置到文件系统的<code>/lib/systemd/system</code>目录下，执行以下命令配置该服务自启动</p><p>systemctl enable helloworld.service</p></blockquote><p><img src="/post/b08/image-20210421095010523.png" alt="image-20210421095010523"></p></li><li><p>在/home/root目录下新建demo.sh文件，<code>并且需要给可执行权限</code>，内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashcurl www.baidu.com &gt; &#x2F;home&#x2F;root&#x2F;log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该脚本的功能是通过网络请求一个网址的内容然后保存到/home/root/log.txt</p></blockquote></li><li><p>需要确保在板卡上能ping通域名</p><p><img src="/post/b08/image-20210421100125694.png" alt="image-20210421100125694"></p><p>完成以上操作，重新板卡</p></li><li><p>重启板卡进入文件系统后，稍等一会，在/home/root目录下会生成log.txt文件</p><p><img src="/post/b08/image-20210421100424655.png" alt="image-20210421100424655"></p></li><li><p>查看log.txt内容</p><p><img src="/post/b08/image-20210421100455696.png" alt="image-20210421100455696"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> imx8 </tag>
            
            <tag> systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单PRU网口问题</title>
      <link href="post/cf24d8c6.html"/>
      <url>post/cf24d8c6.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题原因"><a href="#1-问题原因" class="headerlink" title="1. 问题原因"></a>1. 问题原因</h2><ul><li><p><code>drivers/net/ethernet/ti/prueth.c</code> 中 pru mii0和mii1 任一初始化失败，都会跳到<code>netdev_exit</code>异常退出，导致网络功能不正常。</p><p><img src="/post/cf24d8c6/image-20210409095030279.png" alt="image-20210409095030279"></p></li></ul><h2 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h2><ol><li>修改prueth.c，对pru mii0或pru mii1单独初始化。</li><li>移植SDK5.3的驱动，SDK5.3的驱动支持通过设备树单独配置pru mii0或pru mii1  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题记录 </tag>
            
            <tag> PRU </tag>
            
            <tag> 网口 </tag>
            
            <tag> am570x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加对挂载ntfs格式u盘的支持</title>
      <link href="post/37541.html"/>
      <url>post/37541.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>在<code>570x</code>板卡中接入<code>NTFS</code>格式的<code>U盘</code>能正常挂载。能够正常读取，但是无法对U盘进行写入操作。如下图：</p><p><img src="/post/37541/image-20210408142431733.png" alt="image-20210408142431733"></p><p><img src="/post/37541/image-20210408142456070.png" alt="image-20210408142456070"></p><blockquote><p>Linux内核目前只支持对微软NTFS文件系统的读取。 NTFS-3G 是微软 NTFS 文件系统的一个开源实现，同时支持读和写。NTFS-3G 开发者使用 FUSE 文件系统来辅助开发，同时对可移植性有益。</p></blockquote><p><code>NTFS-3G</code> 详细信息可查看以下链接：</p><p><a href="https://wiki.archlinux.org/index.php/NTFS-3G_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/NTFS-3G_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><p><a href="https://www.tuxera.com/company/open-source/">https://www.tuxera.com/company/open-source/</a></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><h3 id="2-1-Linux内核配置支持FUSE文件系统"><a href="#2-1-Linux内核配置支持FUSE文件系统" class="headerlink" title="2.1 Linux内核配置支持FUSE文件系统"></a>2.1 Linux内核配置支持<code>FUSE</code>文件系统</h3><ul><li><p><img src="/post/37541/image-20210408145146318.png" alt="image-20210408145146318"></p><p><img src="/post/37541/image-20210408145220270.png" alt="image-20210408145220270"></p><blockquote><p>配置完成后，重新编译内核。</p></blockquote><p>执行以下命令，查看内核是否已经支持<code>FUSE</code>文件系统</p><pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">cat &#x2F;proc&#x2F;filesystems<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/37541/image-20210408145652681.png" alt="image-20210408145652681"></p></li></ul><h3 id="2-2-移植NTFS-3G"><a href="#2-2-移植NTFS-3G" class="headerlink" title="2.2 移植NTFS-3G"></a>2.2 移植NTFS-3G</h3><ul><li><h4 id="使用yocto进行移植NTFS-3G"><a href="#使用yocto进行移植NTFS-3G" class="headerlink" title="使用yocto进行移植NTFS-3G"></a>使用yocto进行移植NTFS-3G</h4><blockquote><p>yocto中的bb文件是<code>ntfs-3g-ntfsprogs</code></p><p>ntfs-3g：NTFS- 3g是一个稳定的、功能齐全的、可读写的NTFS驱动程序</p><p>ntfsprogs：Ntfsprogs是一组用于管理NTFS分区并与之交互的实用程序。2011年，Ntfsprogs与NTFS-3G合并</p></blockquote><p>将构建好的<code>ipk包</code>拷贝到板卡进行安装</p><p><img src="/post/37541/image-20210408151631577.png" alt="image-20210408151631577"></p><p><img src="/post/37541/image-20210408151720791.png" alt="image-20210408151720791"></p></li></ul><h2 id="3-使用ntfs-3g命令对u盘进行挂载"><a href="#3-使用ntfs-3g命令对u盘进行挂载" class="headerlink" title="3. 使用ntfs-3g命令对u盘进行挂载"></a>3. 使用ntfs-3g命令对u盘进行挂载</h2><ul><li><pre><code class="shell">ntfs-3g /dev/sda1 /run/media/sda1</code></pre><blockquote><p>如果之前已经挂载，需要先卸载</p></blockquote><p><img src="/post/37541/image-20210408152029078.png" alt="image-20210408152029078"></p></li><li><p>测试创建文件、向文件写入内容正常</p><p><img src="/post/37541/image-20210408152202166.png" alt="image-20210408152202166"></p></li></ul><blockquote><p>挂载NTFS设备，除了可以需要使用ntfs-3g命令。也可以mount命令（<code>mount 命令默认会调用/sbin/mount.ntfs, /sbin/mount.ntfs被符号链接到mount.ntfs-3g， 而mount.ntfs-3g被符号链接到/usr/bin/ntfs-3g</code>）</p></blockquote><h2 id="4-配置自动挂载NTFS设备"><a href="#4-配置自动挂载NTFS设备" class="headerlink" title="4. 配置自动挂载NTFS设备"></a>4. 配置自动挂载NTFS设备</h2><blockquote><p>目前<code>手动挂载</code>能够正常挂载ntfs设备，并且读写正常。但是如果使用<code>udev动态挂载</code>的话。会出现以下问题</p></blockquote><p><img src="/post/37541/image-20210408182534179.png" alt="image-20210408182534179"></p><p><strong>问题原因查看以下链接：</strong></p><p><a href="https://fadeer.github.io/%E5%B7%A5%E4%BD%9C/2016/10/28/udev-vs-fuse.html">https://fadeer.github.io/%E5%B7%A5%E4%BD%9C/2016/10/28/udev-vs-fuse.html</a></p><blockquote><p>主要原因是因为使用udev（<code>systemd-udevd</code>）来实现挂载，会<code>kill</code>掉mount.ntfs进程，导致挂载失败。 </p></blockquote><h3 id="4-1-解决udev挂载ntfs设备失败问题"><a href="#4-1-解决udev挂载ntfs设备失败问题" class="headerlink" title="4.1 解决udev挂载ntfs设备失败问题"></a>4.1 解决udev挂载ntfs设备失败问题</h3><ul><li><p>将<code>mount.ntfs</code> 脱离cgroups</p><p>修改文件系统<code>/etc/udev/scripts/mount.sh</code>文件，添加以下内容：</p><p><img src="/post/37541/image-20210408183239192.png" alt="image-20210408183239192"></p></li></ul><blockquote><p>重启板卡，u盘自动挂载成功。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题记录 </tag>
            
            <tag> u盘 </tag>
            
            <tag> ntfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>udev</title>
      <link href="post/26097.html"/>
      <url>post/26097.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-udev工作流程"><a href="#1-udev工作流程" class="headerlink" title="1. udev工作流程"></a>1. udev工作流程</h2><ol><li><p>当内核检测到系统中出现了新设备后，内核会通过<code>netlink</code>套接字发送<code>uevent</code>。</p></li><li><p><code>udev</code>获取内核发送的信息，进行规则的匹配。匹配的事物包括<code>SUBSYSTEM</code>、<code>ACTION</code>、<code>atttribute</code>、<code>内核提供的名称</code>（通过KERNEL=指定）以及其他的环境变量。</p></li><li><p>用获得的设备名称和主次设备号在<code>/dev/</code>目录下创建设备文件；如果是设备移除，则将已经创建的<code>/dev</code>文件被删除。</p><p><img src="/post/26097/udev.png" alt="udev"></p></li></ol><blockquote><p>​        udev完全在用户态工作，利用设备加入或移除时内核所发送的热插拔事件（hotplug event）来工作。在热插拔时，设备的详细信息都会由内核输出到位于/sys的sysfs文件系统。udev的设备命名策略、权限控制和事件处理都是在用户态完成的，它利用sysfs中的信息来进行创建设备文件节点等工作。</p></blockquote><h2 id="2-设备热插拔与冷插拔"><a href="#2-设备热插拔与冷插拔" class="headerlink" title="2. 设备热插拔与冷插拔"></a>2. 设备热插拔与冷插拔</h2><h3 id="2-1-热插拔"><a href="#2-1-热插拔" class="headerlink" title="2.1 热插拔"></a>2.1 热插拔</h3><ul><li><p>系统启动后插入的设备成为热插拔，内核检测到插拔事件后通过netlink(socket) 发送给守护进程udevd。</p><p><img src="/post/26097/4de682f636804ba8450b497d59458e3f.png" alt="4de682f636804ba8450b497d59458e3f"></p><p><img src="/post/26097/9dcb57bcfee7b3a525965b68f344be66.png" alt="9dcb57bcfee7b3a525965b68f344be66"></p></li></ul><h3 id="2-2-冷插拔"><a href="#2-2-冷插拔" class="headerlink" title="2.2 冷插拔"></a>2.2 冷插拔</h3><ul><li><p>系统启动前插入的设备在系统启动时，内核为设备在/sys目录下创建uevent文件，并记录设备信息，当udevd启动后，去读取设备信息，创建设备文件。</p><blockquote><p>sysfs下的设备都存在uevent文件，向该文件写一个“add”,内核会重新发送netlink，之后udev就可以收到设备的详细信息了，从而创建/dev下对应的设备节点。</p></blockquote></li><li><p>在系统启动后使用以下命令创建冷插拔设备文件<code>( 为每个冷插拔设备产生热插拔uevent)</code></p><p>/sbin/udevadm trigger –action=addudev</p><p>会在根文件系统可用后向内核请求所有设备事件</p></li></ul><h2 id="3-udev规则"><a href="#3-udev规则" class="headerlink" title="3. udev规则"></a>3. udev规则</h2><h3 id="3-1-规则文件目录"><a href="#3-1-规则文件目录" class="headerlink" title="3.1 规则文件目录"></a>3.1 <strong>规则文件目录</strong></h3><ul><li><p>系统规则：/lib/udev/rules.d</p><p>运行时规则：/run/udev/rules.d</p><p>自定义规则：/etc/udev/rules.d</p><blockquote><p>udev会在以上目录匹配规则</p><ol><li>etc具有最高的优先级。(自定义规则文件可以添加这个目录下)</li><li>/run会优先于/lib目录同名的文件。(不建议修改该目录下的规则文件)</li></ol></blockquote></li></ul><h3 id="3-2-规则文件命名"><a href="#3-2-规则文件命名" class="headerlink" title="3.2 规则文件命名"></a>3.2 <strong>规则文件命名</strong></h3><ul><li><p>规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。</p><blockquote><p>数字越小，优先级越大</p></blockquote></li></ul><h3 id="3-3-规则操作符"><a href="#3-3-规则操作符" class="headerlink" title="3.3 规则操作符"></a>3.3 <strong>规则操作符</strong></h3><table><thead><tr><th align="center"><strong>操作符</strong></th><th align="center">匹配或赋值</th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">==</td><td align="center">匹配</td><td align="center">相等比较</td></tr><tr><td align="center">!=</td><td align="center">匹配</td><td align="center">不等比较</td></tr><tr><td align="center">=</td><td align="center">赋值</td><td align="center">分配一个特定的值给该键，他可以覆盖之前的赋值</td></tr><tr><td align="center">+=</td><td align="center">赋值</td><td align="center">追加特定的值给已经存在的键</td></tr><tr><td align="center">:=</td><td align="center">赋值</td><td align="center">分配一个特定的值给该键，后面的规则不可能覆盖它</td></tr></tbody></table><h3 id="3-4-规则匹配键"><a href="#3-4-规则匹配键" class="headerlink" title="3.4 规则匹配键"></a>3.4 <strong>规则匹配键</strong></h3><table><thead><tr><th align="center"><strong>匹配键</strong></th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">匹配事件设备名</td></tr><tr><td align="center">ACTION</td><td align="center">事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )</td></tr><tr><td align="center">KERNEL</td><td align="center">在内核里看到的设备名字,比如sd*表示任意SCSI磁盘设备</td></tr><tr><td align="center">DEVPATH</td><td align="center">内核设备路径</td></tr><tr><td align="center">SUBSYSTEM</td><td align="center">子系统名字,例如：sda 的子系统为 block</td></tr><tr><td align="center">BUS</td><td align="center">总线的名字,比如IDE,USB</td></tr><tr><td align="center">DRIVER</td><td align="center">设备驱动的名字,比如ide-cdrom</td></tr><tr><td align="center">ID</td><td align="center">独立于内核名字的设备名字</td></tr><tr><td align="center">SYSFS{value}</td><td align="center">sysfs属性值</td></tr><tr><td align="center">ENV{key}</td><td align="center">环境变量</td></tr><tr><td align="center">PROGRAM</td><td align="center">可执行的外部程序,如果程序返回0值,该键则认为为真(true)</td></tr><tr><td align="center">RESULT</td><td align="center">上一个PROGRAM调用返回的标准输出</td></tr><tr><td align="center">SYMLINK</td><td align="center">为 /dev/下的设备文件产生符号链接.由于 udev 只能为某个设备产生一个设备文件,所以为了不覆盖系统默认的 udev 规则所产生的文件,推荐使用符号链接.</td></tr><tr><td align="center">OWNER</td><td align="center">设备文件的属组</td></tr><tr><td align="center">GROUP</td><td align="center">设备文件所在的组</td></tr><tr><td align="center">MODE</td><td align="center">设备文件的权限,采用8进制</td></tr><tr><td align="center">RUN</td><td align="center">执行的程序</td></tr></tbody></table><h3 id="3-5-udev一些特殊的值和替换值"><a href="#3-5-udev一些特殊的值和替换值" class="headerlink" title="3.5 udev一些特殊的值和替换值"></a>3.5 <strong>udev一些特殊的值和替换值</strong></h3><table><thead><tr><th align="center"><strong>特殊值</strong></th><th align="center">替换值</th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">$kernel</td><td align="center">%k</td><td align="center">设备的内核设备名称,例如：sda、cdrom</td></tr><tr><td align="center">$number</td><td align="center">%n</td><td align="center">设备的内核号码,例如：sda3 的内核号码是 3</td></tr><tr><td align="center">$devpath</td><td align="center">%p</td><td align="center">设备的 devpath路径</td></tr><tr><td align="center">$id</td><td align="center">%b</td><td align="center">设备在 devpath里的 ID 号</td></tr><tr><td align="center">$sysfs{file}</td><td align="center">%s{file}</td><td align="center">设备的sysfs里 file 的内容.其实就是设备的属性值</td></tr><tr><td align="center">$env{key}</td><td align="center">%E{key}</td><td align="center">一个环境变量的值</td></tr><tr><td align="center">$major</td><td align="center">%M</td><td align="center">主设备号</td></tr><tr><td align="center">$minor</td><td align="center">%m</td><td align="center">次设备号</td></tr><tr><td align="center">$result</td><td align="center">%c</td><td align="center">PROGRAM 返回的结果</td></tr><tr><td align="center">$parent</td><td align="center">%P</td><td align="center">父设备的设备文件名</td></tr><tr><td align="center">$root</td><td align="center">%r</td><td align="center">udev_root的值,默认是 /dev/</td></tr><tr><td align="center">$tempnode</td><td align="center">%N</td><td align="center">临时设备名</td></tr><tr><td align="center"></td><td align="center">%%</td><td align="center">符号 % 本身</td></tr><tr><td align="center"></td><td align="center">$$</td><td align="center">符号 $ 本身</td></tr></tbody></table><h2 id="4-udev配置文件"><a href="#4-udev配置文件" class="headerlink" title="4. udev配置文件"></a>4. udev配置文件</h2><ul><li><code>udev配置文件：/etc/udev/udev.conf</code></li><li><strong>udev_root：</strong>设备节点放置在文件系统中的位置。默认值为/dev/。</li><li><strong>udev_db：</strong>udev数据库的名称和位置。默认值为/dev/.udev.tdb。</li><li><strong>udev_rules：</strong>udev规则文件或目录的名称，以查找后缀为.rules的文件。所有规则文件均按词汇顺序读取。默认值为/etc/udev/rules.d/。</li><li><strong>udev_permissions：</strong>udev权限文件或目录的名称，以查找后缀为.permissions的文件。所有权限文件均按词汇顺序读取。默认值/etc/udev/permissions.d/</li><li><strong>udev_log：</strong>udev记录了有关所处理的每个设备的某些信息，则该开关。默认值为yes。</li><li><strong>default_mode：</strong>权限文件中未明确匹配的所有节点的默认模式。默认值为0666。</li><li><strong>default_owner：</strong>权限文件中未明确匹配的所有节点的默认所有者。默认值为root。</li><li><strong>default_group：</strong>权限文件中未明确匹配的所有节点的默认组。默认值为root。</li></ul><h2 id="5-udevadm工具使用"><a href="#5-udevadm工具使用" class="headerlink" title="5. udevadm工具使用"></a>5. udevadm工具使用</h2><blockquote><p>udevadm 后接一个命令和命令指定选项。它控制了udev运行的行为，处理内核事件，控制事件队列，并且提供简单的调试机制。</p></blockquote><h3 id="5-1-udevadm-info"><a href="#5-1-udevadm-info" class="headerlink" title="5.1 udevadm info"></a>5.1 udevadm info</h3><ul><li><p>查询udev数据库中的设备信息。也可以从sysfs文件系统中查询到设备的属性以辅助创建udev规则。</p><p>用法：</p><blockquote><p>udevadm info OPTIONS</p></blockquote></li><li><p><strong>option</strong>：</p><ul><li><p>-q, –query=TYPE：**默认值为：<code>all</code>**，从数据库中查询指定类型的设备。需要<code>--path</code>或<code>--name</code>来指定设备，可取以下值:</p></li><li><p>name：查询设备节点名称</p><p><img src="/post/26097/image-20210407224450315.png" alt="image-20210407224450315"></p></li><li><p>symlink：查询符号链接节点</p><p><img src="/post/26097/image-20210407224605700.png" alt="image-20210407224605700"></p></li><li><p>path：查询设备在sys文件系统(/sys)的路径</p><p><img src="/post/26097/image-20210407224644180.png" alt="image-20210407224644180"></p></li><li><p>property：查询设备属性</p><p><img src="/post/26097/image-20210407224733041.png" alt="image-20210407224733041"></p></li><li><p>all：查询所有的信息</p><p><img src="/post/26097/image-20210407224858967.png" alt="image-20210407224858967"></p></li><li><p>-p, –path=DEVPATH：设备的路径(可通过–query=path得到该路径)</p></li><li><p>-n, –name=FILE：设备节点或者链接</p></li><li><p>-a, –attribute-walk打印指定设备的所有sysfs记录的属性，以用来udev规则匹配特殊的设备(该选项打印当前设备节点的信息以及父级设备信息)</p></li><li><p>-d, –device-id-of-file=FILE：打印主/从设备号</p><p><img src="/post/26097/image-20210407225242963.png" alt="image-20210407225242963"></p></li><li><p>-e, –export-db：输出udev数据库中的内容</p></li></ul></li></ul><h3 id="5-2-udevadm-trigger"><a href="#5-2-udevadm-trigger" class="headerlink" title="5.2 udevadm trigger"></a>5.2 udevadm trigger</h3><ul><li><p>强制内核触发设备事件，主要用于重放内核初始化过程中的冷插(coldplug)设备事件。</p><p>用法：</p><blockquote><p>udevadm trigger OPTIONS</p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-v, –verbose：显示被触发的设备列表</p></li><li><p>-n, –dry-run：并不真正触发设备事件</p></li><li><p>-t, –type=TYPE：仅触发特定类型的设备，TYPE 可以是下列值之一：<code>**devices**</code>(默认值), <code>**subsystems**</code></p></li><li><p>-c, –action=ACTION：指定触发哪种类型的设备事件，ACTION 可以是下列值之一： add, remove, change(默认值)</p></li><li><p>-s, –subsystem-match=SUBSYSTEM：仅触发属于 SUBSYSTEM 子系统的设备事件(<strong>如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则，也就是说，所有匹配的子系统中的设备都会被触发。可以在SUBSYSTEM中使用shell风格的通配符。</strong>)</p></li><li><p>-S, –subsystem-nomatch=SUBSYSTEM：不触发属于SUBSYSTEM系统的设备事件。可以在SUBSYSTEM中使用shell风格的通配符。如果多次使用此选项，那么表示以AND逻辑连接每个匹配规则，也就是说，只有不匹配所有指定子系统的设备才会被触发。</p></li><li><p>-a, –attr-match=ATTRIBUTE=VALUE：仅触发那些在设备的sysfs目录中存在ATTRIBUTE文件的设备事件。如果同时还指定了”=VALUE”，那么表示仅触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定属性的设备才会被触发。</p></li><li><p> -A, –attr-nomatch=ATTRIBUTE=VALUE：不触发那些在设备的sysfs目录中存在ATTRIBUTE文件的设备事件。如果同时还指定了”=VALUE”，那么表示不触发那些ATTRIBUTE文件的内容匹配VALUE的设备事件。注意，可以在VALUE中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定属性的设备才会被触发。</p></li><li><p>-p, –property-match=PROPERTY=VALUE：仅触发那些设备的PROPERTY属性值匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则，也就是说，匹配任意一个属性值的设备都会被触发。</p></li><li><p>-g, –tag-match=PROPERTY： 仅触发匹配 PROPERTY 标签的设备事件。如果多次使用此选项， 那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定标签的设备才会被触发。</p></li><li><p>-y, –sysname-match=SYSNAME： 仅触发设备sys名称(也就是该设备在 /sys 路径下最末端的文件名)匹配 SYSNAME 的设备事件。 注意，可以在 SYSNAME 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个sys名称的设备都会被触发。</p></li><li><p>–name-match=DEVPATH： 触发给定设备及其所有子设备的事件。DEVPATH 是该设备在 /dev 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p></li><li><p>-b, –parent-match=SYSPATH： 触发给定设备及其所有子设备的事件。SYSPATH 是该设备在 /sys 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p></li><li><p>-w, –settle： 除了触发设备事件之外，还要等待这些事件完成。 注意，此选项仅等待该命令自身触发的事件完成， 而 <strong>udevadm settle</strong> 则要一直等到 所有设备事件全部完成。</p></li><li><p>–wait-daemon[=SECONDS]： 在触发设备事件之前，等待 systemd-udevd 守护进程完成初始化。 默认等待 5 秒之后超时(可以使用 SECONDS 参数修改)。 此选项等价于在 <strong>udevadm trigger</strong> 命令之前先使用 <strong>udevadm control –ping</strong> 命令。</p></li></ul><h3 id="5-3-udevadm-control"><a href="#5-3-udevadm-control" class="headerlink" title="5.3 udevadm control"></a>5.3 udevadm control</h3><ul><li><p>控制udev守护进程(<code>systemd-udevd</code>)的内部状态。</p><p>用法：</p><blockquote><p>udevadm control option</p></blockquote></li><li><p><strong>options</strong></p></li><li><p> -l, –log-priority=value<strong>：</strong>设置的内部日志等级。可以用数字或文本表示：remerg(0), alert(1), crit(2), err(3), warning(4), notice(5), info(6), debug(7)</p></li><li><p>-s, –stop-exec-queue：向 systemd-udevd 发送”禁止处理事件”信号，这样所有新发生的事件都将进入等候队列。</p></li><li><p>-S, –start-exec-queue：向systemd-udevd发送”开始处理事件”信号，也就是开始处理事件队列中尚未处理的事件。</p></li><li><p>-R, –reload：向 systemd-udevd 发送”重新加载”信号，也就是重新加载udev规则与各种数据库(包括内核模块索引)。 注意，重新加载之后并不影响已经存在的设备， 但是新的配置将会应用于所有将来发生的新设备事件。</p></li><li><p>-p, –property=KEY=value：为所有将来发生的新设备事件统一设置一个全局的 KEY 属性，并将其值设为 value</p></li><li><p>-m, –children-max=value：设置最多允许 systemd-udevd 同时处理多少个设备事件。</p></li></ul><h3 id="5-4-udevadm-monitor"><a href="#5-4-udevadm-monitor" class="headerlink" title="5.4 udevadm monitor"></a>5.4 udevadm monitor</h3><ul><li><p>监视内核发出的设备事件(以”KERNEL”标记)，以及udev在处理完udev规则之后发出的事件(以”UDEV”标记)，并在控制台上输出事件的设备路径(devpath)。可用于分析udev处理设备事件所花的时间(比较”KERNEL”与”UDEV”的时间戳)。</p><p>用法：</p><blockquote><p>udevadm monitor options</p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-k, –kernel：仅显示”KERNEL”事件</p></li><li><p>-u, –udev：仅显示”UDEV”事件</p></li><li><p>-p, –property：同时还显示事件的各属性</p></li><li><p>-s, –subsystem-match=subsystem[/devtype]： 根据 subsystem[/devtype] 对事件(包括 kernel uevent 与 udev event)进行过滤，仅显示与”子系统[/设备类型]”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有指定子系统中的设备都会被监视。</p></li><li><p>-t, –tag-match=string：根据设备标签对事件(仅 udev event)进行过滤，仅显示与”标签”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，拥有任一指定标签的设备都会被监视。</p></li></ul><h3 id="5-5-udevadm-test"><a href="#5-5-udevadm-test" class="headerlink" title="5.5 udevadm test"></a>5.5 udevadm test</h3><ul><li><p>模拟一个设备事件，并输出调试信息。</p><p>用法：</p><blockquote><p>udevadm test OPTIONS <syspath></syspath></p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-a, –action=ACTION：指定模拟哪种类型的设备事件，ACTION 可以是下列值之一：add(默认值), remove, change</p></li></ul><h3 id="5-5-1-演示"><a href="#5-5-1-演示" class="headerlink" title="5.5.1 演示"></a>5.5.1 演示</h3><ul><li><p>如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm test $(udevadm info -q path -n &#x2F;dev&#x2F;sda)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408094410301.png" alt="image-20210408094410301"></p></li></ul><h2 id="6-udev测试演示"><a href="#6-udev测试演示" class="headerlink" title="6. udev测试演示"></a>6. udev测试演示</h2><ol><li><p><strong>插入usb摄像头，查询摄像头信息(<code>有两种方式可查询</code>)</strong></p><ul><li><p>执行以下命令后再将摄像头插入</p></li><li><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm monitor -p --subsystem-match&#x3D;input<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><img src="/post/26097/image-20210408095551985.png" alt="image-20210408095551985"></p></li><li><p>通过设备节点名查询信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm info -q all -n &#x2F;dev&#x2F;input&#x2F;event2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408095710873.png" alt="image-20210408095710873"></p></li></ul></li><li><p><strong>查询KERNEL信息</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm info -q all -a -n &#x2F;dev&#x2F;input&#x2F;event2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408100243875.png" alt="image-20210408100243875"></p></li><li><p><strong>创建规则</strong></p><blockquote><p>根据以上查询可以得到以下信息</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ACTION&#x3D;&#x3D;&quot;add&quot; SUBSYSTEM&#x3D;&#x3D;&quot;input&quot; KERNEL&#x3D;&#x3D;&quot;event2&quot; ENV&#123;ID_TYPE&#125;&#x3D;&#x3D;&quot;video&quot;  ENV&#123;ID_BUS&#125;&#x3D;&#x3D;&quot;usb&quot; SYMLINK+&#x3D;&quot;input&#x2F;usb_camera&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ul><li><p>在<code>/etc/udev/rules.d/</code>目录下创建<code>usb_camera.rules</code>规则文件</p></li><li><p>重新加载udev</p><pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">udevadm control -R<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行以下命令，重新触发事件后可以看到生成<code>usb_camera</code>符号链接</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm trigger --action&#x3D;add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408140008962.png" alt="image-20210408140008962"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> udev </tag>
            
            <tag> linux </tag>
            
            <tag> udev规则 </tag>
            
            <tag> udev工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zynq无法识别usb摄像头</title>
      <link href="post/19321.html"/>
      <url>post/19321.html</url>
      
        <content type="html"><![CDATA[<p>在Zynq(核心板：<code>创龙 SOM-TL7020</code>)上接入usb摄像头，无法识别usb摄像头，没有在/dev目录下生成video节点</p><p><img src="/post/19321/image-20210331091713253.png" alt="image-20210331091713253"></p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h2><ul><li>缺少驱动，要支持usb的摄像头，需要 v4l2驱动和UVC驱动</li></ul><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h2><ul><li>将v4l2驱动和UVC驱动编译进内核，然后重新编译内核即可。</li><li>内核默认已支持v4l2驱动，添加UVC驱动即可。</li></ul><h3 id="2-1-配置内核"><a href="#2-1-配置内核" class="headerlink" title="2.1 配置内核"></a>2.1 配置内核</h3><ul><li><p>CONFIG_USB_VIDEO_CLASS<br>CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV</p><p>将以上两个宏设置为<code>y</code></p><p><img src="/post/19321/image-20210331092252053.png" alt="image-20210331092252053"></p><blockquote><p>重新编译内核</p></blockquote></li></ul><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><ul><li><p>接入usb摄像头，能够正常识别。</p><p><img src="/post/19321/image-20210331093210237.png" alt="image-20210331093210237"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zynq </tag>
            
            <tag> usb摄像头 </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot配置从网络加载linux系统</title>
      <link href="post/45266.html"/>
      <url>post/45266.html</url>
      
        <content type="html"><![CDATA[<p>基于<code>广州创龙</code>的TL5728-EasyEVM开发板配置uboot通过tftp加载内核、设备树， 内核通过nfs挂载nfs文件系统。</p><blockquote><p>ubuntu需要先安装tftp/nfs服务。</p></blockquote><p><strong>u-boot环境变量已提供<code>netboot</code>变量来实现从网络加载linux系统</strong></p><p><img src="/post/45266/image-20210323103650020.png" alt="image-20210323103650020"></p><h2 id="1-u-boot环境变量配置"><a href="#1-u-boot环境变量配置" class="headerlink" title="1. u-boot环境变量配置"></a>1. u-boot环境变量配置</h2><h3 id="1-1-配置通过tftp加载内核、设备树"><a href="#1-1-配置通过tftp加载内核、设备树" class="headerlink" title="1.1 配置通过tftp加载内核、设备树"></a>1.1 配置通过tftp加载内核、设备树</h3><ol start="2"><li><p>设置<code>serverip</code>变量（提供tftp、nfs服务的主机ip）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv serverip 192.168.1.99<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>ipaddr</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv ipaddr 192.168.1.144<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>fdtfile</code>变量（<strong>即配置设备树文件名</strong>）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv fdtfile tl5728-easy-evm.dtb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-2-验证加载内核、设备树是否正常"><a href="#1-2-验证加载内核、设备树是否正常" class="headerlink" title="1.2 验证加载内核、设备树是否正常"></a>1.2 验证加载内核、设备树是否正常</h3><ul><li><p>执行以下两条命令，出现下图所示，则说明加载内核、设备树成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">run netloadimagerun netloadfdt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/post/45266/image-20210323104653075.png" alt="image-20210323104653075"></p></li></ul><h3 id="1-3-u-boot配置内核从nfs挂载文件系统"><a href="#1-3-u-boot配置内核从nfs挂载文件系统" class="headerlink" title="1.3 u-boot配置内核从nfs挂载文件系统"></a>1.3 u-boot配置内核从nfs挂载文件系统</h3><ol><li><p>设置<code>rootpath</code>变量</p><blockquote><p>nfs共享文件系统路径</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv rootpath &#x2F;home&#x2F;llr&#x2F;work&#x2F;nfs-share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>netboot</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv netboot &#39;echo Booting from network ...; run netloadimage; run netloadfdt; run netargs; bootz $&#123;loadaddr&#125; - $&#123;fdtaddr&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动系统</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">run netboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-4-设置bootcmd变量，上电开机从网络启动系统"><a href="#1-4-设置bootcmd变量，上电开机从网络启动系统" class="headerlink" title="1.4 设置bootcmd变量，上电开机从网络启动系统"></a>1.4 设置bootcmd变量，上电开机从网络启动系统</h3><ol><li><p>设置<code>bootcmd</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv bootcmd &#39;run netboot&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-5-其他参考"><a href="#1-5-其他参考" class="headerlink" title="1.5 其他参考"></a>1.5 其他参考</h3><ul><li>​    有关通过nfs挂载文件系统说明文档，可查看在内核源码目录下的<code>Documentation/filesystems/nfs/nfsroot.txt</code>文件</li><li><a href="https://linuxlink.timesys.com/docs/static_ip">https://linuxlink.timesys.com/docs/static_ip</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode使用</title>
      <link href="post/3653.html"/>
      <url>post/3653.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-插件说明"><a href="#1-插件说明" class="headerlink" title="1. 插件说明"></a>1. 插件说明</h2><ol><li><p>C/C++</p><p>C/C++开发必装插件</p></li><li><p>Include AutoComplete</p><p>自动头文件包含 </p></li><li><p>Rainbow Brackets</p><p>彩虹花括号，有助于阅读代码</p></li><li><p>ARM</p><p>支持 ARM 汇编语法高亮显示</p></li><li><p>Chinese(Simplified)</p><p>中文环境</p></li><li><p>TabNine</p><p>自动补全插件</p></li><li><p>DeviceTree</p><p>设备树语法插件</p></li><li><p>GBKtoUTF8</p><p>将 GBK 转换为 UTF8</p></li><li><p>git graph</p><p>显示git 有关的所有代码提交信息，可以方便查看本地分支、远程分支、主干的 commit、push、pull 情况</p></li></ol><h2 id="2-实用功能"><a href="#2-实用功能" class="headerlink" title="2. 实用功能"></a>2. 实用功能</h2><h3 id="2-1-两个文件比较"><a href="#2-1-两个文件比较" class="headerlink" title="2.1 两个文件比较"></a>2.1 两个文件比较</h3><ul><li><p>比较文件</p><p><img src="/post/3653/image-20210322235108892.png" alt="image-20210322235108892"></p><p><img src="/post/3653/image-20210322235222241.png" alt="image-20210322235222241"></p><p><img src="/post/3653/image-20210322235317023.png" alt="image-20210322235317023"></p></li></ul><h3 id="3-2-函数列表"><a href="#3-2-函数列表" class="headerlink" title="3.2 函数列表"></a>3.2 函数列表</h3><ul><li><p>点击<code>左下角</code>大纲可查看当前打开的文件的函数列表</p><p><img src="/post/3653/image-20210403230716148.png" alt="image-20210403230716148"></p></li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><h3 id="3-1-取消预览模式"><a href="#3-1-取消预览模式" class="headerlink" title="3.1 取消预览模式"></a>3.1 取消预览模式</h3><ul><li><p>VScode 上打开一个新文件的话会覆盖掉以前的文件，这是因为 VSCode 默认开启了预览模式，预览模式下单击左侧的文件就会覆盖掉当前的打开的文件。如果不想覆盖的话采用双击打开即可，或者设置 VSCode 关闭预览模式</p><p><img src="/post/3653/image-20210323151845681.png" alt="image-20210323151845681"></p></li></ul><h3 id="3-2-添加头文件路径"><a href="#3-2-添加头文件路径" class="headerlink" title="3.2 添加头文件路径"></a>3.2 添加头文件路径</h3><ul><li><p>按下“<code>Ctrl+Shift+P</code>”打开搜索框，然后输入“<code>Edit configurations</code>”，选择“<code>C/C++:Edit configurations</code>”</p><p><img src="/post/3653/image-20210323152230025.png" alt="image-20210323152230025"></p><p>c_cpp_properties.json 中的变量“<code>includePath</code>”用于指定工程中的头文件路径</p><p><img src="/post/3653/image-20210323152411219.png" alt="image-20210323152411219"></p></li></ul><h3 id="4-快捷键"><a href="#4-快捷键" class="headerlink" title="4. 快捷键"></a>4. 快捷键</h3><table><thead><tr><th align="center">Ctrl+鼠标左键</th><th align="center">是文件、函数等跳转</th></tr></thead><tbody><tr><td align="center">Alt + ←</td><td align="center">是跳转后返回原处</td></tr><tr><td align="center">Ctrl + Shift + O</td><td align="center">列出函数名</td></tr><tr><td align="center">Ctrl + P</td><td align="center">列出近期打开的文件名</td></tr><tr><td align="center">Ctrl + Tab</td><td align="center">可以列出最近打开的文件，在开发时，两个文件间切换时效率很高。</td></tr><tr><td align="center">ctrl+p</td><td align="center">查找文件</td></tr><tr><td align="center">ctrl + shift + \</td><td align="center">在对应的{}跳转</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMX8使用weston-calibrator无法校准</title>
      <link href="post/46514.html"/>
      <url>post/46514.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1. 环境说明"></a>1. 环境说明</h2><blockquote><p>yocto：3.0(<code>zeus</code>)</p><p>linux：5.4.70-2.3.0</p><p>weston：9.0</p><p>触摸屏：LVDS屏</p></blockquote><h2 id="2-排查问题"><a href="#2-排查问题" class="headerlink" title="2. 排查问题"></a>2. 排查问题</h2><h3 id="2-1-确定触摸节点是否能接受到事件"><a href="#2-1-确定触摸节点是否能接受到事件" class="headerlink" title="2.1 确定触摸节点是否能接受到事件"></a>2.1 确定触摸节点是否能接受到事件</h3><p><img src="/post/46514/image-20210317152007220.png" alt="image-20210317152007220"></p><blockquote><p>触摸节点能正常接收到触摸事件</p></blockquote><h3 id="2-2-查看weston日志"><a href="#2-2-查看weston日志" class="headerlink" title="2.2 查看weston日志"></a>2.2 查看weston日志</h3><p>/run/user/0/weston.log</p><p>发现日志中有以下问题， 经过查找资料后得知。</p><blockquote><p>内核中的触摸屏驱动程序运行不正常，libinput 不接受输入(<code>weston依赖libinput</code>)，所以导致使用weston-calibrator无法校准</p></blockquote><p><img src="/post/46514/image-20210317151744111.png" alt="image-20210317151744111"></p><h3 id="2-3-使用libinput-debug-events进行调试"><a href="#2-3-使用libinput-debug-events进行调试" class="headerlink" title="2.3 使用libinput debug-events进行调试"></a>2.3 使用libinput debug-events进行调试</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">libinput debug-events<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/46514/image-20210317152754075.png" alt="image-20210317152754075"></p><blockquote><p>运行libinput 工具后， 可以看到红色部分提示触摸屏驱动程序存在问题。</p></blockquote><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><blockquote><p>修改触摸屏驱动</p><p>参考：<a href="https://wiki.postmarketos.org/wiki/Troubleshooting:touchscreen">https://wiki.postmarketos.org/wiki/Troubleshooting:touchscreen</a></p><p>经过修改触摸屏驱动后，重新编译内核，使用weston-calibrator能够正常校准。</p></blockquote><h2 id="3-经过校准后，点击屏幕位置有偏差"><a href="#3-经过校准后，点击屏幕位置有偏差" class="headerlink" title="3. 经过校准后，点击屏幕位置有偏差"></a>3. 经过校准后，点击屏幕位置有偏差</h2><p>使用weston和tslib校准工具调试，发现在屏幕按<code>X轴</code>来滑动，校准工具打印出的是<code>Y轴</code>的值在改变。（<code>也可以使用libinput工具调试</code>）</p><p>经过排查后发现触摸屏的引脚定义是按竖屏，和我们使用的横屏效果反过来，经过调整排线线序后， 重新测试校准。校准后位置偏差问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IMX8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译内核出现无法定位strict.pm</title>
      <link href="post/2920.html"/>
      <url>post/2920.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1. 环境说明"></a>1. 环境说明</h2><blockquote><p>虚拟机：Ubuntu 16.04.5</p><p>sdk：使用TI提供的ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86-Install.bin</p><p>内核版本：linux-4.9.65</p></blockquote><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><ol><li><p>在编译内核过程中出现以下错误：</p><p><img src="/post/2920/image-20210318003635703.png" alt="image-20210318003635703"></p></li></ol><h2 id="3-排查"><a href="#3-排查" class="headerlink" title="3. 排查"></a>3. 排查</h2><ol><li><p>经过排查发现<code>processor-sdk</code>包里包含<code>perl</code>工具，在使用以下命令导入交叉编译工具时，会将<code>sdk</code>自带的<code>perl</code>工具也导入到当前的环境中。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PATH&#x3D;&#x2F;home&#x2F;llr&#x2F;ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86&#x2F;linux-devkit&#x2F;sysroots&#x2F;x86_64-arago-linux&#x2F;usr&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/2920/image-20210318004109095.png" alt="image-20210318004109095"></p><blockquote><p><code>perl</code>工具和<code>交叉编译工具</code>在同一目录下。通过<code>export</code>导入交叉编译工具时，也导入了<code>perl</code>工具。</p></blockquote><p>而ubuntu默认也安装了<code>perl</code>，所以造成冲突。导致在编译内核时出现<code>Can&#39;t locate strict.pm in @INC (you may need to install the strict module)</code></p></li></ol><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><ul><li><p>使用<code>PERL5LIB</code>环境变量指定<code>perl</code>模块所在的目录即可。如下：</p><p>将<code>perl</code>模块目录指定到sdk包下的目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PERL5LIB&#x3D;&#x2F;home&#x2F;llr&#x2F;ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86&#x2F;linux-devkit&#x2F;sysroots&#x2F;armv7ahf-neon-linux-gnueabi&#x2F;usr&#x2F;lib&#x2F;perl&#x2F;5.22.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新编译内核即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>usb3.0接口测试</title>
      <link href="post/56523.html"/>
      <url>post/56523.html</url>
      
        <content type="html"><![CDATA[<p>基于 <code>创龙</code> 5708平台下测试usb3.0接口。测试DM/DP、RXN/RXP、TXN/TXP信号线是否正常。</p><p><strong>原理图不提供</strong></p><blockquote><p>USB是一种差分信号，数据是由正、负信号的差值所决定 </p><p>DM/DP差分对信号线与USB2.0的连接方式一样，只要一对一直接连接就可以。 </p><p>usb3.0需要用到RXP/RXN,TXP/TXN差分对来进行高速的数据传输 </p><p>因为需要测试usb3.0，需要拆除TX端的电容，当电容拆除后，TX端的线就断开了，就不能使用 usb3.0协议，只能使用usb2.0协议</p></blockquote><blockquote><p><strong>拆掉其中一个usb3.0接口的电容，这里拆掉C102/C103电容。另一个usb3.0接口保持不变</strong></p></blockquote><ol><li><p>使用usb3.0 U盘接到<code>已拆除电容</code>的usb3.0接口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard.png" alt="img"></p></li><li><p>使用usb3.0 U盘接到<code>未拆除电容</code>的usb3.0接口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard-1615395634957.png" alt="img"></p></li><li><p>使用<code>usb2.0 U盘</code>接到<code>已拆除电容</code>和<code>未拆除电容</code>的<code>usb 3.0</code>接口，结果都一样，如下图</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard-1615395726474.png" alt="img"></p><blockquote><p><strong>结论：</strong>测试usb3.0接口，需要用usb3.0的设备，如果使用的是usb2.0设备，则无法测试到RX 和TX的信号线是否正常</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外设测试 </tag>
            
            <tag> usb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo引用本地图片</title>
      <link href="post/30757.html"/>
      <url>post/30757.html</url>
      
        <content type="html"><![CDATA[<p>hexo引用本地图片, 本地编辑器里可以直接<code>预览图片</code>，发布的文章图片也可以<code>正常显示</code>。</p><blockquote><p>hexo版本：5.4.0</p></blockquote><h2 id="1-引用本地图片"><a href="#1-引用本地图片" class="headerlink" title="1. 引用本地图片"></a>1. 引用本地图片</h2><ol><li><p>首先要在 Hexo 博客配置文件(<code>_config.yml</code>)中开启使用本地资源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">post_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建博客文件(<code>.md文件</code>)</p><p>首先在 <code>_posts</code> 文件夹下建立一个博客文件(<code>例如：hexo引用本地图片.md</code>)，然后再创建一个同名的文件夹(<code>hexo引用本地图片</code>)，这篇文章要引用的图片就在这个文件夹下。</p><blockquote><p>使用Typora插入图片，必须勾选 <code>优先使用相对路径</code></p><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 优先使用相对路径</p></blockquote><p><img src="/post/30757/image-20210308163658889.png" alt="image-20210308163658889"></p></li><li><p>安装hexo-asset-image插件</p><blockquote><p><strong>注意：使用了 npm 仓库里的插件 hexo-asset-image有问题，需要从Github 仓库的源码安装才正常</strong></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install https:&#x2F;&#x2F;github.com&#x2F;xcodebuild&#x2F;hexo-asset-image.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，在Typora中向文章插入图片能实时预览，部署文章后。图片显示也正常。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
