<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>bayer图像格式</title>
      <link href="post/f067.html"/>
      <url>post/f067.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>背景：</strong></p><p>可感受光强度的传感器可以制造出能拍出黑白照片（是灰度图）的相机。但如果需要彩色图像，这种技术就无能为力了，因为当时的传感器只能感知光的强度，而无法感知颜色，也就是频率或波段。如果想要获得不同波段的光，最直接的做法是加入不同颜色的滤镜，从而滤出RGB三个通道的颜色。但是用这种方法如果对每个pixel都获得三个通道的光强的话，则需要对每个pixel都应用三个滤镜，成本过高。柯达公司的工程师Bryce Bayer ，也就是拜耳阵列的发明人，想到了一种解决方案，就是Bayer pattern。</p></li></ul><h2 id="1-关于bayer图像格式"><a href="#1-关于bayer图像格式" class="headerlink" title="1. 关于bayer图像格式"></a>1. 关于bayer图像格式</h2><ul><li>bayer 是相机内部的原始图片, 一般后缀名为 <code>raw</code>。一般需要转换为其他格式才方便查看与存储。但不同厂商的摄像头出来的 bayer 也有一些差别，主要表现在 RGB 颜色值的排列顺序上的不同。需要注意的是，我们常说的 RGB图, 即为三色图, 一个像素点就由RGB三种颜色构成的混合色, 而bayer图一个像素就只有一个颜色, 或R或G或B. 因为bayer一个像素点只有一种颜色, 需要借助这个像素点周围的颜色对它进行插值(填充)另外的两种颜色, 它本身的颜色就不用插了. 绿色占像素总数的一半，而红色和蓝色占总数的四分之一，因此也称做<code>BGGR</code>, <code>RGBG</code>, <code>GRBG</code>, <code>RGGB</code>。</li></ul><ul><li><p>数据排列格式有四种如下表：</p><p><img src="/post/f067/image-20210601230949424.png" alt="image-20210601230949424"></p></li></ul><h2 id="2-RAW数据格式"><a href="#2-RAW数据格式" class="headerlink" title="2. RAW数据格式"></a>2. RAW数据格式</h2><ul><li><p>raw格式是<code>sensor</code>的输出格式，是未经处理过的数据.</p></li><li><p>raw数据在输出的时候是有一定的顺序的，一般为以下四种:</p><ul><li>GR/BG</li><li>RG/GB</li><li>BG/GR</li><li>GB/RG</li></ul></li><li><p>raw数据几种常用的格式</p><ul><li><p><strong>raw8</strong></p><p>raw8即是用8bits表示 <code>G/R/B/G</code> 中的一个分量，而不是使用8bits表示 <code>RG/GB</code> 四个分量。在sensor中，为了降低功耗，使用一个晶体来表示一种颜色，然后利用差值计算出相邻像素的值。</p></li><li><p><strong>raw10</strong></p><p>raw10就是使用 10bit 表示上述的一个 <code>G/R/B/G</code>，但是数据中是16bit的，高6位没用。</p></li><li><p><strong>raw12</strong></p><p>raw12就是使用 12bit 表示上述的一个 <code>G/R/B/G</code>，但是数据中是16bit的，高4位没用。</p></li></ul></li></ul><h2 id="3-bayer2rgb工具"><a href="#3-bayer2rgb工具" class="headerlink" title="3. bayer2rgb工具"></a>3. bayer2rgb工具</h2><blockquote><p>bayer2rgb工具用于将摄像头采集的 RAW 图片转换为 tiff 格式后，可以在window或者ubuntu下使用图片查看器来打开。</p></blockquote><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><ul><li><p>克隆bayer2rgb项目（项目地址：<a href="https://github.com/jdthomas/bayer2rgb%EF%BC%89">https://github.com/jdthomas/bayer2rgb）</a></p><p>git clone <a href="https://github.com/jdthomas/bayer2rgb.git">https://github.com/jdthomas/bayer2rgb.git</a></p></li><li><p>编译</p><p>make</p><p><img src="/post/f067/image-20210601161503847.png" alt="image-20210601161503847"></p></li></ul><h3 id="3-2-bayer2rgb使用"><a href="#3-2-bayer2rgb使用" class="headerlink" title="3.2 bayer2rgb使用"></a>3.2 bayer2rgb使用</h3><ul><li><p>将生成的raw图像转换为RGB图像</p><p>./bayer2rgb -i ./test.raw -o ./test.tiff -w 1920 -v 1080 -b 8 -f BGGR -t</p><p><img src="/post/f067/image-20210601161958624.png" alt="image-20210601161958624"></p><p>参数说明：</p><p>-i： RAW图像文件</p><p>-o：输出rgb图像文件名</p><p>-w：图像分辨率(宽)</p><p>-v：图像分辨率(高)</p><p>-b：像素位数</p><p>-f：RAW图像格式</p><p>-t：给生成的tiff文件添加头信息(<code>如果不加上这个参数，则生成的图像只有数据信息，没有文件头信息，图片查看软件无法获知其对应格式，直接打开会提示无效图片</code>)</p></li></ul><p>参考：</p><p><a href="https://www.cnblogs.com/linhaostudy/p/11225815.html">https://www.cnblogs.com/linhaostudy/p/11225815.html</a></p><p><a href="https://blog.csdn.net/qq_29575685/article/details/103954096">https://blog.csdn.net/qq_29575685/article/details/103954096</a></p><p><a href="https://blog.csdn.net/hou5233/article/details/108595743">https://blog.csdn.net/hou5233/article/details/108595743</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/12/bayer_filter.html">http://www.ruanyifeng.com/blog/2012/12/bayer_filter.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>戴尔服务器添加硬盘</title>
      <link href="post/cc06.html"/>
      <url>post/cc06.html</url>
      
        <content type="html"><![CDATA[<p>​        给<code>戴尔服务器R330</code>添加<code>12TB</code>硬盘。该服务器有4个盘位。</p><h2 id="1-添加硬盘流程"><a href="#1-添加硬盘流程" class="headerlink" title="1. 添加硬盘流程"></a>1. 添加硬盘流程</h2><h3 id="1-1-服务器关机并打开服务器后盖"><a href="#1-1-服务器关机并打开服务器后盖" class="headerlink" title="1.1 服务器关机并打开服务器后盖"></a>1.1 服务器关机并打开服务器后盖</h3><p><img src="/post/cc06/image-20210514142830314.png" alt="image-20210514142830314"></p><p><img src="/post/cc06/image-20210514142931891.png" alt="image-20210514142931891"></p><p>硬盘装好后，接上线。如下图：</p><p><img src="/post/cc06/image-20210514143235080.png" alt="image-20210514143235080"></p><h3 id="1-2-开机配置阵列"><a href="#1-2-开机配置阵列" class="headerlink" title="1.2 开机配置阵列"></a>1.2 开机配置阵列</h3><p>在开机过程中，看到有 <code>ctrl + r</code>  的提示，然后按<code>ctrl + r</code>，进入阵列卡配置界面，如下：</p><p><img src="/post/cc06/image-20210514143537833.png" alt="image-20210514143537833"></p><p>现在这块硬盘的状态是<code>NON-RAid</code>， 在系统里面可以是直接识别到的，如果做<code>RAID 0</code> 也是可以的。</p><p><img src="/post/cc06/image-20210514143615279.png" alt="image-20210514143615279"></p><p>下面将进行做<code>RAID0</code></p><p><img src="/post/cc06/image-20210514144050384.png" alt="image-20210514144050384"></p><p><img src="/post/cc06/image-20210514144131646.png" alt="image-20210514144131646"></p><p><img src="/post/cc06/image-20210514144515786.png" alt="image-20210514144515786"></p><p><img src="/post/cc06/image-20210514144610133.png" alt="image-20210514144610133"></p><p><img src="/post/cc06/image-20210514144714565.png" alt="image-20210514144714565"></p><p><img src="/post/cc06/image-20210514144822926.png" alt="image-20210514144822926"></p><p><img src="/post/cc06/image-20210514144930586.png" alt="image-20210514144930586"></p><p><img src="/post/cc06/image-20210514144955692.png" alt="image-20210514144955692"></p><p><img src="/post/cc06/image-20210514145026564.png" alt="image-20210514145026564"></p><p><img src="/post/cc06/image-20210514145059367.png" alt="image-20210514145059367"></p><p><img src="/post/cc06/image-20210514145117328.png" alt="image-20210514145117328"></p><p>到此已完成给添加的硬盘做<code>RAID0</code>，如下图</p><p><img src="/post/cc06/image-20210514145220417.png" alt="image-20210514145220417"></p><h3 id="1-3-重启机器，进入系统后在新添加的硬盘新建卷"><a href="#1-3-重启机器，进入系统后在新添加的硬盘新建卷" class="headerlink" title="1.3 重启机器，进入系统后在新添加的硬盘新建卷"></a>1.3 重启机器，进入系统后在新添加的硬盘<code>新建卷</code></h3><p><img src="/post/cc06/image-20210514145344393.png" alt="image-20210514145344393"></p><p><img src="/post/cc06/image-20210514145427221.png" alt="image-20210514145427221"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式gdb调试</title>
      <link href="post/c850.html"/>
      <url>post/c850.html</url>
      
        <content type="html"><![CDATA[<p>​        gdb 工具是 GNU 项目调试器，基于命令行。和其他的调试器一样，我们可以使用 gdb 来一行行的运行程序、单步执行、跳入/跳出函数、设置断点、查看变量等等，它是 UNIX/LINUX 操作系统下强大的程序调试工具。 gdb 支持多种语言，包括 Ada、汇编、 C/C++、 D、 Fortran、 GO、Objective-C、 OpenCL、 Modula-2、 Pascal 和 Rust。</p><p>gdb官网：<a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></p><h2 id="1-gdb和gdbserver"><a href="#1-gdb和gdbserver" class="headerlink" title="1. gdb和gdbserver"></a>1. gdb和gdbserver</h2><ul><li><p>一般交叉编译已经自带了 <code>gdb</code> 和 <code>gdbserver</code>，因此可以不用移植，直接使用交叉编译器自带的即可。如下图</p><p><img src="/post/c850/image-20210509223545066.png" alt="image-20210509223545066"></p><p>只需要将 <code>gdbserver</code> 拷贝到开发板根文件系统下即可</p></li></ul><h2 id="2-编写一个测试应用"><a href="#2-编写一个测试应用" class="headerlink" title="2. 编写一个测试应用"></a>2. 编写一个测试应用</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"runing times:%d\r\n"</span><span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>        times<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">arm-linux-gnueabihf-gcc -g main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编译的时候必须加上 <code>-g</code> 选项，这样编译出来的可执行文件才带有调试信息</p></blockquote></li></ul><h2 id="3-使用gdb调试程序"><a href="#3-使用gdb调试程序" class="headerlink" title="3. 使用gdb调试程序"></a>3. 使用gdb调试程序</h2><ul><li><p>开发板启动gdbserver </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdbserver 192.168.5.107:1234 a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/c850/image-20210509224453645.png" alt="image-20210509224453645"></p><blockquote><p>上述命令中 <code>192.168.5.107</code> 为ubuntu的 IP 地址，， <code>1234</code>是端口号，可以任意给一个端口号， <code>a.out</code>是要调试的可执行文件。</p></blockquote></li><li><p>在 ubuntu 中输入以下命令启动 gdb 调试工具</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">arm-linux-gnueabihf-gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/c850/image-20210509224755653.png" alt="image-20210509224755653"></p></li><li><p>输入如下命令连接到开发板</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">target remote 192.168.5.105:1234<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>上述命令表示连接到开发板上，其中 <code>192.168.5.105</code> 就是开发板 IP 地址， <code>1234</code> 就是开发板 <code>gdbserver</code> 设置的端口号</p></blockquote><p><img src="/post/c850/image-20210509225212458.png" alt="image-20210509225212458"></p><p>连接成功以后开发板中的 <code>gdbserver</code> 就会提示连接信息，如下图：</p><p><img src="/post/c850/image-20210509225619777.png" alt="image-20210509225619777"></p><blockquote><p>连接成功以后就可以在 <code>ubuntu</code> 上进行代码调试了</p></blockquote></li></ul><h2 id="4-VScode-gdbserver-图形化调试"><a href="#4-VScode-gdbserver-图形化调试" class="headerlink" title="4. VScode+gdbserver 图形化调试"></a>4. VScode+gdbserver 图形化调试</h2><h3 id="4-1-VSCode-设置"><a href="#4-1-VSCode-设置" class="headerlink" title="4.1 VSCode 设置"></a>4.1 VSCode 设置</h3><ul><li><p>给 VScode 安装远程调试插件<code>Remote Development</code>，点击<code>运行和调试</code>，然后选择 <code>C++(GDB/LLDB)</code> 选项，如下图：</p><p><img src="/post/c850/image-20210509234726012.png" alt="image-20210509234726012"></p><p><img src="/post/c850/image-20210509235227757.png" alt="image-20210509235227757"></p><p>选择<code>默认配置</code>后，会在当前文件夹新建一个名为 <code>launch.json</code> 的文件，此文件会存放在 <code>.vscode</code> 目录下，如下图：</p><p><img src="/post/c850/image-20210509235419305.png" alt="image-20210509235419305"></p><p><code>launch.json</code> 文件默认的内容如下所示</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="token comment">// 悬停以查看现有属性的描述。</span>    <span class="token comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"(gdb) 启动"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"输入程序名称，例如 $&#123;workspaceFolder&#125;/a.out"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"为 gdb 启用整齐打印"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>launch.json</code> 文件中有几个项目是需要我们根据实际情况配置的：</p><ul><li><strong>name</strong>：调试的项目名</li><li><strong>program</strong>：需要调试的应用程序可执行文件路径。</li><li><strong>cwd</strong>：需要调试的应用程序源码路径。</li><li><strong>miDebuggerPath</strong>：此项需要手动添加，用于指定所使用的交叉编译器 gdb 路径。</li><li><strong>miDebuggerServerAddress</strong>：此项需要手动添加，远程 gdbserver 服务器地址。  </li></ul></li><li><p>修改完成以后的 <code>launch.json</code> 文件内容如下所示 </p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token comment">// 使用 IntelliSense 了解相关属性。 </span>    <span class="token comment">// 悬停以查看现有属性的描述。</span>    <span class="token comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"a.out"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/a.out"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token property">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"为 gdb 启用整齐打印"</span><span class="token punctuation">,</span>                    <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token property">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"miDebuggerPath"</span><span class="token operator">:</span> <span class="token string">"/home/llr/work/am335x/sdk/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gdb"</span><span class="token punctuation">,</span>            <span class="token property">"miDebuggerServerAddress"</span><span class="token operator">:</span> <span class="token string">"192.168.5.105:1234"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-VScode-调试方法"><a href="#4-2-VScode-调试方法" class="headerlink" title="4.2 VScode 调试方法"></a>4.2 VScode 调试方法</h3><h4 id="4-2-1-启动调试"><a href="#4-2-1-启动调试" class="headerlink" title="4.2.1 启动调试"></a>4.2.1 启动调试</h4><ul><li><p>VSCode 设置好以后就可以进行调试了，首先要启动开发板上的 gdbserver，输入如下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdbserver 192.168.5.107:1234 a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>接下来再点击 VSCode 上的<code>开始调试</code>按钮 </p><p><img src="/post/c850/image-20210510000633382.png" alt="image-20210510000633382"></p><p>由于是通过网络进行调试的，因此启动调试以后会有一个建立连接的过程，可能需要几秒钟，建立成功以后如下图： </p><p><img src="/post/c850/image-20210510000921913.png" alt="image-20210510000921913"></p><p>下图为vscode调试面板</p><p><img src="/post/c850/image-20210510001038179.png" alt="image-20210510001038179"></p><p>一共有 6 个控制按钮，这 6 个按钮从左往右功能及快捷键依次如下</p><ul><li>继续按钮，快捷键为 F5，用于控制程序的运行和暂停，程序运行到断点暂停以后可以按下此按钮继续运行</li><li>单步跳过按钮，快捷键为 F10</li><li>单步调试按钮，快捷键为 F11</li><li>单步跳出按钮，快捷键为 Shift+F11</li><li>重启按钮，快捷键为 Ctrl+Shift+F5</li><li>停止按钮，快捷键为 Shift+F5</li></ul></li></ul><h4 id="4-2-2-添加断点"><a href="#4-2-2-添加断点" class="headerlink" title="4.2.2 添加断点"></a>4.2.2 添加断点</h4><ul><li><p>在需要添加断点的行前面，直接点击即可添加或取消断点，点添加成功以后会在所在行前面显示一个小红点，如下图</p><p><img src="/post/c850/image-20210510001540706.png" alt="image-20210510001540706"></p></li></ul><h4 id="4-2-3-添加监视"><a href="#4-2-3-添加监视" class="headerlink" title="4.2.3 添加监视"></a>4.2.3 添加监视</h4><ul><li><p>如果需要监视一个变量的变化，鼠标双击选中需要监视的变量名上，然后点击鼠标右键，选择“添加到监视”，如下图</p><p><img src="/post/c850/image-20210510001850839.png" alt="image-20210510001850839"></p><p>添加成功以后我们就可以在左侧的 <code>监视</code> 窗口看到刚刚添加的变量，如下图</p><p><img src="/post/c850/image-20210510002001200.png" alt="image-20210510002001200"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb使用</title>
      <link href="post/4d4b.html"/>
      <url>post/4d4b.html</url>
      
        <content type="html"><![CDATA[<p>​        gdb 工具是 GNU 项目调试器，基于命令行。和其他的调试器一样，我们可以使用 gdb 来一行行的运行程序、单步执行、跳入/跳出函数、设置断点、查看变量等等，它是 UNIX/LINUX 操作系统下强大的程序调试工具。 gdb 支持多种语言，包括 Ada、汇编、 C/C++、 D、 Fortran、 GO、Objective-C、 OpenCL、 Modula-2、 Pascal 和 Rust。</p><p>gdb官网：<a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></p><h2 id="1-gdb基本命令"><a href="#1-gdb基本命令" class="headerlink" title="1. gdb基本命令"></a>1. gdb基本命令</h2><ul><li><p>测试代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"show\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"arr[%d]: %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc **-g** main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编译的时候必须加上 <code>&quot;-g&quot;</code> 选项，这样编译出来的可执行文件才带有调试信息</p></blockquote></li><li><p>使用gdb调试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gdb a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4d4b/image-20210509184628858.png" alt="image-20210509184628858"></p></li></ul><h3 id="1-2-run命令"><a href="#1-2-run命令" class="headerlink" title="1.2 run命令"></a>1.2 run命令</h3><ul><li><p>用于启动程序，简写：<code>r</code></p><p><img src="/post/4d4b/image-20210509184726139.png" alt="image-20210509184726139"></p></li></ul><h3 id="1-3-quit命令"><a href="#1-3-quit命令" class="headerlink" title="1.3 quit命令"></a>1.3 quit命令</h3><ul><li>退出gdb模式，简写：<code>q</code></li></ul><h3 id="1-4-break命令"><a href="#1-4-break命令" class="headerlink" title="1.4 break命令"></a>1.4 break命令</h3><ul><li><p>设置断点，简写：<code>b</code></p><p><img src="/post/4d4b/image-20210509185748811.png" alt="image-20210509185748811"></p></li></ul><h3 id="1-5-info命令"><a href="#1-5-info命令" class="headerlink" title="1.5 info命令"></a>1.5 info命令</h3><ul><li>用于显示有关正在调试的程序的内容的通用命令</li></ul><h4 id="1-5-1-info-breakpoints-b"><a href="#1-5-1-info-breakpoints-b" class="headerlink" title="1.5.1 info breakpoints(b)"></a>1.5.1 info breakpoints(<code>b</code>)</h4><ul><li><p>显示断点的状态</p><p><img src="/post/4d4b/image-20210509190348243.png" alt="image-20210509190348243"></p></li></ul><h3 id="1-6-list命令"><a href="#1-6-list命令" class="headerlink" title="1.6 list命令"></a>1.6 list命令</h3><ul><li><p>​    用于列出源码，简写：<code>l</code></p><p><img src="/post/4d4b/image-20210509190745817.png" alt="image-20210509190745817"></p></li></ul><h3 id="1-7-print命令"><a href="#1-7-print命令" class="headerlink" title="1.7 print命令"></a>1.7 print命令</h3><ul><li>用于打印变量或者变量地址，简写：<code>p</code></li></ul><h3 id="1-8-step命令"><a href="#1-8-step命令" class="headerlink" title="1.8 step命令"></a>1.8 step命令</h3><ul><li>单步调试，此命令会进入到函数里面调试</li></ul><h3 id="1-9-next命令"><a href="#1-9-next命令" class="headerlink" title="1.9 next命令"></a>1.9 next命令</h3><ul><li>单步调试，此命令<code>不会</code>进入到函数里面调试</li></ul><h3 id="1-10-shell命令"><a href="#1-10-shell命令" class="headerlink" title="1.10 shell命令"></a>1.10 shell命令</h3><ul><li><p>用于执行shell命令</p><p><img src="/post/4d4b/image-20210509192722613.png" alt="image-20210509192722613"></p></li></ul><h3 id="1-10-watchpoint命令"><a href="#1-10-watchpoint命令" class="headerlink" title="1.10 watchpoint命令"></a>1.10 watchpoint命令</h3><ul><li>用于观察变量是否变化</li></ul><h2 id="2-gdb技巧"><a href="#2-gdb技巧" class="headerlink" title="2. gdb技巧"></a>2. gdb技巧</h2><h3 id="2-1-日志功能"><a href="#2-1-日志功能" class="headerlink" title="2.1 日志功能"></a>2.1 日志功能</h3><ul><li><p>用于记录在gdb调试的日志，执行以下指令开启日志功能</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">set logging on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/4d4b/image-20210509193316534.png" alt="image-20210509193316534"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux调试技术</title>
      <link href="post/21b4.html"/>
      <url>post/21b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Coredump调试"><a href="#1-Coredump调试" class="headerlink" title="1. Coredump调试"></a>1. Coredump调试</h2><blockquote><p>Coredump中文翻译核心转储，核心（Core）指的是内存映像，当进程发生错误时，系统会把核心映像写入一个文件(Core文件)，我们称为核心转储（Coredump）。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">/* 内存越界,不一定会引发coredump，只有越界的地址是非法地址的时候才会出现 */</span><span class="token keyword">int</span> <span class="token function">coredump_test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0123456789abcdefg"</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 不会引发coredump */</span>    buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 会引发coredump */</span>    buf<span class="token punctuation">[</span><span class="token number">100000000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>     <span class="token comment">/* 不会引发coredump */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof buf: %ld, sizeof str: %ld\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"buf => %s\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 非法地址 */</span><span class="token keyword">int</span> <span class="token function">coredump_test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 空指针 */</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 没有访问权限的地址 */</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x123456</span><span class="token punctuation">;</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 重复释放 */</span><span class="token keyword">int</span> <span class="token function">coredump_test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 重复释放会触发coredump */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 正确释放操作 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 栈溢出 */</span><span class="token keyword">int</span> <span class="token function">coredump_test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 正常 */</span>    <span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 栈溢出，会引发coredump */</span>    <span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 无限递归调用，栈溢出, 引发coredump */</span><span class="token keyword">int</span> <span class="token function">coredump_test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">coredump_test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 除0错误 */</span><span class="token keyword">int</span> <span class="token function">coredump_test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> den <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> num <span class="token operator">/</span> den<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//coredump_test1();</span>    <span class="token comment">//coredump_test2();</span>    <span class="token comment">//coredump_test3();</span>    <span class="token comment">//coredump_test4();</span>    <span class="token comment">//coredump_test5();</span>    <span class="token function">coredump_test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><p>gcc -g coredump.c</p></li><li><p>运行</p><p><img src="/post/21b4/image-20210507234631788.png" alt="image-20210507234631788"></p></li><li><p>使用gdb调试<code>core</code></p><p>gdb <code>可执行文件</code> <code>core文件</code></p><p><img src="/post/21b4/image-20210507235042047.png" alt="image-20210507235042047"></p></li></ul><h2 id="2-内存错误调试"><a href="#2-内存错误调试" class="headerlink" title="2. 内存错误调试"></a>2. 内存错误调试</h2><h3 id="2-1-Valgrind"><a href="#2-1-Valgrind" class="headerlink" title="2.1  Valgrind"></a>2.1  Valgrind</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token comment">/* 非法读写 */</span><span class="token keyword">int</span> <span class="token function">memory_error1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token comment">/* 非法读 */</span>    <span class="token keyword">char</span> num <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 非法写 */</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">120</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 使用未初始化的值 */</span><span class="token keyword">int</span> <span class="token function">memory_error2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value = %d\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 系统调用时使用未初始化的值或者地址 */</span><span class="token keyword">int</span> <span class="token function">memory_error3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 非法释放 */</span><span class="token keyword">int</span> <span class="token function">memory_error4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 不匹配的释放 */</span><span class="token keyword">int</span> <span class="token function">memory_error5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>    <span class="token comment">/* 不匹配的释放 */</span>    delete p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 参数不合法 */</span><span class="token keyword">int</span> <span class="token function">memory_error6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>           <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 源地址和目标地址重叠 */</span><span class="token keyword">int</span> <span class="token function">memory_error7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefghijk"</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before src: %s\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>src <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after src: %s\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 内存泄露 */</span><span class="token keyword">int</span> <span class="token function">memory_error8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--- %s test ---\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//memory_error1();</span>    <span class="token comment">//memory_error2();</span>    <span class="token comment">//memory_error3();</span>    <span class="token comment">//memory_error4();</span>    <span class="token comment">//memory_error5();</span>        <span class="token comment">//memory_error6();</span>    <span class="token comment">//memory_error7();</span>    <span class="token function">memory_error8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编译</p><p>g++ -g memory_valgrind.cpp</p></li><li><p>使用Valgrind运行程序</p><p><img src="/post/21b4/image-20210508223447727.png" alt="image-20210508223447727"></p></li></ul><h3 id="2-2-Asan"><a href="#2-2-Asan" class="headerlink" title="2.2 Asan"></a>2.2 Asan</h3><h2 id="3-CPU占用过高调试-多线程"><a href="#3-CPU占用过高调试-多线程" class="headerlink" title="3. CPU占用过高调试 (多线程)"></a>3. CPU占用过高调试 (<code>多线程</code>)</h2><ol><li>打印每个线程的线程id</li><li><code>top -H -p 主线程id</code>，显示每个线程占用cpu的情况</li><li>通过strace命令查看线程<code>系统调用</code>情况</li><li>通过显示信息和打印信息找到出问题的线程</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> coredump </tag>
            
            <tag> 内存错误 </tag>
            
            <tag> cpu错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核-驱动的一些命令</title>
      <link href="post/72e4.html"/>
      <url>post/72e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><h3 id="1-2-linux系统中查看设备树"><a href="#1-2-linux系统中查看设备树" class="headerlink" title="1.2 linux系统中查看设备树"></a>1.2 linux系统中查看设备树</h3><blockquote><p>以目录的形式体现设备树结构</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls &#x2F;sys&#x2F;firmware&#x2F;devicetree&#x2F;base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls &#x2F;proc&#x2F;device-tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-linux系统查看中断信息"><a href="#1-3-linux系统查看中断信息" class="headerlink" title="1.3 linux系统查看中断信息"></a>1.3 linux系统查看中断信息</h3><pre class="line-numbers language-she" data-language="she"><code class="language-she">cat &#x2F;proc&#x2F;interrupts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emmc节点挂载问题调试</title>
      <link href="post/7e72.html"/>
      <url>post/7e72.html</url>
      
        <content type="html"><![CDATA[<p>​        在zynq平台中出现使用<code>spi+emmc</code>方式启动，sd卡分区会覆盖emmc的分区</p><h2 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h2><ul><li><p>调试过程中发现有以下两种异常情况</p><p><img src="/post/7e72/image-20210427172723421.png" alt="image-20210427172723421"></p><blockquote><p>异常分别为：<code>EMMC分区没有正常挂载</code>和<code>EMMC、sd卡两个设备只有部分分区被挂载</code></p></blockquote></li></ul><h2 id="2-调试"><a href="#2-调试" class="headerlink" title="2. 调试"></a>2. 调试</h2><ul><li><p>从SPI启动，并插入sd卡，如下图</p><p><img src="/post/7e72/image-20210428101449869.png" alt="image-20210428101449869"></p><blockquote><p>EMMC和sd卡只有部分分区被挂载，并且<code>/run/media/mmcblk1p3</code>目录下的文件是<code>sd卡的p3分区</code>的文件，即emmc的分区被sd卡分区覆盖了</p></blockquote></li></ul><h3 id="2-1-修改udev用于挂载块设备的脚本"><a href="#2-1-修改udev用于挂载块设备的脚本" class="headerlink" title="2.1 修改udev用于挂载块设备的脚本"></a>2.1 修改udev用于挂载块设备的脚本</h3><ul><li><blockquote><p>这个修改，用于确认udev有没有接收到从内核发送来的关于emmc和sd卡所有分区的netlink消息</p></blockquote></li><li><p>修改<code>/etc/udev/scripts/mount.sh</code></p><p><img src="/post/7e72/image-20210427173703255.png" alt="image-20210427173703255"></p><p>执行以下命令使内核触发设备事件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm trigger --subsystem-match&#x3D;block --action&#x3D;add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/7e72/image-20210428105235593.png" alt="image-20210428105235593"></p><blockquote><p>通过结果来看，udev能正常接收到内核触发EMMC和sd卡设备每个分区的事件，由此可得出udev挂载这个环节是正常的</p></blockquote><p>通过<code>df -a</code>命令查看</p><p><img src="/post/7e72/image-20210428111422210.png" alt="image-20210428111422210"></p><blockquote><p>以上两个分区的信息异常，具体原因未知</p></blockquote></li></ul><h3 id="2-2-分析udev自启动脚本"><a href="#2-2-分析udev自启动脚本" class="headerlink" title="2.2 分析udev自启动脚本"></a>2.2 分析udev自启动脚本</h3><ol><li><p>通过分析udev启动脚本发现，udev在启动过程中，会<code>检查有没有cache</code>，如果有则解压cache tar包到<code>/</code>目录下</p><p><img src="/post/7e72/image-20210428120542010.png" alt="image-20210428120542010"></p><p>udev-cache.tar.gz包包含文件系统/dev目录下的设备节点文件，如下</p><p><img src="/post/7e72/image-20210428142554240.png" alt="image-20210428142554240"></p></li><li><p>udev-cache.tar.gz包由udev-cache服务生成，如下为udev-cache脚本</p><p><img src="/post/7e72/image-20210428143205989.png" alt="image-20210428143205989"></p><p>有关udev cache的作用，查看以下链接：</p><p><a href="https://elinux.org/Caching_of_information_on_udev">https://elinux.org/Caching_of_information_on_udev</a></p></li><li><p>尝试删除<code>udev-cache.tar.gz</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm &#x2F;etc&#x2F;udev-cache.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除后，reboot。发现eMMc和sd卡分区挂载正常（<code>各分区的文件显示正常</code>），如下图</p><p><img src="/post/7e72/image-20210428143931299.png" alt="image-20210428143931299"></p></li><li><p>结论</p><blockquote><p><strong>emmc节点挂载问题和udev cahce有关</strong></p></blockquote></li></ol><h3 id="2-3-排查udev-cache"><a href="#2-3-排查udev-cache" class="headerlink" title="2.3  排查udev cache"></a>2.3  排查udev cache</h3><ul><li><blockquote><p>排查udev cache影响emmc分区挂载的原因</p></blockquote></li></ul><ol><li><p>分析emmc和sd卡设备分区的<code>主次设备号</code>，<code>正常情况下</code>主次设备号如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;dev&#x2F;mmcblk0p1  主设备号179  次设备号1&#x2F;dev&#x2F;mmcblk0p2  主设备号179  次设备号2&#x2F;dev&#x2F;mmcblk0p3  主设备号179  次设备号3&#x2F;dev&#x2F;mmcblk1p1  主设备号179  次设备号9&#x2F;dev&#x2F;mmcblk1p2  主设备号179  次设备号10&#x2F;dev&#x2F;mmcblk1p3  主设备号179  次设备号11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/post/7e72/image-20210428151638109.png" alt="image-20210428151638109"></p></li><li><p>从SPI启动，不插sd卡，<code>正常情况</code>eMMC的主次设备如下：</p><p><img src="/post/7e72/image-20210428153035929.png" alt="image-20210428153035929"></p></li><li><p>从SPI启动，插入sd卡。<code>异常情况</code>下eMMC和sd卡的主次设备</p><p><img src="/post/7e72/image-20210428153804595.png" alt="image-20210428153804595"></p><blockquote><p>sd和emmc的主次设备号一样，从而导致emmc节点挂载异常</p></blockquote></li></ol><h2 id="3-分析udev生成cache和使用cache"><a href="#3-分析udev生成cache和使用cache" class="headerlink" title="3. 分析udev生成cache和使用cache"></a>3. 分析udev生成cache和使用cache</h2><ol><li>在烧写eMMC后，拔了sd卡，然后从<code>SPI+eMMC</code>启动</li><li>第一次启动udev-cache服务会在<code>/etc</code>目录下生成<code>udev-cache.tar.gz</code>（已经将eMMC节点和主次设备号保存了下来。分别为<code>179,1</code>、<code>179, 2</code>、<code>179,3</code>）</li><li>第二次从<code>SPI+eMMC</code>启动(<code>插上sd卡</code>)，udev在启动过程中发现有<code>udev-cache.tar.gz</code>，将会解压这个tar到<code>/dev</code>目录下进行覆盖。导致eMMC节点的主次设备号从<code>179,9</code>、<code>179,10</code>、<code>179,11</code>变为了<code>179,1</code>、<code>179, 2</code>、<code>179,3</code>。和sd卡一样的设备号。</li></ol><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><ul><li>文件系统关闭自启动udev-cache服务，不生成udev-cache.tar.gz。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> udev </tag>
            
            <tag> 问题记录 </tag>
            
            <tag> emmc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序在系统获取ip后再启动</title>
      <link href="post/b08.html"/>
      <url>post/b08.html</url>
      
        <content type="html"><![CDATA[<p>基于IMX8（<code>systemd</code>）板卡，让系统获取ip并且可以对外通信后，再启动应用程序。</p><h2 id="1-systemd-networkd-wait-online服务简介"><a href="#1-systemd-networkd-wait-online服务简介" class="headerlink" title="1. systemd-networkd-wait-online服务简介"></a>1. systemd-networkd-wait-online服务简介</h2><ul><li><p><code>systemd-networkd-wait-online</code> 是一个 一次性系统服务，用于等待网络连线成功(可以对外通信)。 默认情况下，它会一直等待到 所有被其监视且由 <code>systemd-networkd.service</code>管理的网络接口连线成功或者超时失败，并且至少有一个连接 可以对外通信。</p><blockquote><p>systemd-networkd-wait-online服务会等待网络是否连接成功，如果网络没有连接成功，该服务会一直阻塞，而其他指定了在systemd-networkd-wait-online服务之后才运行的服务，都不会运行。在由此可编写应用程序的自启动服务，让该服务在systemd-networkd-wait-online服务后才运行即可</p></blockquote></li><li><p>由于systemd-networkd-wait-online服务会等待板卡所有的网口都正常连接成功后，才继续执行其他任务。如需等待某一个网口是否连接成功。可修改<code>/lib/systemd/system/systemd-networkd-wait-online.service</code>文件，如下指定等待<code>eth0网口</code>连接成功即可</p><p><img src="/post/b08/image-20210421095349245.png" alt="image-20210421095349245"></p></li></ul><h2 id="2-编写应用程序自启动服务-service"><a href="#2-编写应用程序自启动服务-service" class="headerlink" title="2. 编写应用程序自启动服务(.service)"></a>2. 编写应用程序自启动服务(.service)</h2><ul><li><p>新建helloworld.service文件，内容如下：</p><pre class="line-numbers language-code" data-language="code"><code class="language-code">[Unit]Description&#x3D;HelloworldAfter&#x3D;basic.service systemd-networkd-wait-online.service[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;home&#x2F;root&#x2F;demo.shStandardOutput&#x3D;tty[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ExecStart： 指定要执行的程序</p><p>将该文件放置到文件系统的<code>/lib/systemd/system</code>目录下，执行以下命令配置该服务自启动</p><p>systemctl enable helloworld.service</p></blockquote><p><img src="/post/b08/image-20210421095010523.png" alt="image-20210421095010523"></p></li><li><p>在/home/root目录下新建demo.sh文件，<code>并且需要给可执行权限</code>，内容如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bashcurl www.baidu.com &gt; &#x2F;home&#x2F;root&#x2F;log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该脚本的功能是通过网络请求一个网址的内容然后保存到/home/root/log.txt</p></blockquote></li><li><p>需要确保在板卡上能ping通域名</p><p><img src="/post/b08/image-20210421100125694.png" alt="image-20210421100125694"></p><p>完成以上操作，重新板卡</p></li><li><p>重启板卡进入文件系统后，稍等一会，在/home/root目录下会生成log.txt文件</p><p><img src="/post/b08/image-20210421100424655.png" alt="image-20210421100424655"></p></li><li><p>查看log.txt内容</p><p><img src="/post/b08/image-20210421100455696.png" alt="image-20210421100455696"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> imx8 </tag>
            
            <tag> systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单PRU网口问题</title>
      <link href="post/cf24d8c6.html"/>
      <url>post/cf24d8c6.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题原因"><a href="#1-问题原因" class="headerlink" title="1. 问题原因"></a>1. 问题原因</h2><ul><li><p><code>drivers/net/ethernet/ti/prueth.c</code> 中 pru mii0和mii1 任一初始化失败，都会跳到<code>netdev_exit</code>异常退出，导致网络功能不正常。</p><p><img src="/post/cf24d8c6/image-20210409095030279.png" alt="image-20210409095030279"></p></li></ul><h2 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h2><ol><li>修改prueth.c，对pru mii0或pru mii1单独初始化。</li><li>移植SDK5.3的驱动，SDK5.3的驱动支持通过设备树单独配置pru mii0或pru mii1  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题记录 </tag>
            
            <tag> PRU </tag>
            
            <tag> 网口 </tag>
            
            <tag> am570x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加对挂载ntfs格式u盘的支持</title>
      <link href="post/37541.html"/>
      <url>post/37541.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>在<code>570x</code>板卡中接入<code>NTFS</code>格式的<code>U盘</code>能正常挂载。能够正常读取，但是无法对U盘进行写入操作。如下图：</p><p><img src="/post/37541/image-20210408142431733.png" alt="image-20210408142431733"></p><p><img src="/post/37541/image-20210408142456070.png" alt="image-20210408142456070"></p><blockquote><p>Linux内核目前只支持对微软NTFS文件系统的读取。 NTFS-3G 是微软 NTFS 文件系统的一个开源实现，同时支持读和写。NTFS-3G 开发者使用 FUSE 文件系统来辅助开发，同时对可移植性有益。</p></blockquote><p><code>NTFS-3G</code> 详细信息可查看以下链接：</p><p><a href="https://wiki.archlinux.org/index.php/NTFS-3G_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/index.php/NTFS-3G_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><p><a href="https://www.tuxera.com/company/open-source/">https://www.tuxera.com/company/open-source/</a></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><h3 id="2-1-Linux内核配置支持FUSE文件系统"><a href="#2-1-Linux内核配置支持FUSE文件系统" class="headerlink" title="2.1 Linux内核配置支持FUSE文件系统"></a>2.1 Linux内核配置支持<code>FUSE</code>文件系统</h3><ul><li><p><img src="/post/37541/image-20210408145146318.png" alt="image-20210408145146318"></p><p><img src="/post/37541/image-20210408145220270.png" alt="image-20210408145220270"></p><blockquote><p>配置完成后，重新编译内核。</p></blockquote><p>执行以下命令，查看内核是否已经支持<code>FUSE</code>文件系统</p><pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">cat &#x2F;proc&#x2F;filesystems<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/37541/image-20210408145652681.png" alt="image-20210408145652681"></p></li></ul><h3 id="2-2-移植NTFS-3G"><a href="#2-2-移植NTFS-3G" class="headerlink" title="2.2 移植NTFS-3G"></a>2.2 移植NTFS-3G</h3><ul><li><h4 id="使用yocto进行移植NTFS-3G"><a href="#使用yocto进行移植NTFS-3G" class="headerlink" title="使用yocto进行移植NTFS-3G"></a>使用yocto进行移植NTFS-3G</h4><blockquote><p>yocto中的bb文件是<code>ntfs-3g-ntfsprogs</code></p><p>ntfs-3g：NTFS- 3g是一个稳定的、功能齐全的、可读写的NTFS驱动程序</p><p>ntfsprogs：Ntfsprogs是一组用于管理NTFS分区并与之交互的实用程序。2011年，Ntfsprogs与NTFS-3G合并</p></blockquote><p>将构建好的<code>ipk包</code>拷贝到板卡进行安装</p><p><img src="/post/37541/image-20210408151631577.png" alt="image-20210408151631577"></p><p><img src="/post/37541/image-20210408151720791.png" alt="image-20210408151720791"></p></li></ul><h2 id="3-使用ntfs-3g命令对u盘进行挂载"><a href="#3-使用ntfs-3g命令对u盘进行挂载" class="headerlink" title="3. 使用ntfs-3g命令对u盘进行挂载"></a>3. 使用ntfs-3g命令对u盘进行挂载</h2><ul><li><pre><code class="shell">ntfs-3g /dev/sda1 /run/media/sda1</code></pre><blockquote><p>如果之前已经挂载，需要先卸载</p></blockquote><p><img src="/post/37541/image-20210408152029078.png" alt="image-20210408152029078"></p></li><li><p>测试创建文件、向文件写入内容正常</p><p><img src="/post/37541/image-20210408152202166.png" alt="image-20210408152202166"></p></li></ul><blockquote><p>挂载NTFS设备，除了可以需要使用ntfs-3g命令。也可以mount命令（<code>mount 命令默认会调用/sbin/mount.ntfs, /sbin/mount.ntfs被符号链接到mount.ntfs-3g， 而mount.ntfs-3g被符号链接到/usr/bin/ntfs-3g</code>）</p></blockquote><h2 id="4-配置自动挂载NTFS设备"><a href="#4-配置自动挂载NTFS设备" class="headerlink" title="4. 配置自动挂载NTFS设备"></a>4. 配置自动挂载NTFS设备</h2><blockquote><p>目前<code>手动挂载</code>能够正常挂载ntfs设备，并且读写正常。但是如果使用<code>udev动态挂载</code>的话。会出现以下问题</p></blockquote><p><img src="/post/37541/image-20210408182534179.png" alt="image-20210408182534179"></p><p><strong>问题原因查看以下链接：</strong></p><p><a href="https://fadeer.github.io/%E5%B7%A5%E4%BD%9C/2016/10/28/udev-vs-fuse.html">https://fadeer.github.io/%E5%B7%A5%E4%BD%9C/2016/10/28/udev-vs-fuse.html</a></p><blockquote><p>主要原因是因为使用udev（<code>systemd-udevd</code>）来实现挂载，会<code>kill</code>掉mount.ntfs进程，导致挂载失败。 </p></blockquote><h3 id="4-1-解决udev挂载ntfs设备失败问题"><a href="#4-1-解决udev挂载ntfs设备失败问题" class="headerlink" title="4.1 解决udev挂载ntfs设备失败问题"></a>4.1 解决udev挂载ntfs设备失败问题</h3><ul><li><p>将<code>mount.ntfs</code> 脱离cgroups</p><p>修改文件系统<code>/etc/udev/scripts/mount.sh</code>文件，添加以下内容：</p><p><img src="/post/37541/image-20210408183239192.png" alt="image-20210408183239192"></p></li></ul><blockquote><p>重启板卡，u盘自动挂载成功。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题记录 </tag>
            
            <tag> u盘 </tag>
            
            <tag> ntfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>udev</title>
      <link href="post/26097.html"/>
      <url>post/26097.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-udev工作流程"><a href="#1-udev工作流程" class="headerlink" title="1. udev工作流程"></a>1. udev工作流程</h2><ol><li><p>当内核检测到系统中出现了新设备后，内核会通过<code>netlink</code>套接字发送<code>uevent</code>。</p></li><li><p><code>udev</code>获取内核发送的信息，进行规则的匹配。匹配的事物包括<code>SUBSYSTEM</code>、<code>ACTION</code>、<code>atttribute</code>、<code>内核提供的名称</code>（通过KERNEL=指定）以及其他的环境变量。</p></li><li><p>用获得的设备名称和主次设备号在<code>/dev/</code>目录下创建设备文件；如果是设备移除，则将已经创建的<code>/dev</code>文件被删除。</p><p><img src="/post/26097/udev.png" alt="udev"></p></li></ol><blockquote><p>​        udev完全在用户态工作，利用设备加入或移除时内核所发送的热插拔事件（hotplug event）来工作。在热插拔时，设备的详细信息都会由内核输出到位于/sys的sysfs文件系统。udev的设备命名策略、权限控制和事件处理都是在用户态完成的，它利用sysfs中的信息来进行创建设备文件节点等工作。</p></blockquote><h2 id="2-设备热插拔与冷插拔"><a href="#2-设备热插拔与冷插拔" class="headerlink" title="2. 设备热插拔与冷插拔"></a>2. 设备热插拔与冷插拔</h2><h3 id="2-1-热插拔"><a href="#2-1-热插拔" class="headerlink" title="2.1 热插拔"></a>2.1 热插拔</h3><ul><li><p>系统启动后插入的设备成为热插拔，内核检测到插拔事件后通过netlink(socket) 发送给守护进程udevd。</p><p><img src="/post/26097/4de682f636804ba8450b497d59458e3f.png" alt="4de682f636804ba8450b497d59458e3f"></p><p><img src="/post/26097/9dcb57bcfee7b3a525965b68f344be66.png" alt="9dcb57bcfee7b3a525965b68f344be66"></p></li></ul><h3 id="2-2-冷插拔"><a href="#2-2-冷插拔" class="headerlink" title="2.2 冷插拔"></a>2.2 冷插拔</h3><ul><li><p>系统启动前插入的设备在系统启动时，内核为设备在/sys目录下创建uevent文件，并记录设备信息，当udevd启动后，去读取设备信息，创建设备文件。</p><blockquote><p>sysfs下的设备都存在uevent文件，向该文件写一个“add”,内核会重新发送netlink，之后udev就可以收到设备的详细信息了，从而创建/dev下对应的设备节点。</p></blockquote></li><li><p>在系统启动后使用以下命令创建冷插拔设备文件<code>( 为每个冷插拔设备产生热插拔uevent)</code></p><p>/sbin/udevadm trigger –action=addudev</p><p>会在根文件系统可用后向内核请求所有设备事件</p></li></ul><h2 id="3-udev规则"><a href="#3-udev规则" class="headerlink" title="3. udev规则"></a>3. udev规则</h2><h3 id="3-1-规则文件目录"><a href="#3-1-规则文件目录" class="headerlink" title="3.1 规则文件目录"></a>3.1 <strong>规则文件目录</strong></h3><ul><li><p>系统规则：/lib/udev/rules.d</p><p>运行时规则：/run/udev/rules.d</p><p>自定义规则：/etc/udev/rules.d</p><blockquote><p>udev会在以上目录匹配规则</p><ol><li>etc具有最高的优先级。(自定义规则文件可以添加这个目录下)</li><li>/run会优先于/lib目录同名的文件。(不建议修改该目录下的规则文件)</li></ol></blockquote></li></ul><h3 id="3-2-规则文件命名"><a href="#3-2-规则文件命名" class="headerlink" title="3.2 规则文件命名"></a>3.2 <strong>规则文件命名</strong></h3><ul><li><p>规则文件的文件名通常是两个数字开头，它表示系统应用该规则的顺序。</p><blockquote><p>数字越小，优先级越大</p></blockquote></li></ul><h3 id="3-3-规则操作符"><a href="#3-3-规则操作符" class="headerlink" title="3.3 规则操作符"></a>3.3 <strong>规则操作符</strong></h3><table><thead><tr><th align="center"><strong>操作符</strong></th><th align="center">匹配或赋值</th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">==</td><td align="center">匹配</td><td align="center">相等比较</td></tr><tr><td align="center">!=</td><td align="center">匹配</td><td align="center">不等比较</td></tr><tr><td align="center">=</td><td align="center">赋值</td><td align="center">分配一个特定的值给该键，他可以覆盖之前的赋值</td></tr><tr><td align="center">+=</td><td align="center">赋值</td><td align="center">追加特定的值给已经存在的键</td></tr><tr><td align="center">:=</td><td align="center">赋值</td><td align="center">分配一个特定的值给该键，后面的规则不可能覆盖它</td></tr></tbody></table><h3 id="3-4-规则匹配键"><a href="#3-4-规则匹配键" class="headerlink" title="3.4 规则匹配键"></a>3.4 <strong>规则匹配键</strong></h3><table><thead><tr><th align="center"><strong>匹配键</strong></th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">匹配事件设备名</td></tr><tr><td align="center">ACTION</td><td align="center">事件 (uevent) 的行为，例如：add( 添加设备 )、remove( 删除设备 )</td></tr><tr><td align="center">KERNEL</td><td align="center">在内核里看到的设备名字,比如sd*表示任意SCSI磁盘设备</td></tr><tr><td align="center">DEVPATH</td><td align="center">内核设备路径</td></tr><tr><td align="center">SUBSYSTEM</td><td align="center">子系统名字,例如：sda 的子系统为 block</td></tr><tr><td align="center">BUS</td><td align="center">总线的名字,比如IDE,USB</td></tr><tr><td align="center">DRIVER</td><td align="center">设备驱动的名字,比如ide-cdrom</td></tr><tr><td align="center">ID</td><td align="center">独立于内核名字的设备名字</td></tr><tr><td align="center">SYSFS{value}</td><td align="center">sysfs属性值</td></tr><tr><td align="center">ENV{key}</td><td align="center">环境变量</td></tr><tr><td align="center">PROGRAM</td><td align="center">可执行的外部程序,如果程序返回0值,该键则认为为真(true)</td></tr><tr><td align="center">RESULT</td><td align="center">上一个PROGRAM调用返回的标准输出</td></tr><tr><td align="center">SYMLINK</td><td align="center">为 /dev/下的设备文件产生符号链接.由于 udev 只能为某个设备产生一个设备文件,所以为了不覆盖系统默认的 udev 规则所产生的文件,推荐使用符号链接.</td></tr><tr><td align="center">OWNER</td><td align="center">设备文件的属组</td></tr><tr><td align="center">GROUP</td><td align="center">设备文件所在的组</td></tr><tr><td align="center">MODE</td><td align="center">设备文件的权限,采用8进制</td></tr><tr><td align="center">RUN</td><td align="center">执行的程序</td></tr></tbody></table><h3 id="3-5-udev一些特殊的值和替换值"><a href="#3-5-udev一些特殊的值和替换值" class="headerlink" title="3.5 udev一些特殊的值和替换值"></a>3.5 <strong>udev一些特殊的值和替换值</strong></h3><table><thead><tr><th align="center"><strong>特殊值</strong></th><th align="center">替换值</th><th align="center"><strong>作用</strong></th></tr></thead><tbody><tr><td align="center">$kernel</td><td align="center">%k</td><td align="center">设备的内核设备名称,例如：sda、cdrom</td></tr><tr><td align="center">$number</td><td align="center">%n</td><td align="center">设备的内核号码,例如：sda3 的内核号码是 3</td></tr><tr><td align="center">$devpath</td><td align="center">%p</td><td align="center">设备的 devpath路径</td></tr><tr><td align="center">$id</td><td align="center">%b</td><td align="center">设备在 devpath里的 ID 号</td></tr><tr><td align="center">$sysfs{file}</td><td align="center">%s{file}</td><td align="center">设备的sysfs里 file 的内容.其实就是设备的属性值</td></tr><tr><td align="center">$env{key}</td><td align="center">%E{key}</td><td align="center">一个环境变量的值</td></tr><tr><td align="center">$major</td><td align="center">%M</td><td align="center">主设备号</td></tr><tr><td align="center">$minor</td><td align="center">%m</td><td align="center">次设备号</td></tr><tr><td align="center">$result</td><td align="center">%c</td><td align="center">PROGRAM 返回的结果</td></tr><tr><td align="center">$parent</td><td align="center">%P</td><td align="center">父设备的设备文件名</td></tr><tr><td align="center">$root</td><td align="center">%r</td><td align="center">udev_root的值,默认是 /dev/</td></tr><tr><td align="center">$tempnode</td><td align="center">%N</td><td align="center">临时设备名</td></tr><tr><td align="center"></td><td align="center">%%</td><td align="center">符号 % 本身</td></tr><tr><td align="center"></td><td align="center">$$</td><td align="center">符号 $ 本身</td></tr></tbody></table><h2 id="4-udev配置文件"><a href="#4-udev配置文件" class="headerlink" title="4. udev配置文件"></a>4. udev配置文件</h2><ul><li><code>udev配置文件：/etc/udev/udev.conf</code></li><li><strong>udev_root：</strong>设备节点放置在文件系统中的位置。默认值为/dev/。</li><li><strong>udev_db：</strong>udev数据库的名称和位置。默认值为/dev/.udev.tdb。</li><li><strong>udev_rules：</strong>udev规则文件或目录的名称，以查找后缀为.rules的文件。所有规则文件均按词汇顺序读取。默认值为/etc/udev/rules.d/。</li><li><strong>udev_permissions：</strong>udev权限文件或目录的名称，以查找后缀为.permissions的文件。所有权限文件均按词汇顺序读取。默认值/etc/udev/permissions.d/</li><li><strong>udev_log：</strong>udev记录了有关所处理的每个设备的某些信息，则该开关。默认值为yes。</li><li><strong>default_mode：</strong>权限文件中未明确匹配的所有节点的默认模式。默认值为0666。</li><li><strong>default_owner：</strong>权限文件中未明确匹配的所有节点的默认所有者。默认值为root。</li><li><strong>default_group：</strong>权限文件中未明确匹配的所有节点的默认组。默认值为root。</li></ul><h2 id="5-udevadm工具使用"><a href="#5-udevadm工具使用" class="headerlink" title="5. udevadm工具使用"></a>5. udevadm工具使用</h2><blockquote><p>udevadm 后接一个命令和命令指定选项。它控制了udev运行的行为，处理内核事件，控制事件队列，并且提供简单的调试机制。</p></blockquote><h3 id="5-1-udevadm-info"><a href="#5-1-udevadm-info" class="headerlink" title="5.1 udevadm info"></a>5.1 udevadm info</h3><ul><li><p>查询udev数据库中的设备信息。也可以从sysfs文件系统中查询到设备的属性以辅助创建udev规则。</p><p>用法：</p><blockquote><p>udevadm info OPTIONS</p></blockquote></li><li><p><strong>option</strong>：</p><ul><li><p>-q, –query=TYPE：**默认值为：<code>all</code>**，从数据库中查询指定类型的设备。需要<code>--path</code>或<code>--name</code>来指定设备，可取以下值:</p></li><li><p>name：查询设备节点名称</p><p><img src="/post/26097/image-20210407224450315.png" alt="image-20210407224450315"></p></li><li><p>symlink：查询符号链接节点</p><p><img src="/post/26097/image-20210407224605700.png" alt="image-20210407224605700"></p></li><li><p>path：查询设备在sys文件系统(/sys)的路径</p><p><img src="/post/26097/image-20210407224644180.png" alt="image-20210407224644180"></p></li><li><p>property：查询设备属性</p><p><img src="/post/26097/image-20210407224733041.png" alt="image-20210407224733041"></p></li><li><p>all：查询所有的信息</p><p><img src="/post/26097/image-20210407224858967.png" alt="image-20210407224858967"></p></li><li><p>-p, –path=DEVPATH：设备的路径(可通过–query=path得到该路径)</p></li><li><p>-n, –name=FILE：设备节点或者链接</p></li><li><p>-a, –attribute-walk打印指定设备的所有sysfs记录的属性，以用来udev规则匹配特殊的设备(该选项打印当前设备节点的信息以及父级设备信息)</p></li><li><p>-d, –device-id-of-file=FILE：打印主/从设备号</p><p><img src="/post/26097/image-20210407225242963.png" alt="image-20210407225242963"></p></li><li><p>-e, –export-db：输出udev数据库中的内容</p></li></ul></li></ul><h3 id="5-2-udevadm-trigger"><a href="#5-2-udevadm-trigger" class="headerlink" title="5.2 udevadm trigger"></a>5.2 udevadm trigger</h3><ul><li><p>强制内核触发设备事件，主要用于重放内核初始化过程中的冷插(coldplug)设备事件。</p><p>用法：</p><blockquote><p>udevadm trigger OPTIONS</p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-v, –verbose：显示被触发的设备列表</p></li><li><p>-n, –dry-run：并不真正触发设备事件</p></li><li><p>-t, –type=TYPE：仅触发特定类型的设备，TYPE 可以是下列值之一：<code>**devices**</code>(默认值), <code>**subsystems**</code></p></li><li><p>-c, –action=ACTION：指定触发哪种类型的设备事件，ACTION 可以是下列值之一： add, remove, change(默认值)</p></li><li><p>-s, –subsystem-match=SUBSYSTEM：仅触发属于 SUBSYSTEM 子系统的设备事件(<strong>如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则，也就是说，所有匹配的子系统中的设备都会被触发。可以在SUBSYSTEM中使用shell风格的通配符。</strong>)</p></li><li><p>-S, –subsystem-nomatch=SUBSYSTEM：不触发属于SUBSYSTEM系统的设备事件。可以在SUBSYSTEM中使用shell风格的通配符。如果多次使用此选项，那么表示以AND逻辑连接每个匹配规则，也就是说，只有不匹配所有指定子系统的设备才会被触发。</p></li><li><p>-a, –attr-match=ATTRIBUTE=VALUE：仅触发那些在设备的sysfs目录中存在ATTRIBUTE文件的设备事件。如果同时还指定了”=VALUE”，那么表示仅触发那些 ATTRIBUTE 文件的内容匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定属性的设备才会被触发。</p></li><li><p> -A, –attr-nomatch=ATTRIBUTE=VALUE：不触发那些在设备的sysfs目录中存在ATTRIBUTE文件的设备事件。如果同时还指定了”=VALUE”，那么表示不触发那些ATTRIBUTE文件的内容匹配VALUE的设备事件。注意，可以在VALUE中使用shell风格的通配符。 如果多次使用此选项，那么表示以 AND 逻辑连接每个匹配规则， 也就是说，只有不匹配所有指定属性的设备才会被触发。</p></li><li><p>-p, –property-match=PROPERTY=VALUE：仅触发那些设备的PROPERTY属性值匹配 VALUE 的设备事件。注意，可以在 VALUE 中使用shell风格的通配符。如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则，也就是说，匹配任意一个属性值的设备都会被触发。</p></li><li><p>-g, –tag-match=PROPERTY： 仅触发匹配 PROPERTY 标签的设备事件。如果多次使用此选项， 那么表示以 AND 逻辑连接每个匹配规则，也就是说，只有匹配所有指定标签的设备才会被触发。</p></li><li><p>-y, –sysname-match=SYSNAME： 仅触发设备sys名称(也就是该设备在 /sys 路径下最末端的文件名)匹配 SYSNAME 的设备事件。 注意，可以在 SYSNAME 中使用shell风格的通配符。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，匹配任意一个sys名称的设备都会被触发。</p></li><li><p>–name-match=DEVPATH： 触发给定设备及其所有子设备的事件。DEVPATH 是该设备在 /dev 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p></li><li><p>-b, –parent-match=SYSPATH： 触发给定设备及其所有子设备的事件。SYSPATH 是该设备在 /sys 目录下的路径。 如果多次使用此选项，那么仅以最后一个为准。</p></li><li><p>-w, –settle： 除了触发设备事件之外，还要等待这些事件完成。 注意，此选项仅等待该命令自身触发的事件完成， 而 <strong>udevadm settle</strong> 则要一直等到 所有设备事件全部完成。</p></li><li><p>–wait-daemon[=SECONDS]： 在触发设备事件之前，等待 systemd-udevd 守护进程完成初始化。 默认等待 5 秒之后超时(可以使用 SECONDS 参数修改)。 此选项等价于在 <strong>udevadm trigger</strong> 命令之前先使用 <strong>udevadm control –ping</strong> 命令。</p></li></ul><h3 id="5-3-udevadm-control"><a href="#5-3-udevadm-control" class="headerlink" title="5.3 udevadm control"></a>5.3 udevadm control</h3><ul><li><p>控制udev守护进程(<code>systemd-udevd</code>)的内部状态。</p><p>用法：</p><blockquote><p>udevadm control option</p></blockquote></li><li><p><strong>options</strong></p></li><li><p> -l, –log-priority=value<strong>：</strong>设置的内部日志等级。可以用数字或文本表示：remerg(0), alert(1), crit(2), err(3), warning(4), notice(5), info(6), debug(7)</p></li><li><p>-s, –stop-exec-queue：向 systemd-udevd 发送”禁止处理事件”信号，这样所有新发生的事件都将进入等候队列。</p></li><li><p>-S, –start-exec-queue：向systemd-udevd发送”开始处理事件”信号，也就是开始处理事件队列中尚未处理的事件。</p></li><li><p>-R, –reload：向 systemd-udevd 发送”重新加载”信号，也就是重新加载udev规则与各种数据库(包括内核模块索引)。 注意，重新加载之后并不影响已经存在的设备， 但是新的配置将会应用于所有将来发生的新设备事件。</p></li><li><p>-p, –property=KEY=value：为所有将来发生的新设备事件统一设置一个全局的 KEY 属性，并将其值设为 value</p></li><li><p>-m, –children-max=value：设置最多允许 systemd-udevd 同时处理多少个设备事件。</p></li></ul><h3 id="5-4-udevadm-monitor"><a href="#5-4-udevadm-monitor" class="headerlink" title="5.4 udevadm monitor"></a>5.4 udevadm monitor</h3><ul><li><p>监视内核发出的设备事件(以”KERNEL”标记)，以及udev在处理完udev规则之后发出的事件(以”UDEV”标记)，并在控制台上输出事件的设备路径(devpath)。可用于分析udev处理设备事件所花的时间(比较”KERNEL”与”UDEV”的时间戳)。</p><p>用法：</p><blockquote><p>udevadm monitor options</p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-k, –kernel：仅显示”KERNEL”事件</p></li><li><p>-u, –udev：仅显示”UDEV”事件</p></li><li><p>-p, –property：同时还显示事件的各属性</p></li><li><p>-s, –subsystem-match=subsystem[/devtype]： 根据 subsystem[/devtype] 对事件(包括 kernel uevent 与 udev event)进行过滤，仅显示与”子系统[/设备类型]”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，所有指定子系统中的设备都会被监视。</p></li><li><p>-t, –tag-match=string：根据设备标签对事件(仅 udev event)进行过滤，仅显示与”标签”匹配的”UDEV”事件。 如果多次使用此选项，那么表示以 OR 逻辑连接每个匹配规则， 也就是说，拥有任一指定标签的设备都会被监视。</p></li></ul><h3 id="5-5-udevadm-test"><a href="#5-5-udevadm-test" class="headerlink" title="5.5 udevadm test"></a>5.5 udevadm test</h3><ul><li><p>模拟一个设备事件，并输出调试信息。</p><p>用法：</p><blockquote><p>udevadm test OPTIONS <syspath></syspath></p></blockquote></li><li><p><strong>options</strong></p></li><li><p>-a, –action=ACTION：指定模拟哪种类型的设备事件，ACTION 可以是下列值之一：add(默认值), remove, change</p></li></ul><h3 id="5-5-1-演示"><a href="#5-5-1-演示" class="headerlink" title="5.5.1 演示"></a>5.5.1 演示</h3><ul><li><p>如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm test $(udevadm info -q path -n &#x2F;dev&#x2F;sda)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408094410301.png" alt="image-20210408094410301"></p></li></ul><h2 id="6-udev测试演示"><a href="#6-udev测试演示" class="headerlink" title="6. udev测试演示"></a>6. udev测试演示</h2><ol><li><p><strong>插入usb摄像头，查询摄像头信息(<code>有两种方式可查询</code>)</strong></p><ul><li><p>执行以下命令后再将摄像头插入</p></li><li><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm monitor -p --subsystem-match&#x3D;input<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><img src="/post/26097/image-20210408095551985.png" alt="image-20210408095551985"></p></li><li><p>通过设备节点名查询信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm info -q all -n &#x2F;dev&#x2F;input&#x2F;event2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408095710873.png" alt="image-20210408095710873"></p></li></ul></li><li><p><strong>查询KERNEL信息</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm info -q all -a -n &#x2F;dev&#x2F;input&#x2F;event2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408100243875.png" alt="image-20210408100243875"></p></li><li><p><strong>创建规则</strong></p><blockquote><p>根据以上查询可以得到以下信息</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ACTION&#x3D;&#x3D;&quot;add&quot; SUBSYSTEM&#x3D;&#x3D;&quot;input&quot; KERNEL&#x3D;&#x3D;&quot;event2&quot; ENV&#123;ID_TYPE&#125;&#x3D;&#x3D;&quot;video&quot;  ENV&#123;ID_BUS&#125;&#x3D;&#x3D;&quot;usb&quot; SYMLINK+&#x3D;&quot;input&#x2F;usb_camera&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ul><li><p>在<code>/etc/udev/rules.d/</code>目录下创建<code>usb_camera.rules</code>规则文件</p></li><li><p>重新加载udev</p><pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">udevadm control -R<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行以下命令，重新触发事件后可以看到生成<code>usb_camera</code>符号链接</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">udevadm trigger --action&#x3D;add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/26097/image-20210408140008962.png" alt="image-20210408140008962"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> udev </tag>
            
            <tag> linux </tag>
            
            <tag> udev规则 </tag>
            
            <tag> udev工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zynq无法识别usb摄像头</title>
      <link href="post/19321.html"/>
      <url>post/19321.html</url>
      
        <content type="html"><![CDATA[<p>在Zynq(核心板：<code>创龙 SOM-TL7020</code>)上接入usb摄像头，无法识别usb摄像头，没有在/dev目录下生成video节点</p><p><img src="/post/19321/image-20210331091713253.png" alt="image-20210331091713253"></p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h2><ul><li>缺少驱动，要支持usb的摄像头，需要 v4l2驱动和UVC驱动</li></ul><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2. 解决方法"></a>2. 解决方法</h2><ul><li>将v4l2驱动和UVC驱动编译进内核，然后重新编译内核即可。</li><li>内核默认已支持v4l2驱动，添加UVC驱动即可。</li></ul><h3 id="2-1-配置内核"><a href="#2-1-配置内核" class="headerlink" title="2.1 配置内核"></a>2.1 配置内核</h3><ul><li><p>CONFIG_USB_VIDEO_CLASS<br>CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV</p><p>将以上两个宏设置为<code>y</code></p><p><img src="/post/19321/image-20210331092252053.png" alt="image-20210331092252053"></p><blockquote><p>重新编译内核</p></blockquote></li></ul><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><ul><li><p>接入usb摄像头，能够正常识别。</p><p><img src="/post/19321/image-20210331093210237.png" alt="image-20210331093210237"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zynq </tag>
            
            <tag> usb摄像头 </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot配置从网络加载linux系统</title>
      <link href="post/45266.html"/>
      <url>post/45266.html</url>
      
        <content type="html"><![CDATA[<p>基于<code>广州创龙</code>的TL5728-EasyEVM开发板配置uboot通过tftp加载内核、设备树， 内核通过nfs挂载nfs文件系统。</p><blockquote><p>ubuntu需要先安装tftp/nfs服务。</p></blockquote><p><strong>u-boot环境变量已提供<code>netboot</code>变量来实现从网络加载linux系统</strong></p><p><img src="/post/45266/image-20210323103650020.png" alt="image-20210323103650020"></p><h2 id="1-u-boot环境变量配置"><a href="#1-u-boot环境变量配置" class="headerlink" title="1. u-boot环境变量配置"></a>1. u-boot环境变量配置</h2><h3 id="1-1-配置通过tftp加载内核、设备树"><a href="#1-1-配置通过tftp加载内核、设备树" class="headerlink" title="1.1 配置通过tftp加载内核、设备树"></a>1.1 配置通过tftp加载内核、设备树</h3><ol start="2"><li><p>设置<code>serverip</code>变量（提供tftp、nfs服务的主机ip）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv serverip 192.168.1.99<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>ipaddr</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv ipaddr 192.168.1.144<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>fdtfile</code>变量（<strong>即配置设备树文件名</strong>）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv fdtfile tl5728-easy-evm.dtb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-2-验证加载内核、设备树是否正常"><a href="#1-2-验证加载内核、设备树是否正常" class="headerlink" title="1.2 验证加载内核、设备树是否正常"></a>1.2 验证加载内核、设备树是否正常</h3><ul><li><p>执行以下两条命令，出现下图所示，则说明加载内核、设备树成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">run netloadimagerun netloadfdt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/post/45266/image-20210323104653075.png" alt="image-20210323104653075"></p></li></ul><h3 id="1-3-u-boot配置内核从nfs挂载文件系统"><a href="#1-3-u-boot配置内核从nfs挂载文件系统" class="headerlink" title="1.3 u-boot配置内核从nfs挂载文件系统"></a>1.3 u-boot配置内核从nfs挂载文件系统</h3><ol><li><p>设置<code>rootpath</code>变量</p><blockquote><p>nfs共享文件系统路径</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv rootpath &#x2F;home&#x2F;llr&#x2F;work&#x2F;nfs-share<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置<code>netboot</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv netboot &#39;echo Booting from network ...; run netloadimage; run netloadfdt; run netargs; bootz $&#123;loadaddr&#125; - $&#123;fdtaddr&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动系统</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">run netboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-4-设置bootcmd变量，上电开机从网络启动系统"><a href="#1-4-设置bootcmd变量，上电开机从网络启动系统" class="headerlink" title="1.4 设置bootcmd变量，上电开机从网络启动系统"></a>1.4 设置bootcmd变量，上电开机从网络启动系统</h3><ol><li><p>设置<code>bootcmd</code>变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setenv bootcmd &#39;run netboot&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存uboot环境变量</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="1-5-其他参考"><a href="#1-5-其他参考" class="headerlink" title="1.5 其他参考"></a>1.5 其他参考</h3><ul><li>​    有关通过nfs挂载文件系统说明文档，可查看在内核源码目录下的<code>Documentation/filesystems/nfs/nfsroot.txt</code>文件</li><li><a href="https://linuxlink.timesys.com/docs/static_ip">https://linuxlink.timesys.com/docs/static_ip</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode使用</title>
      <link href="post/3653.html"/>
      <url>post/3653.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-插件说明"><a href="#1-插件说明" class="headerlink" title="1. 插件说明"></a>1. 插件说明</h2><ol><li><p>C/C++</p><p>C/C++开发必装插件</p></li><li><p>Include AutoComplete</p><p>自动头文件包含 </p></li><li><p>Rainbow Brackets</p><p>彩虹花括号，有助于阅读代码</p></li><li><p>ARM</p><p>支持 ARM 汇编语法高亮显示</p></li><li><p>Chinese(Simplified)</p><p>中文环境</p></li><li><p>TabNine</p><p>自动补全插件</p></li><li><p>DeviceTree</p><p>设备树语法插件</p></li><li><p>GBKtoUTF8</p><p>将 GBK 转换为 UTF8</p></li><li><p>git graph</p><p>显示git 有关的所有代码提交信息，可以方便查看本地分支、远程分支、主干的 commit、push、pull 情况</p></li></ol><h2 id="2-实用功能"><a href="#2-实用功能" class="headerlink" title="2. 实用功能"></a>2. 实用功能</h2><h3 id="2-1-两个文件比较"><a href="#2-1-两个文件比较" class="headerlink" title="2.1 两个文件比较"></a>2.1 两个文件比较</h3><ul><li><p>比较文件</p><p><img src="/post/3653/image-20210322235108892.png" alt="image-20210322235108892"></p><p><img src="/post/3653/image-20210322235222241.png" alt="image-20210322235222241"></p><p><img src="/post/3653/image-20210322235317023.png" alt="image-20210322235317023"></p></li></ul><h3 id="3-2-函数列表"><a href="#3-2-函数列表" class="headerlink" title="3.2 函数列表"></a>3.2 函数列表</h3><ul><li><p>点击<code>左下角</code>大纲可查看当前打开的文件的函数列表</p><p><img src="/post/3653/image-20210403230716148.png" alt="image-20210403230716148"></p></li></ul><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><h3 id="3-1-取消预览模式"><a href="#3-1-取消预览模式" class="headerlink" title="3.1 取消预览模式"></a>3.1 取消预览模式</h3><ul><li><p>VScode 上打开一个新文件的话会覆盖掉以前的文件，这是因为 VSCode 默认开启了预览模式，预览模式下单击左侧的文件就会覆盖掉当前的打开的文件。如果不想覆盖的话采用双击打开即可，或者设置 VSCode 关闭预览模式</p><p><img src="/post/3653/image-20210323151845681.png" alt="image-20210323151845681"></p></li></ul><h3 id="3-2-添加头文件路径"><a href="#3-2-添加头文件路径" class="headerlink" title="3.2 添加头文件路径"></a>3.2 添加头文件路径</h3><ul><li><p>按下“<code>Ctrl+Shift+P</code>”打开搜索框，然后输入“<code>Edit configurations</code>”，选择“<code>C/C++:Edit configurations</code>”</p><p><img src="/post/3653/image-20210323152230025.png" alt="image-20210323152230025"></p><p>c_cpp_properties.json 中的变量“<code>includePath</code>”用于指定工程中的头文件路径</p><p><img src="/post/3653/image-20210323152411219.png" alt="image-20210323152411219"></p></li></ul><h3 id="4-快捷键"><a href="#4-快捷键" class="headerlink" title="4. 快捷键"></a>4. 快捷键</h3><table><thead><tr><th align="center">Ctrl+鼠标左键</th><th align="center">是文件、函数等跳转</th></tr></thead><tbody><tr><td align="center">Alt + ←</td><td align="center">是跳转后返回原处</td></tr><tr><td align="center">Ctrl + Shift + O</td><td align="center">列出函数名</td></tr><tr><td align="center">Ctrl + P</td><td align="center">列出近期打开的文件名</td></tr><tr><td align="center">Ctrl + Tab</td><td align="center">可以列出最近打开的文件，在开发时，两个文件间切换时效率很高。</td></tr><tr><td align="center">ctrl+p</td><td align="center">查找文件</td></tr><tr><td align="center">ctrl + shift + \</td><td align="center">在对应的{}跳转</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMX8使用weston-calibrator无法校准</title>
      <link href="post/46514.html"/>
      <url>post/46514.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1. 环境说明"></a>1. 环境说明</h2><blockquote><p>yocto：3.0(<code>zeus</code>)</p><p>linux：5.4.70-2.3.0</p><p>weston：9.0</p><p>触摸屏：LVDS屏</p></blockquote><h2 id="2-排查问题"><a href="#2-排查问题" class="headerlink" title="2. 排查问题"></a>2. 排查问题</h2><h3 id="2-1-确定触摸节点是否能接受到事件"><a href="#2-1-确定触摸节点是否能接受到事件" class="headerlink" title="2.1 确定触摸节点是否能接受到事件"></a>2.1 确定触摸节点是否能接受到事件</h3><p><img src="/post/46514/image-20210317152007220.png" alt="image-20210317152007220"></p><blockquote><p>触摸节点能正常接收到触摸事件</p></blockquote><h3 id="2-2-查看weston日志"><a href="#2-2-查看weston日志" class="headerlink" title="2.2 查看weston日志"></a>2.2 查看weston日志</h3><p>/run/user/0/weston.log</p><p>发现日志中有以下问题， 经过查找资料后得知。</p><blockquote><p>内核中的触摸屏驱动程序运行不正常，libinput 不接受输入(<code>weston依赖libinput</code>)，所以导致使用weston-calibrator无法校准</p></blockquote><p><img src="/post/46514/image-20210317151744111.png" alt="image-20210317151744111"></p><h3 id="2-3-使用libinput-debug-events进行调试"><a href="#2-3-使用libinput-debug-events进行调试" class="headerlink" title="2.3 使用libinput debug-events进行调试"></a>2.3 使用libinput debug-events进行调试</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">libinput debug-events<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/46514/image-20210317152754075.png" alt="image-20210317152754075"></p><blockquote><p>运行libinput 工具后， 可以看到红色部分提示触摸屏驱动程序存在问题。</p></blockquote><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><blockquote><p>修改触摸屏驱动</p><p>参考：<a href="https://wiki.postmarketos.org/wiki/Troubleshooting:touchscreen">https://wiki.postmarketos.org/wiki/Troubleshooting:touchscreen</a></p><p>经过修改触摸屏驱动后，重新编译内核，使用weston-calibrator能够正常校准。</p></blockquote><h2 id="3-经过校准后，点击屏幕位置有偏差"><a href="#3-经过校准后，点击屏幕位置有偏差" class="headerlink" title="3. 经过校准后，点击屏幕位置有偏差"></a>3. 经过校准后，点击屏幕位置有偏差</h2><p>使用weston和tslib校准工具调试，发现在屏幕按<code>X轴</code>来滑动，校准工具打印出的是<code>Y轴</code>的值在改变。（<code>也可以使用libinput工具调试</code>）</p><p>经过排查后发现触摸屏的引脚定义是按竖屏，和我们使用的横屏效果反过来，经过调整排线线序后， 重新测试校准。校准后位置偏差问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IMX8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译内核出现无法定位strict.pm</title>
      <link href="post/2920.html"/>
      <url>post/2920.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1. 环境说明"></a>1. 环境说明</h2><blockquote><p>虚拟机：Ubuntu 16.04.5</p><p>sdk：使用TI提供的ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86-Install.bin</p><p>内核版本：linux-4.9.65</p></blockquote><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><ol><li><p>在编译内核过程中出现以下错误：</p><p><img src="/post/2920/image-20210318003635703.png" alt="image-20210318003635703"></p></li></ol><h2 id="3-排查"><a href="#3-排查" class="headerlink" title="3. 排查"></a>3. 排查</h2><ol><li><p>经过排查发现<code>processor-sdk</code>包里包含<code>perl</code>工具，在使用以下命令导入交叉编译工具时，会将<code>sdk</code>自带的<code>perl</code>工具也导入到当前的环境中。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PATH&#x3D;&#x2F;home&#x2F;llr&#x2F;ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86&#x2F;linux-devkit&#x2F;sysroots&#x2F;x86_64-arago-linux&#x2F;usr&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/2920/image-20210318004109095.png" alt="image-20210318004109095"></p><blockquote><p><code>perl</code>工具和<code>交叉编译工具</code>在同一目录下。通过<code>export</code>导入交叉编译工具时，也导入了<code>perl</code>工具。</p></blockquote><p>而ubuntu默认也安装了<code>perl</code>，所以造成冲突。导致在编译内核时出现<code>Can&#39;t locate strict.pm in @INC (you may need to install the strict module)</code></p></li></ol><h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><ul><li><p>使用<code>PERL5LIB</code>环境变量指定<code>perl</code>模块所在的目录即可。如下：</p><p>将<code>perl</code>模块目录指定到sdk包下的目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export PERL5LIB&#x3D;&#x2F;home&#x2F;llr&#x2F;ti-processor-sdk-linux-rt-am57xx-evm-04.03.00.05-Linux-x86&#x2F;linux-devkit&#x2F;sysroots&#x2F;armv7ahf-neon-linux-gnueabi&#x2F;usr&#x2F;lib&#x2F;perl&#x2F;5.22.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新编译内核即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>usb3.0接口测试</title>
      <link href="post/56523.html"/>
      <url>post/56523.html</url>
      
        <content type="html"><![CDATA[<p>基于 <code>创龙</code> 5708平台下测试usb3.0接口。测试DM/DP、RXN/RXP、TXN/TXP信号线是否正常。</p><p><strong>原理图不提供</strong></p><blockquote><p>USB是一种差分信号，数据是由正、负信号的差值所决定 </p><p>DM/DP差分对信号线与USB2.0的连接方式一样，只要一对一直接连接就可以。 </p><p>usb3.0需要用到RXP/RXN,TXP/TXN差分对来进行高速的数据传输 </p><p>因为需要测试usb3.0，需要拆除TX端的电容，当电容拆除后，TX端的线就断开了，就不能使用 usb3.0协议，只能使用usb2.0协议</p></blockquote><blockquote><p><strong>拆掉其中一个usb3.0接口的电容，这里拆掉C102/C103电容。另一个usb3.0接口保持不变</strong></p></blockquote><ol><li><p>使用usb3.0 U盘接到<code>已拆除电容</code>的usb3.0接口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard.png" alt="img"></p></li><li><p>使用usb3.0 U盘接到<code>未拆除电容</code>的usb3.0接口</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard-1615395634957.png" alt="img"></p></li><li><p>使用<code>usb2.0 U盘</code>接到<code>已拆除电容</code>和<code>未拆除电容</code>的<code>usb 3.0</code>接口，结果都一样，如下图</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">使用 lsblk -S 命令扫描usb设备<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/post/56523/clipboard-1615395726474.png" alt="img"></p><blockquote><p><strong>结论：</strong>测试usb3.0接口，需要用usb3.0的设备，如果使用的是usb2.0设备，则无法测试到RX 和TX的信号线是否正常</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外设测试 </tag>
            
            <tag> usb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo引用本地图片</title>
      <link href="post/30757.html"/>
      <url>post/30757.html</url>
      
        <content type="html"><![CDATA[<p>hexo引用本地图片, 本地编辑器里可以直接<code>预览图片</code>，发布的文章图片也可以<code>正常显示</code>。</p><blockquote><p>hexo版本：5.4.0</p></blockquote><h2 id="1-引用本地图片"><a href="#1-引用本地图片" class="headerlink" title="1. 引用本地图片"></a>1. 引用本地图片</h2><ol><li><p>首先要在 Hexo 博客配置文件(<code>_config.yml</code>)中开启使用本地资源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">post_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建博客文件(<code>.md文件</code>)</p><p>首先在 <code>_posts</code> 文件夹下建立一个博客文件(<code>例如：hexo引用本地图片.md</code>)，然后再创建一个同名的文件夹(<code>hexo引用本地图片</code>)，这篇文章要引用的图片就在这个文件夹下。</p><blockquote><p>使用Typora插入图片，必须勾选 <code>优先使用相对路径</code></p><p>文件 -&gt; 偏好设置 -&gt; 图像 -&gt; 优先使用相对路径</p></blockquote><p><img src="/post/30757/image-20210308163658889.png" alt="image-20210308163658889"></p></li><li><p>安装hexo-asset-image插件</p><blockquote><p><strong>注意：使用了 npm 仓库里的插件 hexo-asset-image有问题，需要从Github 仓库的源码安装才正常</strong></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install https:&#x2F;&#x2F;github.com&#x2F;xcodebuild&#x2F;hexo-asset-image.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，在Typora中向文章插入图片能实时预览，部署文章后。图片显示也正常。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
